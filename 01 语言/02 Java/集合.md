# 容器

## 容器比较

几个Set类型：HashSet、TreeSet、LinkedHashSet。

HashSet获取元素最快。

TreeSet按照比较结果的升序保存对象。

LinkedHashSet按照被添加的顺序保存对象。

几个Map类型：HashMap、TreeMap、LinkedHashMap。

HashMap查找最快。

TreeMap按照升序保存键。

LinkedHashMap按照插入顺序保存键。

## 迭代器

Iterator很常见，是一个单方向的迭代器，ListIterator不太常见，它的功能很多，可以进行双向访问，不仅可以remove，还可以set，具体功能可以见文档。

```java
public class Main {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            list.add(String.valueOf((char) ('a' + i)));
        }

        ListIterator<String> iterator = list.listIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.nextIndex() + ":" + iterator.next());
        }
    }

}
```

## 栈和队列

LinkedList可以实现栈和队列的功能，Stack这个类继承了Vector，而Vector已经不用了，所以需要使用栈和队列的地方可以换成LinkedList，下面列举LinkedList栈和队列的方法。

### 队列的操作

**peek**

```java
public E peek() {
    final Node<E> f = first;
    return (f == null) ? null : f.item;
}
```

获取队列第一个节点，但不删除。如果队列为空就返回null。

**poll**

```java
public E poll() {
    final Node<E> f = first;
    return (f == null) ? null : unlinkFirst(f);
}
```

获取队列第一个节点，并删除。如果队列为空就返回null。

**offer/add**

```java
public boolean offer(E e) {
    return add(e);
}
```

在队列结尾添加一个元素，可以为null。

这些方法还有一些类似功能的，只不过不能放/取null值，遇到null会报错。

### 栈的操作

**peek**

```java
public E peek() {
    final Node<E> f = first;
    return (f == null) ? null : f.item;
}
```

获取栈的头节点，但不删除。如果队列为空就返回null。

**push**

```java
public void push(E e) {
    addFirst(e);
}
```

往栈里添加一个元素。

**pop**

```java
public E pop() {
    return removeFirst();
}
```

栈弹出一个元素。

### 优先级队列PriorityQueue

先进先出描述了最典型的队列规则。队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是等待时间最长的元素。优先级队列声明下一个弹出元素是最需要的元素(具有最高的优先级)。

**demo**

```java
public class Main {
    public static void main(String[] args) {
        Random random = new Random();

        PriorityQueue<Person> priorityQueue = new PriorityQueue<>();
        for (int i = 0; i < 10; i++) {
            priorityQueue.add(new Person(random.nextInt(100) + 1, random.nextInt(1000000)));
        }

        for (int i = 0; i < 10; i++) {
            System.out.println(priorityQueue.poll());
        }
    }

    private static class Person implements Comparable<Person> {
        int age;
        int money;
        public Person(int age, int money) {
            this.age = age;
            this.money = money;
        }
        private int weight() {
            return (int) (money * 0.5 - age * 10);
        }
        @Override
        public String toString() {
            return "I am " + age + " years old, I hava ¥" + money;
        }
        @Override
        public int compareTo(Person o) {
            return Integer.compare(o.weight(),weight());
        }
    }
}

output：
I am 72 years old, I hava ¥893784
I am 1 years old, I hava ¥887114
I am 52 years old, I hava ¥828050
I am 48 years old, I hava ¥715618
I am 80 years old, I hava ¥664334
I am 98 years old, I hava ¥410442
I am 24 years old, I hava ¥381874
I am 48 years old, I hava ¥298060
I am 16 years old, I hava ¥258399
I am 91 years old, I hava ¥88100
```

>   这个demo演示了人的优先级，weight表示了年龄和财富的加权值，可以看到，富裕的年轻人优先级很高，而穷老头没什么优先级。（乱搞的，溜了溜了）

PriorityQueue使用自然排序对对象进行排序，也可以在构造方法里传入比较器Comparator来指定排序方式，其余操作和Queue一样。

## 总结

![6](/Users/mezzsy/Projects/EffectiveBlog/01 语言/02 Java/assets/12.jpg)

## 在迭代中删除元素

[禁止在foreach循环里进行元素的remove-add操作](禁止在foreach循环里进行元素的remove-add操作.md)

