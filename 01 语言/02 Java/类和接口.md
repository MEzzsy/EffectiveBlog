# 面向对象

## 五大原则

1. **单一职责原则（Single-Resposibility Principle）**
    其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。
2. **开放封闭原则（Open-Closed principle）**
    其核心思想是：软件实体应该是可扩展的，而不可修改的。
3. **里氏替换原则（Liskov-Substituion Principle）**
    其核心思想是：子类必须能够替换其基类。
4. **依赖倒置原则（Dependecy-Inversion Principle）**
    其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
5. **接口隔离原则（Interface-Segregation Principle）**
    其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。

## 面向对象三大特征

- **封装**：隐藏类的内部实现机制。
- **继承**：重用父类代码，实现多态。
- **多态**：同一方法可以根据对象的不同而采用多种不同的行为方式。

## 对java多态的理解

对于一个方法传入不同的对象类型表现出不同的行为。Java实现的方式是动态绑定和向上转型。

动态绑定：在运行时根据对象的类型进行绑定。。

向上转型：把对某个对象的引用视为对其父类的引用的做法称作向上转型。

**动态绑定（后期绑定、运行时绑定）**：在运行时根据对象的类型进行绑定。

多态的作用：消除类型之间的耦合关系。

实现多态的三个必要条件：继承、重写、向上转型。

向上转型：把对某个对象的引用视为对其父类的引用的做法称作向上转型——在继承树上，父类是放在上方的。

## 对java继承的理解

 一个是对代码的复用。

另一个是对通用版本的特殊化。

## 面向过程和面向对象的区别

**面向过程** 

优点：
性能比面向对象高，因为类调用时需要实例化。 

缺点：
没有面向对象易维护、易复用、易扩展。

**面向对象** 

优点：
易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 

缺点：
性能比面向过程低。

# 初始化与清理

## 重载

每个重载的方法都必须有一个独一无的参数类型列表。甚至参数顺序的不同也足以区分两个方法。

基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，下面举几个例子

**demo1**

```java
class OverloadMethods {
    public static void main(String[] args) {
        overloadMethod(1);
    }
    private static void overloadMethod(){
        System.out.println("无参方法");
    }
    private static void overloadMethod(int i){
        System.out.println("参数为int的方法");
    }
    private static void overloadMethod(Integer i){
        System.out.println("参数为Integer的方法");
    }
    private static void overloadMethod(int... ints){
        System.out.println("参数为int[]的方法");
    }
    private static void overloadMethod(Integer... integers){
        System.out.println("参数为Integer[]的方法");
    }
    private static void overloadMethod(Object o){
        System.out.println("参数为Object的方法");
    }
}

output:
参数为int的方法

将int注释：
参数为Integer的方法

如上，并将Integer注释：
参数为Object的方法

如上，并将Object注释：
错误: 对overloadMethod的引用不明确
OverloadMethods 中的方法 overloadMethod(int...) 和 OverloadMethods 中的方法 overloadMethod(Integer...) 都匹配

如上，并将Integer[]注释：
参数为int[]的方法
```

**demo2**

```java
public static void main(String[] args) {
    overloadMethod(1);
}

private static void overloadMethod(int i){
    System.out.println("参数为int的方法");
}

private static void overloadMethod(long i){
    System.out.println("参数为long的方法");
}

output:
参数为int的方法
```

**demo3**

```java
public static void main(String[] args) {
        overloadMethod(1.1);
    }

    private static void overloadMethod(float i){
        System.out.println("参数为float的方法");
    }

    private static void overloadMethod(double i){
        System.out.println("参数为double的方法");
    }
    
output:
1的时候
参数为float的方法

1.1的时候
参数为double的方法
```

**demo4**

```java
public static void main(String[] args) {
    f('a');
}

private static void f(int i) {
    System.out.println("int:" + i);
}

private static void f(long i) {
    System.out.println("long:" + i);
}

output:
int:97
```

**demo5**

```java
public class Main {
    public static void main(String[] args) {
        f((int) 111111111111111111L);
    }
    private static void f(int i) {
        System.out.println("int:" + i);
    }
}
```

demo1的可以这样总结：
传入基本数据类型，如int1，先寻找int类型，如果没有就寻找包装类型Integer，如果没有就寻找Object类型，如果没有，就寻找可变参数，如果同时存在int和Integer的可变参数，那么会报引用不明确错误。

如果传入的数据类型小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。（见demo4）

在这里，方法接受较小的基本类型作为参数。如果传入的实际参数较大，就得通过类型转
换来执行窄化转换。如果不这样做，编译器就会报错。（见demo5）

## this

```java
public class Main {
    int i;

    public static void main(String[] args) {
        Main a = new Main();
        Main b = new Main();

        a.f(1);
        b.f(2);
    }

    public void f(int i) {
        this.i = i;
        System.out.println(i);
    }

}
```

f方法是如何知道是被a还是被b所调用的呢?

为了能用简便、面向对象的语法来编写代码——即 “发送消息给对象”，编译器做了一些幕
后工作。它暗自把“所操作对象的引用”作为第一个参数传递给f。所以上述两个方法的内部的表示形式为：

```
Main.f(a,1);
Main.f(b,2);
```

如果希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this。 this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一类中的其他方法。

>   以上内容来自《Java编程思想》，经本人反编译Main类，并没有发现所谓内部的表示形式，可能有只是没看懂，所以这里的内容保留。

## finalize方法

见Java虚拟机。

## 初始化顺序

看看下面的demo：

```java
public class Main {
    static {
        i = 123;
        System.out.println("static代码块，静态变量前");
//        System.out.println("i=" + i);//非法向前引用
    }

    static int i = i();
    int j = j();

    public static void main(String[] args) {
        Main a = new Main();
    }

    static {
        System.out.println("static代码块，静态变量后");
    }

    {
        System.out.println("普通代码块，构造方法前");
    }

    public Main() {
        System.out.println("i=" + i);
        System.out.println("构造方法");
    }

    {
        System.out.println("普通代码块，构造方法后");
    }

    public static int i() {
        System.out.println(1);
        return 1;
    }

    public int j() {
        System.out.println(2);
        return 2;
    }

}
```

output：

```
static代码块，静态变量前
1
static代码块，静态变量后
2
普通代码块，构造方法前
普通代码块，构造方法后
i=1
构造方法
```

这里做个小结：

-   在静态变量前面的静态代码块可以对静态变量赋值，但是不能访问。

-   静态代码块的顺序相对静态变量是有影响的。
-   普通代码块的顺序对构造方法没有影响。
-   同样地，在普通变量前面的普通代码块也可以对普通变量赋值，但是不能访问。

## 对象的创建

总结一下对象创建的过程，假设有个名为Dog的类：

1. 即使没有显式地使用static关键字，构造器实际上是static。因此，当首次创建类型为Dog的对象的时候，或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
2. 然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象第一次加载的时候执行。
3. 当调用new Dog()创建对象的时候，首先在堆上为Dog对象分配足够的内存空间。
4. 这块内存空间会被清零，这就自动地将Dog对象中的所有基本数据类型都设置成了默认值，引用设置成了null。
5. 执行所有出现于字段定义处的初始化动作。（对成员变量的显式初始化）
6. 执行构造器。

# 访问权限限制

访问权限控制的等级，从最大权限到最小权限依次为：public，protected、包访问权限(没有关键词)和private。 

## 包：库单元

当编写一个Java源代码文件时，此文件通常被称为编译单元。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同(包括大小写，但不包括文件的后缀名.java)。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。

以下是可以接受的：

```java
package com.mezzsy.learnsomething;

public class Main {
    public static void main(String[] args) {
    }
}

class ClassA{	
}
```

ClassA类只能为包可见。

## 类的访问权限

类不能是private和protected，类只能是包访问权限（缺省）和public。如果不希望别人访问类，可以把构造器设置为private。

## 总结

**控制对成员的访问权限的原因：**

1. 为了使用户不要触碰那些不该触碰的部分，这些部分对于类内部的操作是必要的，但是不属于接口的一部分。
2. 为了让类库设计者可以更改类的内部工作方式而不必担心这样会对客户端程序员造成重大的影响。

**访问权限排序：**

1. public，无限制。(类只有public和缺省)
2. protected，包级访问以及子类访问。
3. 缺省，包级访问。
4. private，类级访问。

# 复用类

**复用类的方法：**

第一种方法：在新的类产生现有类的对象，由于新的类是由现有类的对象所组成，所以这种方法称为**组合**。

第二种方法：按照现有类的类型来创建新类。这种方式称为**继承**。

第三种方法：反射？

组合和继承的区别：

**组合**

组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。即，在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。为取得此效果，需要在新类中嵌入一个现有类的private对象。

有时，允许类的用户直接访问新类中的组合成分是极具意义的，也就是说，将成员对象声明为public。如果成员对象自身都隐藏了具体实现，那么这种做法是安全的。当用户能够了解到你正在组装组部件时， 会使得端口更加易于理解。

**继承**

在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。略微思考一下就会发现， 用一个“ 交通工具”对象来构成一部“车子”是毫无意义的，因为“车子”并不包含“交通工具”，它仅是一种交通工具(is-a关系)。

**“is-a”(是一个)的关系是用继承来表达的，而“has-a”(有一个)的关系则是用组合来表达的。**（可以用来回答什么时候用组合，什么时候用继承）

## final

用到final的三种情况：数据、方法、类。

### final数据

final数据一般用在：

1.  一个永不改变的编译时常量。

2.  一个在运行时被初始化的值，并且不希望它被改变。
3.  final用于引用表示引用恒定不变，而对于对象本身是可以修改的。

**空白final**

空白final可以延迟到构造方法再赋值：

```java
public class Main {
    final int i;

    public Main() {
        i = 1;
    }

    public Main(int i) {
        this.i = i;
    }
}
```

**final参数**

Java允许在参数列表中以声明的方式将参数指明为final。这样无法在方法中更改参数引用所指向的对象。

```java
public class Main {
    final int i;

    final int j = 2;

    int k = 3;

    {
        i = 1;
    }

}
```

反编译：

```
Classfile /Applications/Projects/Android/Learn/app/src/main/java/com/mezzsy/learnsomething/Main.class
  Last modified 2019年9月29日; size 338 bytes
  MD5 checksum 045e85c319f4532723fe996138775c75
  Compiled from "Main.java"
public class com.mezzsy.learnsomething.Main
  minor version: 0
  major version: 56
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #5                          // com/mezzsy/learnsomething/Main
  super_class: #6                         // java/lang/Object
  interfaces: 0, fields: 3, methods: 1, attributes: 1
Constant pool:
   #1 = Methodref          #6.#19         // java/lang/Object."<init>":()V
   #2 = Fieldref           #5.#20         // com/mezzsy/learnsomething/Main.j:I
   #3 = Fieldref           #5.#21         // com/mezzsy/learnsomething/Main.k:I
   #4 = Fieldref           #5.#22         // com/mezzsy/learnsomething/Main.i:I
   #5 = Class              #23            // com/mezzsy/learnsomething/Main
   #6 = Class              #24            // java/lang/Object
   #7 = Utf8               i
   #8 = Utf8               I
   #9 = Utf8               j
  #10 = Utf8               ConstantValue
  #11 = Integer            2
  #12 = Utf8               k
  #13 = Utf8               <init>
  #14 = Utf8               ()V
  #15 = Utf8               Code
  #16 = Utf8               LineNumberTable
  #17 = Utf8               SourceFile
  #18 = Utf8               Main.java
  #19 = NameAndType        #13:#14        // "<init>":()V
  #20 = NameAndType        #9:#8          // j:I
  #21 = NameAndType        #12:#8         // k:I
  #22 = NameAndType        #7:#8          // i:I
  #23 = Utf8               com/mezzsy/learnsomething/Main
  #24 = Utf8               java/lang/Object
{
  final int i;
    descriptor: I
    flags: (0x0010) ACC_FINAL

  final int j;
    descriptor: I
    flags: (0x0010) ACC_FINAL
    ConstantValue: int 2

  int k;
    descriptor: I
    flags: (0x0000)

  public com.mezzsy.learnsomething.Main();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_2
         6: putfield      #2                  // Field j:I
         9: aload_0
        10: iconst_3
        11: putfield      #3                  // Field k:I
        14: aload_0
        15: iconst_1
        16: putfield      #4                  // Field i:I
        19: return
      LineNumberTable:
        line 4: 0
        line 7: 4
        line 9: 9
        line 12: 14
        line 13: 19
}
SourceFile: "Main.java"
```

可以看到直接赋值的final变量、空白final变量、普通变量，初始化的动作都是放在构造方法中的。

### final方法

使用final方法的原因：

1. 防止继承。
2. 效率。（在Java SE5/6中，JVM自己去处理效率问题，不需要使用final方法进行优化了。）（？TODO 从虚拟机的角度分析）

private隐式的为final类型。如果子类写了一个与父类同名（也是private）的private方法，并不会覆盖。

final类中的方法隐式的为final方法。

### final类

表示该类不能被继承。

## 继承与初始化

```java
public class Human {

    public Human() {
        System.out.println("我被初始化");
    }

}

public class Father {

    private static Human sHuman = new Human();

    static {
        System.out.println("父类静态块");
    }

    {
        System.out.println("父类代码块");
    }

    public Father() {
        System.out.println("父类构造器");
    }

}

public class Son extends Father{
    private static Human sHuman=new Human();

    static {
        System.out.println("子类静态块");
    }

    {
        System.out.println("子类代码块");
    }

    public Son() {
        System.out.println("子类构造器");
    }

}

public static void main(String[] args) {
        Son son=new Son();
}

output：
我被初始化
父类静态块

我被初始化
子类静态块

父类代码块
父类构造器

子类代码块
子类构造器
//注：空行后添
```

**总结**

类的初始化顺序是： 

1. 初始化父类中的静态成员变量和静态代码块。
2. 初始化子类中的静态成员变量和静态代码块。
3. 初始化父类中的普通成员变量和代码块，在执行父类中的构造方法。
4. 初始化子类中的普通成员变量和代码块，在执行子类中的构造方法。

# 多态

**封装**：通过合并特征和行为来创建新的数据类型。

**多态**：消除类型之间的耦合。

## 向上转型

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种把对某个对象的引用视为对其基类型的引用的做法被称作向上转型。

## 转机

```java
public class Main {
    public static void main(String[] args) {
        say(new MyChild1());
    }
    
    private static void say(MyParent parent){
        parent.f();
    }

    private static class MyParent {
        public void f() {
            System.out.println("i am parent");
        }
    }

    private static class MyChild1 extends MyParent {
        @Override
        public void f() {
            System.out.println("i am child1");
        }
    }
    private static class MyChild2 extends MyParent {
        @Override
        public void f() {
            System.out.println("i am child2");
        }
    }
    private static class MyChild3 extends MyParent {
        @Override
        public void f() {
            System.out.println("i am child3");
        }
    }
}
```

运行这个程序后，child1会输出结果。say方法接受一个MyParent引用。那么在这种情况下，编译器怎样才能知道这个MyParent引用指向的是MyChild1对象，而不是MyChild2对象或MyChild3对象呢？实际上，编译器无法得知。这里涉及到绑定的概念。

### 绑定

将一个方法调用同一个方法主体关联起来称作**绑定**。

若在程序执行前进行绑定，叫做**前期绑定**。可能以前从来没有听说过这个术语，因为它是面向过程的语言中不需要选择就默认的绑定方式。例如，C只有一种方法调用，那就是前期绑定。

**动态绑定（后期绑定、运行时绑定）**：在运行时根据对象的类型进行绑定。（可以从虚拟机的角度来分析）

Java除了static和final（private默认为final）方法之外，其它方法都是动态绑定

## 总结

这里做一下对多态的理解：

对于一个方法传入不同的对象类型表现出不同的行为。Java实现的方式是动态绑定和向上转型。

动态绑定：在运行时根据对象的类型进行绑定。

向上转型：把对某个对象的引用视为对其父类的引用的做法称作向上转型。

# 接口和抽象类

## 应用场景

-   如果一些方法有默认实现，那么使用抽象类。
-   如果想实现多重继承，那么必须使用接口。
-   如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

## 接口的继承

```java
public class Main {
    public class MyClass implements MyInterface3 {
        @Override
        public void a() {

        }
        @Override
        public void b() {

        }
        @Override
        public void c() {

        }
    }

    public interface MyInterface1 {
        void a();
    }
    public interface MyInterface2 {
        void b();
    }

    public interface MyInterface3 extends MyInterface1, MyInterface2 {
        void c();
    }
}
```

类不能多继承，但是接口可以。

一个类实现一个接口同时也要实现它父接口中的方法。

## 接口出现相同名称

**接口出现相同名称的方法怎么办？**

**demo1**

以下的代码是不能编译通过的。

```java
public class Main {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        myClass.a();
        testInterface(myClass);//错误: 对testInterface的引用不明确
    }
    
    private static void testInterface(MyInterface1 i){
        i.a();
    }
    private static void testInterface(MyInterface2 i){
        i.a();
    }

    public static class MyClass implements MyInterface1, MyInterface2 {
        @Override
        public void a() {
            System.out.println("a");
        }

        @Override
        public void b() {}//编译错误

        @Override
        public int b() {//编译错误
            return 0;
        }
    }

    public interface MyInterface1 {
        void a();
        void b();
    }
    public interface MyInterface2 {
        void a();
        int b();
    }
}
```

**demo2**

如果两个方法返回类型、名称和参数完全一样，如：

```java
public class Main {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        myClass.a();
        testInterface1(myClass);
        testInterface2(myClass);
    }

    private static void testInterface1(MyInterface1 i){
        i.a();
    }
    private static void testInterface2(MyInterface2 i){
        i.a();
    }

    public static class MyClass implements MyInterface1, MyInterface2 {
        @Override
        public void a() {
            System.out.println("a");
        }
    }

    public interface MyInterface1 {
        void a();
    }
    public interface MyInterface2 {
        void a();
    }
}
```

结果是编译通过，并且输出为：

```
a
a
a
```

这就表明，如果接口的方法完全一样，那么结果没有问题。

**demo3**

返回类型相同，参数不同：

```java
public class Main {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        testInterface1(myClass);
        testInterface2(myClass);
    }

    private static void testInterface1(MyInterface1 i) {
        i.a();
    }
    private static void testInterface2(MyInterface2 i) {
        i.a(1);
    }

    public static class MyClass implements MyInterface1, MyInterface2 {

        @Override
        public void a() {
            System.out.println("a");
        }
        @Override
        public void a(int i) {
            System.out.println(i);
        }
    }

    public interface MyInterface1 {
        void a();
    }
    public interface MyInterface2 {
        void a(int i);
    }
}
```

输出结果为：

```
a
1
```

可以看出，由于参数不同，相当于方法重载，也不会有什么问题。

**demo4**

返回类型不同，参数相同：

和demo1一样，由于不能重载，所以这里不能通过编译。

请尽量避免这种情况，如果一定要解决，可以采用内部类的方式。

## 适配接口

接口彼此之间也可以嵌套。接口元素都必须是public的，因此，嵌套在另一个接口中的接口自动就是public的，而不能声明为private的。

```java
public interface MyInterface1{
    private interface MyInterface2{}//编译错误
    
    public interface MyInterface3{}
}
```

# 内部类

## 创建内部类

```java
public class Main {
    public class InnerClass{
    }
}
```

创建一个内部类的对象需要使用外部类的对象来创建：

```java
public static void main(String[] args) {
    Main main = new Main();
    InnerClass innerClass = main.new InnerClass();
}
```

## 链接到外部类

### 为什么内部类会隐式持有外部类的引用

```java
class InnerClassTest {
    private int id = 0;

    private void add() {
        id++;
    }

    private void use() {
        InnerClass innerClass = new InnerClass();
        innerClass.innerAdd();
    }

    private class InnerClass {

        public InnerClass() {
        }

        public InnerClass(int a) {
            id = a;
        }

        private void innerAdd() {
            add();//调用外部类的方法
            id++;//使用外部类的成员变量
        }
    }
}
```

InnerClassTest是外部类，里面有个内部类InnerClass，InnerClass有两个构造方法，注意这两个构造方法。

对InnerClassTest进行反编译，会生成2个class文件，一个是InnerClassTest.class，另一个是InnerClassTest$InnerClass.class。

主要看一下InnerClassTest$InnerClass.class

```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.mezzsy.learnsomething.java;

class InnerClassTest$InnerClass {
    public InnerClassTest$InnerClass(InnerClassTest var1) {
        this.this$0 = var1;
    }

    public InnerClassTest$InnerClass(InnerClassTest var1, int var2) {
        this.this$0 = var1;
        var1.id = var2;
    }

    private void innerAdd() {
        this.this$0.add();
        ++this.this$0.id;
    }
}
```

注意看构造方法，虽然在代码上一个是无参，一个是只有一个参数，但是实际上编辑器会插入一个参数，这个参数就是隐式的外部类的引用，当使用外部类的变量或者方法时，会使用这个隐式引用。

## 匿名内部类

匿名内部类没有构造方法，那么如果要初始化怎么办？可以利用初始化块。

```java
public class Main {

    public static void main(String[] args) {
        new InnerClass(){
            {
                System.out.println("在此初始化");
            }
        }.say();
    }

    public static abstract class InnerClass {
        public void say(){
            
        }
    }
}
```

## 嵌套类

如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。

嵌套类意味着：

1.  要创建嵌套类的对象，并不需要其外围类的对象。
2.  不能从嵌套类的对象中访问非静态的外围类对象。

接口里面也可以放嵌套类：

```java
public interface MainInterface {
    public static class InnerStaticClass{
        
    }
}
```

## 为什么需要内部类

内部类允许继承多个非接口类型(类或抽象类)。

这是《Java编程思想》的解释。

我个人的理解是：为了能够使用外部类的私有部分，如果没有外部类，那么要使用外部类的私有部分，要么复制代码，要么通过反射，这些都是十分复杂的方式。

## 内部类的继承

```java
public class MainParent {
    public class MainParentInnerClass{}
}

public class MainChild extends MainParent.MainParentInnerClass {
    public MainChild(MainParent parent) {
        parent.super();
    }
}
```

内部类隐式地持有外部类的引用，而子类隐式地持有父类的引用，所以，继承一个内部类的时候，要显式地传入外部类引用，并调用其super方法。

>   创建内部类的方式是这样的：`InnerClass innerClass = main.new InnerClass();`。
>
>   而super()可以理解为创建父类对象，所以需要这样调用：`parent.super();`

## 内部类可以被覆盖吗

```java
class Egg {
  private Yolk y;
    
  public Egg() {
    print("New Egg()");
    y = new Yolk();
  }
    
  protected class Yolk {
    public Yolk() { print("Egg.Yolk()"); }
  }
}  

public class BigEgg extends Egg {
  
  public static void main(String[] args) {
    new BigEgg();
  }
   
  public class Yolk {
    public Yolk() { print("BigEgg.Yolk()"); }
  }
}

Output:
New Egg()
Egg.Yolk()
```

这个例子说明，当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的。

## 什么时候使用局部内部类而不是匿名内部类？

- 需要一个已命名的构造器，或者需要重载构造器。
- 需要不止一个该内部类的对象。

# 枚举

## 基本使用

```java
enum MyEnum{
    ONE,TWO,THREE
}
```

为了使用enum，需要创建一个该类型的引用，并将其赋值给某个实例：

```java
public static void main(String[] args) {
    MyEnum one = MyEnum.ONE;
    MyEnum two = MyEnum.TWO;
    MyEnum three = MyEnum.THREE;
}
```

在创建enum时，编译器会自动添加一些有用的特性。例如，它会创建toString方法，以便显示某个enum实例的名字。编译器还会创建ordinal方法，用来表示某个特定enum常量的声明顺序，以及static values方法（values方法是在编译期间添加的一个静态方法），用来按照enum常量的声明顺序，产生由这些常量值构成的数组：

```java
public static void main(String[] args) {
    for (MyEnum value : MyEnum.values()) {
        System.out.println(value.ordinal() + ":" + value);
    }
}
```

output

```
0:ONE
1:TWO
2:THREE
```

enum可以和switch配合使用。

```java
enum Str {
    A("a"), B("b"), C("c"), D("d");

    String s;

    Str(String s) {
        this.s = s;
    }

    public String getS() {
        return s;
    }
}
```

可以在枚举类中添加一些构造器。方法和域。构造器只是在调用枚举常量的时候调用（即只能为**private**）。

## 添加方法

除了不能继承自一个enum之外，基本上可以将enum看作一个常规的类。

可以向enum中添加方法。甚至可以有main方法。

如果希望每个枚举实例能够返回对自身的描述，而不仅仅只是默认的toString实现（只能返回枚举实例的名字）。为此，可以提供一个构造器 ，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。

```java
public class Main {
    public static void main(String[] args) {
        for (MyEnum value : MyEnum.values()) {
            System.out.println(value.getContent());
        }
    }

    enum MyEnum {
        ONE("This is One"),
        TWO("This is Two"),
        THREE("This is Three");

        private String content;

        MyEnum(String content) {
            this.content = content;
        }

        public String getContent() {
            return content;
        }
    }
}
```

```
This is One
This is Two
This is Three
```

注意，如果打算定义方法，那么必须在enum实例序列的最后添加一个分号。同时，必须先定义enum实例。如果在定义enum实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。

在这个例子中，虽然有意识地将enum的构造器声明为private，但对于它的可访问性而言，其实并没有什么变化，因为只能在enum定义的内部使用其构造器创建enum实例。一旦enum的定义结束，编译器就不允许使用其构造器来创建任何实例了。

还可以为每个实例添加方法：

```java
enum MyEnum {
    ONE {
        public void sayOne() {
            System.out.println("one");
        }
    },
    TWO {
        public void sayTwo() {
            System.out.println("two");
        }
    },
    THREE {
        public void sayThree() {
            System.out.println("three");
        }
    };
}
```

不过这样方法无法被外界调用，如果要用，需要这样：

```java
enum MyEnum {
    ONE {
        public void say() {
            System.out.println("one");
        }
    },
    TWO {
        public void say() {
            System.out.println("two");
        }
    },
    THREE {
        public void say() {
            System.out.println("three");
        }
    };

    abstract void say();
}
```

## 继承

所有的enum都继承自java.lang.Enum类。由于Java不支持多重继承，所以enum不能再继承其他类，然而，在创建一个新的enum时，可以同时实现一个或多个接口。

如果希望扩展原enum中的元素，需要用到接口。在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。

```java
interface Number {
    enum SmallNumber implements Number {
        ONE, TWO;
    }

    enum BigNumber implements Number {
        NiNE, TEN;
    }
}
```

## 使用EnumSet替代标志

Set是一种集合，只能向其中添加不重复的对象。enum也要求其成员都是唯一的， 所以enum看起来也具有集合的行为。不过，由于不能从enum中删除或添加元素。Java SE5引入EnumSet，是为了通过enum创建一种替代品，以替代传统的基于int的“位标志”。这种标志可以用来表示某种“开/关” 信息，不过，使用这种标志，最终操作的只是一些bit，而不是这些bit想要表达的概念，因此很容易写出令人难以理解的代码。

EnumSet的设计充分考虑到了速度因素，因为它必须与非常高效的bit标志相竞争(其操作与HashSet相比，非常地快)。就其内部而言，它(可能)就是将一个long值作为比特向量，所以EnumSet非常快速高效。使用EnumSet的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。

EnumSet中的元素必须来自一个enum。

```java
public class Main {
    public static void main(String[] args) {
        //创建空的set
        EnumSet<MyEnum> enumSet = EnumSet.noneOf(MyEnum.class);

        enumSet.add(MyEnum.ONE);
        System.out.println(enumSet);

        enumSet.addAll(EnumSet.allOf(MyEnum.class));
        System.out.println(enumSet);

        enumSet.remove(MyEnum.TWO);
        System.out.println(enumSet);
    }

    enum MyEnum {
        ONE, TWO, THREE
    }
}
```

```
[ONE]
[ONE, TWO, THREE]
[ONE, THREE]
```

## EnumMap

EnumMap是一种特殊的Map，它要求其中的键(key)必须来自一个enum。由于enum本身的限制，所以EnumMap在内部可由数组实现。因此EnumMap的速度很快，可以放心地使用enum实例在EnumMap中进行查找操作。不过，只能将enum的实例作为键来调用put方法，其他操作与使用一般的Map差不多。