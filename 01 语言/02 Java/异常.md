# 通过异常处理错误

[Java异常机制](Java异常机制.md)

## 基本异常

异常情形是指阻止当前方法或作用域继续执行的问题。

当抛出异常后，有几件事会随之发生：
首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象。
然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。
异常处理机制接管程序，并开始寻找一个恰当的地方（异常处理程序）来继续执行。

## 捕获异常

### try块

如果在方法内部抛出了异常，这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种(可能产生异常的)方法调用，所以称为try块。

### 异常处理程序

抛出的异常必须在某处得到处理。这个“地点”就是**异常处理程序**，而且针对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在try块之后，以关键字catch表示。

## 捕获所有异常

### 重新抛出异常

有时希望把刚捕获的异常重新抛出，尤其是在使用Exception捕获所有异常的时候。既然已经得到了对当前异常对象的引用，可以直接把它重新抛出:

```java
catch(Exception e) {
    System.out.println("An exception was thrown");
	throw e;
}
```

重抛异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略。

## 异常丢失

```java
package com.mezzsy.learnsomething;


public class Main {

    public static void main(String[] args) {
        try {
            Main main = new Main();
            try {
                main.f1();
            } finally {
                main.f2();
            }
        } catch (Exception e) {
            System.out.println(e);
        }
    }

    private void f1() throws Exception1 {
        throw new Exception1();
    }

    private void f2() throws Exception2 {
        throw new Exception2();
    }

    private static class Exception1 extends Exception {
        @Override
        public String toString() {
            return "Exception 1";
        }
    }

    private static class Exception2 extends Exception {
        @Override
        public String toString() {
            return "Exception 2";
        }
    }
}
```

输出：

```
Exception 2
```

从输出中可以看到，Exception1不见了，它被finally子句里的Exception2所取代。这是相当严重的缺陷，因为异常丢失了。

>   这段内容来自《Java编程思想》，个人认为，这里造成异常丢失的原因是编码不规范导致的，没有必要在try块套一层/try，可以换成在finally中使用try块。
>
>   TODO 为什么会丢失？

## 异常的限制

```java
private static class ExceptionParent extends Exception {
    public ExceptionParent() throws IOException {
        throw new IOException();
    }
}

private static class ExceptionChild extends ExceptionParent {
    public ExceptionChild() throws IOException {
        super();//super()不能放在try-catch块
    }
}
```

异常限制对构造器不起作用。派生类构造器的异常说明必须包含基类构造器的异常说明。
派生类构造器不能捕获（catch）基类构造器抛出的异常。

## 异常匹配

抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。

查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。

