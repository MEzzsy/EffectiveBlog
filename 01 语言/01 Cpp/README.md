第16章
模板与泛型编程
内容
16。1定义模板。
16。2模板实参推断
16。3重载与模板。
16。4可变参数模板
16。5模板特例化。
小结
术语表
578
600
614
618
624
630
630
面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之
处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能
获知类型了。
本书第II部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛
型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型
或值，程序实例可在其上运行。
例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这
个泛型定义来定义很多类型的vector，它们的差异就在于包含的元素类型不同。
模板是泛型编程的基础。我们不必了解模板是如何定义的就能使用它们，实际上我们
已经这样用了。在本章中，我们将学习如何定义自己的模板。
651

Page604
578
652
模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。
当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信
息，将蓝图转换为特定的类或函数。这种转换发生在编译时。在本书第3章和第II部分中
我们已经学习了如何使用模板。在本章中，我们将学习如何定义模板。
16。1定义模板
假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第
二个值。在实际中，我们可能想要定义多个函数，每个函数比较一种给定类型的值。我们
的初次尝试可能定义多个重载函数：
//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1
intcompare（conststring&v1，conststring&v2）
{
if（v1<v2）
if（v2<vl）
return0；
return-1；
return1；
第16章模板与泛型编程
}
intcompare（constdouble&vl，constdouble&v2）
{
if（v1<v2）return-1；
if（v2<v1）return1；
return0；
}
这两个函数几乎是相同的，唯一的差异是参数的类型，函数体则完全一样。
如果对每种希望比较的类型都不得不重复定义完全一样的函数体，是非常烦琐且容易
出错的。更麻烦的是，在编写程序的时候，我们就要确定可能要compare的所有类型。
如果希望能在用户提供的类型上使用此函数，这种策略就失效了。
Note
16。1。1函数模板
我们可以定义一个通用的函数模板（functiontemplate），而不是为每个类型都定义一
个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare
的模板版本可能像下面这样：
template<typenameT>
intcompare（constT&vl，constT&v2）
{
if（v1<v2）return-1；
if（v2<vl）return1；
return0；
653模板定义以关键字template开始，后跟一个模板参数列表（templateparameterlist），这
是一个逗号分隔的一个或多个模板参数（templateparameter）的列表，用小于号（<）和大
于号（>）包围起来。
在模板定义中，模板参数列表不能为空。

Page605
16。1定义模板
模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变
量，但并未指出如何初始化它们。在运行时，调用者提供实参来初始化形参。
类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐
式地或显式地）指定模板实参（templateargument），将其绑定到模板参数上。
我们的compare函数声明了一个名为T的类型参数。在compare中，我们用名字T
表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。
实例化函数模板
当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，
当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型｡例如，
在下面的调用中：
cout<<compare（1，0）<<endl；//T为int
实参类型是int。编译器会推断出模板实参为int，并将它绑定到模板参数T。
编译器用推断出的模板参数来为我们实例化（instantiate）一个特定版本的函数。当编
译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个
新“实例”。例如，给定下面的调用：
//实例化出intcompare（constint&，constint&）
cout<<compare（1，0）<<endl；//T为int
//实例化出intcompare（constvector<int>&，constvector<int>&）
vector<int>vecl{1，2，3}，vec2{4，5，6}；
cout<<compare（vecl，vec2）<<endl；//T为vector<int>
编译器会实例化出两个不同版本的compare。对于第一个调用，编译器会编写并编译一
个compare版本，其中T被替换为int：
intcompare（constint&vl，constint&v2）
{
}
对于第二个调用，编译器会生成另一个compare版本，其中T被替换为vector<int>。
这些编译器生成的版本通常被称为模板的实例（instantiation）。
if（v1<v2）return-1；
if（v2<v1）return1；
return0；
模板类型参数
我们的compare函数有一个模板类型参数（typeparameter）。一般来说，我们可以将
类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可
以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：
//正确：返回类型和参数类型相同
template<typenameT>Tfoo（T*p）
{
}
*p；//tmp的类型将是指针p指向的类型
Ttmp
//。。。
returntmp；
579
654

Page606
580
655
第16章模板与泛型编程
类型参数前必须使用关键字class或typename；
//错误：U之前必须加上class或typename
template<typenameT，U>Tcalc（constT&，constU&）；
在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以
同时使用这两个关键字：
//正确：在模板参数列表中，typename和class没有什么不同
template<typenameT，classU>calc（constT&，constU&）；
看起来用关键字typename来指定模板类型参数比用class更为直观。毕竟，我们
可以用內置（非类）类型作为模板类型实参。而且，typename更清楚地指出随后的名字
是一个类型名。但是，typename是在模板已经广泛使用之后才引入C++语言的，某些程
序员仍然只用class。
非类型模板参数
除了定义类型参数，还可以在模板中定义非类型参数（nontypeparameter）。一个非类
型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或
typename来指定非类型参数。
当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。
这些值必须是常量表达式（参见2。4。4节，第58页），从而允许编译器在编译时实例化
模板。
例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const
char的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用（参见
6。2。4节，第195页）。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义
了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数
组的长度：
template<unsignedN，unsignedM>
intcompare（constchar（&p1）[N]，constchar（&p2）[M]）
{
returnstrcmp（p1，p2）；
}
当我们调用这个版本的compare时：
compare（"hi"，"mom"）
编译器会使用字面常量的大小来代替N和M，从而实例化模板。记住，编译器会在一个字
符串字面常量的末尾插入一个空字符作为终结符（参见2。1。3节，第36页），因此编译器
会实例化出如下版本：
intcompare（constchar（&p1）[3]，constchar（&p2）[4]）
一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）
引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参
数的实参必须具有静态的生存期（参见第12章，第400页）。我们不能用一个普通（非
static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以
用nullptr或一个值为0的常量表达式来实例化。
在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用

Page607
16。1定义模板
非类型参数，例如，指定数组大小。
Note
非类型模板参数的模板实参必须是常量表达式。
inline和constexpr的函数模板
函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或
constexpr说明符放在模板参数列表之后，返回类型之前：
//正确：inline说明符跟在模板参数列表之后
template<typenameT>inlineTmin（constT&，constT&）；
//错误：inline说明符的位置不正确
inlinetemplate<typenameT>Tmin（constT&，constT&）；
编写类型无关的代码
我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则：
•模板中的函数参数是const的引用。
•函数体中的条件判断仅使用<比较运算。
通过将函数参数设定为const的引用，我们保证了函数可以用于不能拷贝的类型。大多
数类型，包括内置类型和我们已经用过的标准库类型（除unique_ptr和IO类型之外），
都是允许拷贝的。但是，不允许拷贝的类类型也是存在的。通过将参数设定为const的
引用，保证了这些类型可以用我们的compare函数来处理。而且，如果compare用于
处理大对象，这种设计策略还能使函数运行得更快。
你可能认为既使用<运算符又使用>运算符来进行比较操作会更为自然：
//期望的比较操作
if（v1<v2）return-1；
if（v1>v2）return1；
return0；
但是，如果编写代码时只使用<运算符，我们就降低了compare函数对要处理的类型的
要求。这些类型必须支持<，但不必同时支持>。
实际上，如果我们真的关心类型无关和可移植性，可能需要用less（参见14。8。2节，
第510页）来定义我们的函数：
//即使用于指针也正确的compare版本；参见14。8。2节（第510页）
template<typenameT>intcompare（constT&vl，constT&v2）
{
if（less<T>（）（v1，v2））return-1；
if（less<T>（）（v2，v1））return1；
return0；
}
原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，
则代码的行为是未定义的（据查阅资料，less<T>的默认实现用的就是<，所以这其实并
未起到让这种比较有一个良好定义的作用——译者注）。
Best
Practices模板程序应该尽量减少对实参类型的要求。
581
656

Page608
582
657
第16章模板与泛型编程
模板编译
当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特
定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，
这一特性影响了我们如何组织代码以及错误何时被检测到。
通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用
一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我
们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。
模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数
的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。
Note
函数模板和类模板成员函数的定义通常放在头文件中。
关键概念：模板和头文件
模板包含两种名字：
•那些不依赖于模板参数的名字
•那些依赖于模板参数的名字
当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来
保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板
的成员的定义，也必须是可见的。
用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见
的，这是由模板的用户来保证的。
通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计
者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声
明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。
大多数编译错误在实例化期间报告
模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编
译错误。通常，编译器会在三个阶段报告错误。
第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器
可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。
第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对
于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。
对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。
第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器
如何管理实例化，这类错误可能在链接时才报告。
当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型
有一些假设。例如，我们最初的compare函数中的代码就假定实参类型定义了<运算符。
if（v1<v2）return-1；//要求类型T的对象支持<操作
if（v2<vl）return1；
//要求类型T的对象支持<操作

Page609
16。1定义模板
return0；
//返回int；不依赖于T
当编译器处理此模板时，它不能验证if语句中的条件是否合法。如果传递给compare658
的实参定义了<运算符，则代码就是正确的，否则就是错误的。例如，
Sales_datadatal，data2；
cout<<compare（datal，data2）<<endl；//错误：Salesdata未定义<
此调用实例化了compare的一个版本，将T替换为Sales_data。if条件试图对
Sales_data对象使用<运算符，但Sales_data并未定义此运算符。此实例化生成了
一个无法编译通过的函数版本。但是，这样的错误直至编译器在类型Salesdata上实
例化compare时才会被发现。
WARNING
保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确
工作，是调用者的责任。
16。1。1节练习
练习16。1：给出实例化的定义。
练习16。2：编写并测试你自己版本的compare函数。
练习16。3：对两个Sales_data对象调用你的compare函数，观察编译器在实例化
过程中如何处理错误。
练习16。4：编写行为类似标准库find算法的模板。函数需要两个模板类型参数，一个
表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个vector<int>和
一个list<string>中查找给定值。
练习16。5：为6。2。4节（第195页）中的print函数编写模板版本，它接受一个数组的
引用，能处理任意大小、任意元素类型的数组。
练习16。6：你认为接受一个数组实参的标准库函数begin和end是如何工作的?定义
你自己版本的begin和end。
练习16。7：编写一个constexpr模板，返回给定数组的大小。
练习16。8：在第97页的“关键概念”中，我们注意到，C++程序员喜欢使用!=而不喜
欢<。解释这个习惯的原因。
583
16。1。2类模板
类模板（classtemplate）是用来生成类的蓝图的。与函数模板的不同之处是，编译器
不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在
模板名后的尖括号中提供额外信息（参见3。3节，第87页）——用来代替模板参数的模板659
实参列表。
定义类模板
作为一个例子，我们将实现StrBlob（参见12。1。1节，第405页）的模板版本。我
们将此模板命名为Blob，意指它不再针对string。类似StrBlob，我们的模板会提供
对元素的共享（且核查过的）访问能力。与类不同，我们的模板可以用于更多类型的元素。
与标准库容器相同，当使用Blob时，用户需要指出元素类型。

Page610
584
类似函数模板，类模板以关键字template开始，后跟模板参数列表。在类模板（及
其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值：
template<typenameT>classBlob{
public：
typedefTvalue_type；
typedeftypenamestd：：vector<T>：：size_typesize_type；
//构造函数
Blob（）；
Blob（std：：initializerlist<T>il）；
//Blob中的元素数目
第16章模板与泛型编程
size_typesize（）const{returndata->size（）；}
boolempty（）const{returndata->empty（）；}
//添加和删除元素
voidpush_back（constT&t）{data->push_back（t）；}
//移动版本，参见13。6。3节（第484页）
voidpush_back（T&&t）{data->push_back（std：：move（t））；}
voidpop_back（）；
//元素访问
T&back（）；
T&operator[]（size_typei）；//在14。5节（第501页）中定义
private：
std：：shared_ptr<std：：vector<T>>data；
//若data[i]无效，则抛出msg
voidcheck（size_typei，conststd：：string&msg）const；
}；
我们的Blob模板有一个名为T的模板类型参数，用来表示Blob保存的元素的类型。例
如，我们将元素访问操作的返回类型定义为T&。当用户实例化Blob时，T就会被替换为
特定的模板实参类型。
除了模板参数列表和使用T代替string之外，此类模板的定义与12。1。1节（第405
页）中定义的类版本及12。1。6节（第422页）和第13章､第14章中更新的版本是一样的。
660实例化类模板
我们已经多次见到，当使用一个类模板时，我们必须提供额外信息。我们现在知道这
些额外信息是显式模板实参（explicittemplateargument）列表，它们被绑定到模板参数。
编译器使用这些模板实参来实例化出特定的类。
例如，为了用我们的Blob模板定义一个类型，必须提供元素类型：
Blob<int>ia；
//空Blob<int>
Blob<int>ia2={0，1，2，3，4}；//有5个元素的Blob<int>
ia和ia2使用相同的特定类型版本的Blob（即Blob<int>）。从这两个定义，编译器
会实例化出一个与下面定义等价的类：
template<>classBlob<int>{
typedeftypenamestd：：vector<int>：：size_typesize_type；
Blob（）；
Blob（std：：initializerlist<int>il）；
//。。。
int&operator[]（size_typei）；

Page611
16。1定义模板
private：
std：：shared_ptr<std：：vector<int>>data；
voidcheck（size_typei，conststd：：string&msg）const；
}；
当编译器从我们的Blob模板实例化出一个类时，它会重写Blob模板，将模板参数T的
每个实例替换为给定的模板实参，在本例中是int。
对我们指定的每一种元素类型，编译器都生成一个不同的类：
//下面的定义实例化出两个不同的Blob类型
Blob<string>names；//保存string的Blob
Blob<double>prices；//不同的元素类型
这两个定义会实例化出两个不同的类。names的定义创建了一个Blob类，每个T都被替
换为string。prices的定义生成了另一个Blob类，T被替换为double。
Note
一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其
他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。
在模板作用域中引用模板类型
为了阅读模板类代码，应该记住类模板的名字不是一个类型名（参见3。3节，第87
页）。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。
可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实
际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用
模板的实参。例如，我们的data成员使用了两个模板，vector和shared_ptr。我们661
知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是Blob
的模板参数。因此，data的定义如下：
std：：shared_ptr<std：：vector<T>>data；
它使用了Blob的类型参数来声明data是一个shared_ptr的实例，此shared_ptr
指向一个保存类型为T的对象的vector实例。当我们实例化一个特定类型的Blob，例
如Blob<string>时，data会成为：
shared_ptr<vector<string>>
如果我们实例化Blob<int>，则data会成为shared_ptr<vector<int>>，依此类推。
类模板的成员函数
与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函
数，且定义在类模板内的成员函数被隐式声明为内联函数。
类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的
成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之
外的成员函数就必须以关键字template开始，后接类模板参数列表。
585
与往常一样，当我们在类外定义一个成员时，必须说明成员属于哪个类。而且，从一
个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与
模板形参相同。即，对于StrBlob的一个给定的成员函数
ret-typeStrBlob：：member-name（parm-list）

Page612
586
662
对应的Blob的成员应该是这样的：
template<typenameT>
ret-typeBlob<T>：：member-name（parm-list）
check和元素访问成员
我们首先定义check成员，它检查一个给定的索引：
template<typenameT>
voidBlob<T>：：check（size_typei，conststd：：string&msg）const
{
}
if（i>=data->size（））
}
除了类名中的不同之处以及使用了模板参数列表外，此函数与原StrBlob类的check成
员完全一样。
下标运算符和back函数用模板参数指出返回类型，其他未变：
template<typenameT>
T&Blob<T>：：back（）
{
throwstd：：out_of_range（msg）；
}
template<typenameT>
T&Blob<T>：：operator[]（size_typei）
{
{
check（0，"backonemptyBlob"）；
returndata->back（）；
第16章模板与泛型编程
//如果i太大，check会抛出异常，阻止访问一个不存在的元素
check（i，"subscriptoutofrange"）；
return（*data）[i]；
在原StrBlob类中，这些运算符返回string&。而模板版本则返回一个引用，指向用来
实例化Blob的类型。
pop_back函数与原StrBlob的成员几乎相同：
template<typenameT>voidBlob<T>：：pop_back（）
check（0，"pop_backonemptyBlob"）；
data->pop_back（）；
}
在原StrBlob类中，下标运算符和back成员都对const对象进行了重载。我们将这些
成员及front成员的定义留作练习。
Blob构造函数
与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：
template<typenameT>
Blob<T>：：Blob（）：data（std：：make_shared<std：：vector<T>>（））{}
这段代码在作用域Blob<T>中定义了名为Blob的成员函数。类似StrBlob的默认构造

Page613
16。1定义模板
函数（参见12。1。1节，第405页），此构造函数分配一个空vector，并将指向vector
的指针保存在data中。如前所述，我们将类模板自己的类型参数作为vector的模板实
参来分配vector。
类似的，接受一个initializerlist参数的构造函数将其类型参数T作为
initializerlist参数的元素类型：
template<typenameT>
Blob<T>：：Blob（std：：initializerlist<T>il）：
data（std：：make_shared<std：：vector<T>>（il））{}
类似默认构造函数，此构造函数分配一个新的vector。在本例中，我们用参数i1来初
始化此vector。
为了使用这个构造函数，我们必须传递给它一个initializerlist，其中的元素
必须与Blob的元素类型兼容：
Blob<string>articles={"a"，"an"，"the"}；
这条语句中，构造函数的参数类型为initializer_list<string>。列表中的每个字
符串字面常量隐式地转换为一个string。
类模板成员函数的实例化
默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。例如，下面代码
//实例化Blob<int>和接受initializer_list<int>的构造函数
Blob<int>squares=（0，1，2，3，4，5，6，7，8，9}；
//实例化Blob<int>：：size（）const
for（size_ti=0；i!=squares。size（）；++i）
squares[i]=i*i；//实例化Blob<int>：：operator[]（size_t）
实例化了Blob<int>类和它的三个成员函数：operator[]、size和接受
initializer_list<int>的构造函数。
如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行
实例化，这一特性使得即使某种类型不能完全符合模板操作的要求（参见9。2节，第294
页），我们仍然能用该类型实例化类。
Note
默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。
在类代码内简化模板类名的使用
当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板
自己的作用域中，我们可以直接使用模板名而不提供实参：
//若试图访问一个不存在的元素，BlobPtr抛出一个异常
template<typenameT>classBlobPtr{
public：
BlobPtr（）：curr（0）{}
BlobPtr（Blob<T>&a，size_tsz=0）：
wptr（a。data），curr（sz）{}
T&operator*（）const
{autop=check（curr，"dereferencepastend"）；
return（*p）[curr]；//（*p）为本对象指向的vector
587
663

Page614
588
664
}
//递增和递减
Blobetr&operator++（）；//前置运算符
BlobPtr&operator--（）；
private：
//若检查成功，check返回一个指向vector的shared_ptr
std：：shared_ptr<std：：vector<T>>
check（std：：size_t，conststd：：string&）const；
//保存一个weak_ptr，表示底层vector可能被销毁
std：：weak_ptr<std：：vector<T>>wptr；
std：：size_tcurr；//数组中的当前位置
}；
细心的读者可能已经注意到，BlobPtr的前置递增和递减成员返回BlobPtr&，而不是
BlobPtr<T>&。当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好
像我们已经提供了与模板参数匹配的实参一样。即，就好像我们这样编写代码一样：
BlobPtr<T>&operator++（）；
BlobPtr<T>&operator--（）；
{
在类模板外使用类模板名
当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类
名才表示进入类的作用域（参见7。4节，第253页）：
//后置：递增/递减对象但返回原值
template<typenameT>
BlobPtr<T>BlobPtr<T>：：operator++（int）
Note
第16章模板与泛型编程
//此处无须检查；调用前置递增时会进行检查
BlobPtrret=*this；//保存当前值
++*this；
//推进一个元素；前置++检查递增是否合法
returnret；//返回保存的状态
}
由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的BlobPtr，
它所用类型与类实例化所用类型一致。在函数体内，我们已经进入类的作用域，因此在定
义ret时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与
成员实例化所用类型一致。因此，ret的定义与如下代码等价：
BlobPtr<T>ret=*this；
在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。
类模板和友元
当一个类包含一个友元声明（参见7。2。1节，第241页）时，类与友元各自是否是模
板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板
实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。
一对一友好关系
类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友
元间的友好关系。例如，我们的Blob类应该将BlobPtr类和一个模板版本的Blob相

Page615
16。1定义模板
等运算符（最初是在14。3。1节（第498页）练习中为StrBlob定义的）定义为友元。
为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板
声明包括模板参数列表：
//前置声明，在Blob中声明友元所需要的
template<typename>classBlobPtr；
template<typename>classBlob；//运算符==中的参数所需要的
template<typenameT>
booloperator==（constBlob<T>&，constBlob<T>&）；
template<typenameT>classBlob{
//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符
friendclassBlobPtr<T>；
friendbooloperator==<T>
（constBlob<T>&，constBlob<T>&）；
//其他成员定义，与12。1。1（第405页）相同
}；
我们首先将Blob、BlobPtr和operator==声明为模板。这些声明是operator==函
数的参数声明以及Blob中的友元声明所需要的。
友元的声明用Blob的模板形参作为它们自己的模板实参。因此，友好关系被限定在
用相同类型实例化的Blob与BlobPtr相等运算符之间：
Blob<char>ca；//BlobPtr<char>和operator==<char>都是本对象的友元
//BlobPtr<int>和operator==<int>都是本对象的友元
Blob<int>ia；
BlobPtr<char>的成员可以访问ca（或任何其他Blob<char>对象）的非public部
分，但ca对ia（或任何其他Blob<int>对象）或Blob的任何其他实例都没有特殊访
问权限。
通用和特定的模板友好关系
一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为
友元：
}；
//前置声明，在将模板的一个特定实例声明为友元时要用到
template<typenameT>classPal；
classC{//C是一个普通的非模板类
friendclassPal<C>；//用类C实例化的Pal是C的一个友元
//Pal2的所有实例都是C的友元；这种情况无须前置声明
template<typenameT>friendclassPal2；
template<typenameT>classC2{//C2本身是一个类模板
//C2的每个实例将相同实例化的Pal声明为友元
friendclassPal<T>；//Pal的模板声明必须在作用域之內
//Pal2的所有实例都是C2的每个实例的友元，不需要前置声明
template<typenameX>friendclassPal2；
//Pal3是一个非模板类，它是C2所有实例的友元
friendclassPal3；//不需要Pal3的前置声明
}；
为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。
589
665

Page616
590
666
C++
11
C++
11
667
令模板自己的类型参数成为友元
在新标准中，我们可以将模板类型参数声明为友元；
template<typenameType>classBar{
friendType；//将访问权限授予用来实例化Bar的类型
//。。。
第16章模板与泛型编程
}；
此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo，Foo将成
为Bar<Foo>的友元，Salesdata将成为Bar<Sales_data>的友元，依此类推。
值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一
个内置类型来实例化Bar。这种与内置类型的友好关系是允许的，以便我们能用内置类型
来实例化Bar这样的类。
模板类型别名
类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个
typedef（参见2。5。1节，第60页）来引用实例化的类：
typedefBlob<string>StrBlob；
这条typedef语句允许我们运行在12。1。1节（第405页）中编写的代码，而使用的却是
用string实例化的模板版本的Blob。由于模板不是一个类型，我们不能定义一个
typedef引用一个模板。即，无法定义一个typedef引用Blob<T>。
但是，新标准允许我们为类模板定义一个类型别名：
template<typenameT>usingtwin=pair<T，T>；
twin<string>authors；//authors是一个pair<string，string>
在这段代码中，我们将twin定义为成员类型相同的pair的别名。这样，twin的用户
只需指定一次类型。
一个模板类型别名是一族类的别名：
twin<int>winloss；//win_loss是一个pair<int，int>
twin<double>area；//area-pair<double，double>
就像使用类模板一样，当我们使用twin时，需要指出希望使用哪种特定类型的twin。
当我们定义一个模板类型别名时，可以固定一个或多个模板参数：
template<typenameT>usingpartNo
pair<T，unsigned>；
partNo<string>books；//books是一个pair<string，unsigned>
partNo<Vehicle>cars；//cars是一个pair<Vehicle，unsigned>
partNo<Student>kids；//kids是一个pair<Student，unsigned>
=
这段代码中我们将partNo定义为一族类型的别名，这族类型是second成员为
unsigned的pair。partNo的用户需要指出pair的first成员的类型，但不能指定
second成员的类型。
类模板static成员
与任何其他类相同，类模板可以声明static成员（参见7。6节，第269页）：
template<typenameT>classFoo{
public：

Page617


Page618
592
voidinsert（ListItem*ptr，elemTypevalue）；
private：
}；
}
练习16。12：编写你自己版本的Blob和BlobPtr模板，包含书中未定义的多个const
成员。
练习16。13：解释你为BlobPtr的相等和关系运算符选择哪种类型的友好关系?
练习16。14：编写Screen类模板，用非类型参数定义Screen的高和宽。
练习16。15：为你的Screen模板实现输入和输出运算符。Screen类需要哪些友元（如
果需要的话）来令输入和输出运算符正确工作?解释每个友元声明（如果有的话）为什
么是必要的。
练习16。16：将StrVec类（参见13。5节，第465页）重写为模板，命名为Vec。
ListItem*front，*end；
16。1。3模板参数
类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参
数命名为T，但实际上我们可以使用任何名字：
template<typenameFoo>Foocalc（constFoo&a，constFoo&b）
Footmp=a；//tmp的类型与参数和返回类型一样
//。。。
returntmp；//返回类型和参数类型一样
{
第16章模板与泛型编程
模板参数与作用域
模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模
669板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同
名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：
typedefdoubleA；
template<typenameA，typenameB>voidf（Aa，Bb）
Atmp=a；
doubleB；//错误：重声明模板参数B
//tmp的类型为模板参数A的类型，而非double
模板声明
}
正常的名字隐藏规则决定了A的typedef被类型参数A隐藏。因此，tmp不是一个
double，其类型是使用f时绑定到类型参数A的类型。由于我们不能重用模板参数名，
声明名字为B的变量是错误的。
由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：
//错误：非法重用模板参数名V
template<typenameV，typenameV>//。。。
模板声明必须包含模板参数：

Page619
16。1定义模板
//声明但不定义compare和Blob
template<typenameT>intcompare（constT&，constT&）；
template<typenameT>classBlob；
与函数参数相同，声明中的模板参数的名字不必与定义中相同：
//3个calc都指向相同的函数模板
template<typenameT>Tcalc（constT&，constT&）；//声明
template<typenameU>Ucalc（constU&，constU&）；//声明
//模板的定义
template<typenameType>
Typecalc（constType&a，constType&b）{/*
*/}
当然，一个给定模板的每个声明和定义必须有相同数量和种类（即，类型或非类型）的参数。
Best
Practices
一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于
任何使用这些模板的代码之前，原因我们将在16。3节（第617页）中解释。
使用类的类型成员
回忆一下，我们用作用域运算符（：）来访问static成员和类型成员（参见7。4节，
第253页和7。6节，第269页）。在普通（非模板）代码中，编译器掌握类的定义。因此，
它知道通过作用域运算符访问的名字是类型还是static成员。例如，如果我们写下
string：：size_type，编译器有string的定义，从而知道size_type是一个类型。670
但对于模板代码就存在困难。例如，假定T是一个模板类型参数，当编译器遇到类似
T：：mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直
至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。例
如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时：
T：：size_type*P；
它需要知道我们是正在定义一个名为p的变量还是将一个名为size_type的static数
据成员与名为p的变量相乘。
默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们
希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们
通过使用关键字typename来实现这一点：
template<typenameT>
typenameT：：value_typetop（constT&c）
{
Note
if（!c。empty（））
else
returnc。back（）；
returntypenameT：：value_type（）；
我们的top函数期待一个容器类型的实参，它使用typename指明其返回类型并在c中
没有元素时生成一个值初始化的元素（参见7。5。3节，第262页）返回给调用者。
593
当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而
不能使用class。

Page620
594
C++
11
默认模板实参
就像我们能为函数参数提供默认实参一样（参见6。5。1节，第211页），我们也可以提
供默认模板实参（defaulttemplateargument）。在新标准中，我们可以为函数和类模板提供
默认实参。而更早的C++标准只允许为类模板提供默认实参。
例如，我们重写compare，默认使用标准库的less函数对象模板（参见14。8。2节，
第509页）：
第16章模板与泛型编程
//compare有一个默认模板实参less<T>和一个默认函数实参F（）
template<typenameT，typenameF=less<T>>
intcompare（constT&vl，constT&v2，Ff=F（））
{
if（f（vl，v2））return-1；
if（f（v2，v1））return1；
return0；
671在这段代码中，我们为模板添加了第二个类型参数，名为F，表示可调用对象（参见10。3。2
节，第346页）的类型；并定义了一个新的函数参数f，绑定到一个可调用对象上。
我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默认实参。默认
模板实参指出compare将使用标准库的less函数对象类，它是使用与compare一样
的类型参数实例化的。默认函数实参指出f将是类型F的一个默认初始化的对象。
当用户调用这个版本的compare时，可以提供自己的比较操作，但这并不是必需的：
booli=compare（0，42）；//使用less；i为-1
//结果依赖于iteml和item2中的isbn
Sales_dataiteml（cin），item2（cin）；
boolj=compare（iteml，item2，compareIsbn）；
第一个调用使用默认函数实参，即，类型less<T>的一个默认初始化对象。在此调用中，
T为int，因此可调用对象的类型为less<int>。compare的这个实例化版本将使用
less<int>进行比较操作。
在第二个调用中，我们传递给compare三个实参：compareIsbn（参见11。2。2节，
第379页）和两个Sales_data类型的对象。当传递给compare三个实参时，第三个实
参的类型必须是一个可调用对象，该可调用对象的返回类型必须能转换为bool值，且接
受的实参类型必须与compare的前两个实参的类型兼容。与往常一样，模板参数的类型
从它们对应的函数实参推断而来。在此调用中，T的类型被推断为Sales_data，F被推
断为compareIsbn的类型。
与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，
它才可以有默认实参。
模板默认实参与类模板
无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须
从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，
且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：
template<classT=int>classNumbers{//T默认为int
public：
Numbers（Tv=0）：val（v）{}

Page621
16。1定义模板
//对数值的各种操作
private：
Tval；
Numbers<longdouble>lots_of_precision；
Numbers<>average_precision；//空<>表示我们希望使用默认类型
此例中我们实例化了两个Numbers版本：average_precision是用int代替T实例
化得到的：lots_of_precision是用longdouble代替T实例化而得到的。
16。1。3节练习
练习16。17：声明为typename的类型参数和声明为class的类型参数有什么不同（如
果有的话）?什么时候必须使用typename?
练习16。18：解释下面每个函数模板声明并指出它们是否非法。更正你发现的每个错误。
（a）template<typenameT，U，typenameV>voidf1（T，U，V）；
（b）template<typenameT>Tf2（int&T）；
（c）inlinetemplate<typenameT>Tfoo（T，unsignedint*）；
（d）template<typenameT>f4（T，T）；
（e）typedefcharCtype；
template<typenameCtype>Ctypef5（Ctypea）；
练习16。19：编写函数，接受一个容器的引用，打印容器中的元素。使用容器的size_type
和size成员来控制打印元素的循环。
练习16。20：重写上一题的函数，使用begin和end返回的迭代器来控制循环。
16。1。4成员模板
一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称
为成员模板（membertemplate）。成员模板不能是虚函数。
普通（非模板）类的成员模板
作为普通类包含成员模板的例子，我们定义一个类，类似unique_ptr所使用的默
认删除器类型（参见12。1。5节，第418页）。类似默认删除器，我们的类将包含一个重载
的函数调用运算符（参见14。8节，第506页），它接受一个指针并对此指针执行delete。
与默认删除器不同，我们的类还将在删除器被执行时打印一条信息。由于希望删除器适用
于任何类型，所以我们将调用运算符定义为一个模板：
//函数对象类，对给定指针执行delete
classDebugDelete{
public：
}；
DebugDelete（std：：ostream&s=std：：cerr）：os（s）{}
//与任何函数模板相同，T的类型由编译器推断
template<typenameT>voidoperator（）（T*p）const
{os<<"deletingunique_ptr"<<std：：endl；deletep；}
private：
std：：ostream&os；
595
672

Page622
596
673
与任何其他模板相同，成员模板也是以模板参数列表开始的。每个DebugDelete对象都
有一个ostream成员，用于写入数据；还包含一个自身是模板的成员函数。我们可以用
这个类代替delete：
double*p=newdouble；
DebugDeleted；//可像delete表达式一样使用的对象
d（p）；//调用DebugDelete：：operator（）（double*），释放p
int*ip
newint；
//在一个临时DebugDelete对象上调用operator（）（int*）
DebugDelete（）（ip）；
由于调用一个DebugDelete对象会delete其给定的指针，我们也可以将
DebugDelete用作unique_ptr的删除器。为了重载unique_ptr的删除器，我们在
尖括号内给出删除器类型，并提供一个这种类型的对象给unique_ptr的构造函数（参
见12。1。5节，第418页）：
//销毁p指向的对象
//实例化DebugDelete：：operator（）<int>（int*）
第16章模板与泛型编程
unique_ptr<int，DebugDelete>p（newint，DebugDelete（））；
//销毁sp指向的对象
//实例化DebugDelete：：operator（）<string>（string*）
unique_ptr<string，DebugDelete>sp（newstring，DebugDelete（））；
在本例中，我们声明p的删除器的类型为DebugDelete，并在p的构造函数中提供了该
类型的一个未命名对象。
unique_ptr的析构函数会调用DebugDelete的调用运算符。因此，无论何时
unique_ptr的析构函数实例化时，DebugDelete的调用运算符都会实例化：因此，上
述定义会这样实例化。
//DebugDelete的成员模板实例化样例
voidDebugDelete：：operator（）（int*p）const{deletep；}
voidDebugDelete：：operator（）（string*p）const{deletep；}
类模板的成员模板
对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、
独立的模板参数。
例如，我们将为Blob类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素
范围。由于我们希望支持不同类型序列的迭代器，因此将构造函数定义为模板：
template<typenameT>classBlob{
template<typenameIt>Blob（Itb，Ite）；
//。。。
}；
此构造函数有自己的模板类型参数It，作为它的两个函数参数的类型。
与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成
674员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后
跟成员自己的模板参数列表：
template<typenameT>//类的类型参数
template<typenameIt>
Blob<T>：：Blob（Itb，
//构造函数的类型参数
Ite）：

Page623
16。1定义模板
data（std：：make_shared<std：：vector<T>>（b，e））{}
在此例中，我们定义了一个类模板的成员，类模板有一个模板类型参数，命名为T。而成
员自身是一个函数模板，它有一个名为It的类型参数。
实例化与成员模板
为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常
一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的
实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板
实参（参见16。1。1节，第579页）：
intia[]={0，1，2，3，4，5，6，7，8，9}；
vector<long>vi={0，1，2，3，4，5，6，7，8，9}；
list<constchar*>w={"now"，"is"，"the"，"time"}；
//实例化Blob<int>类及其接受两个int*参数的构造函数
Blob<int>al（begin（ia），end（ia））；
//实例化Blob<int>类的接受两个vector<long>：：iterator的构造函数
Blob<int>a2（vi。begin（），vi。end（））；
//实例化Blob<string>及其接受两个list<constchar*>：：iterator参数的构造函数
Blob<string>a3（w。begin（），w。end（））；
当我们定义al时，显式地指出编译器应该实例化一个int版本的Blob。构造函数自己
的类型参数则通过begin（ia）和end（ia）的类型来推断，结果为int*。因此，al的定
义实例化了如下版本：
Blob<int>：：Blob（int*，int*）；
a2的定义使用了已经实例化了的Blob<int>类，并用vector<short>：：iterator
替换It来实例化构造函数。a3的定义（显式地）实例化了一个string版本的Blob，
并（隐式地）实例化了该类的成员模板构造函数，其模板参数被绑定到list<const
char*>。
16。1。4节练习
练习16。21：编写你自己的DebugDelete版本。
练习16。22：修改12。3节（第430页）中你的TextQuery程序，令shared_ptr成
员使用DebugDelete作为它们的删除器（参见12。1。4节，第415页）。
练习16。23：预测在你的查询主程序中何时会执行调用运算符。如果你的预测和实际不
符，确认你理解了原因。
练习16。24：为你的Blob模板添加一个构造函数，它接受两个迭代器。
16。1。5控制实例化
当模板被使用时才会进行实例化（参见16。1。1节，第582页）这一特性意味着，相同
的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，
并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。
在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，
我们可以通过显式实例化（explicitinstantiation）来避免这种开销。一个显式实例化有如下
597
675
C++
11

Page624
598
形式：
externtemplatedeclaration；
templatedeclaration；
//实例化声明
//实例化定义
第16章模板与泛型编程
declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，
//实例化声明与定义
externtemplateclassBlob<string>；
//声明
templateintcompare（constint&，constint&）；//定义
当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声
明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对
于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。
由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使
用此实例化版本的代码之前：
//Application。cc
//这些模板类型必须在程序其他位置进行实例化
externtemplateclassBlob<string>；
externtemplateintcompare（constint&，constint&）；
Blob<string>sal，sa2；//实例化会出现在其他位置
//Blob<int>及其接受initializer_list的构造函数在本文件中实例化
Blob<int>al={0，1，2，3，4，5，6，7，8，9}；
Blob<int>a2（al）；//拷贝构造函数在本文件中实例化
inti=compare（al[0]，a2[0]）；//实例化出现在其他位置
676文件Application。o将包含Blob<int>的实例及其接受initializerlist参数的
构造函数和拷贝构造函数的实例。而compare<int>函数和Blob<string>类将不在本
文件中进行实例化。这些模板的定义必须出现在程序的其他文件中：
//templateBuild。cc
//实例化文件必须为每个在其他文件中声明为extern的类型和函数提供一个（非extern）
//的定义
templateintcompare（constint&，constint&）；
templateclassBlob<string>；//实例化类模板的所有成员
当编译器遇到一个实例化定义（与声明相对）时，它为其生成代码。因此，文件
templateBuild。o将会包含compare的int实例化版本的定义和Blob<string>类
的定义。当我们编译此应用程序时，必须将templateBuild。o和Application。o链
接到一起。
对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。
WARNING
实例化定义会实例化所有成员
一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译
器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通
实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例
化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。

Page625
16。1定义模板
Note
在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。
16。1。5节练习
练习16。25：解释下面这些声明的含义：
externtemplateclassvector<string>；
templateclassvector<Sales_data>；
练习16。26：假设NoDefault是一个没有默认构造函数的类，我们可以显式实例化
vector<Nodefault>吗?如果不可以，解释为什么。
练习16。27：对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话）。如
果一个模板被实例化，解释为什么；如果未实例化，解释为什么没有。
template<typenameT>classStack{}；
voidfl（Stack<char>）；
classExercise（
Stack<double>&rsd；
Stack<int>si；
}；
intmain（）{
Stack<char>*sc；
f1（*sc）；
intiobj
=
//（a）
//（b）
//（c）
//（d）
//（e）
sizeof（Stack<string>）；//（f）
16。1。6效率与灵活性
对模板设计者所面对的设计选择，标准库智能指针类型（参见12。1节，第400页）给
出了一个很好的展示。
shared_ptr和unique_ptr之间的明显不同是它们管理所保存的指针的策略-
前者给予我们共享指针所有权的能力；后者则独占指针。这一差异对两个类的功能来说是
至关重要的。
这两个类的另一个差异是它们允许用户重载默认删除器的方式。我们可以很容易地重
载一个shared_ptr的删除器，只要在创建或reset指针时传递给它一个可调用对象即
可。与之相反，删除器的类型是一个unique_ptr对象的类型的一部分。用户必须在定
义unique_ptr时以显式模板实参的形式提供删除器的类型。因此，对于unique_ptr
的用户来说，提供自己的删除器就更为复杂。
599
如何处理删除器的差异实际上就是这两个类功能的差异。但是，如我们将要看到的，677
这一实现策略上的差异可能对性能有重要影响。
在运行时绑定删除器
虽然我们不知道标准库类型是如何实现的，但可以推断出，shared_ptr必须能直接
访问其删除器。即，删除器必须保存为一个指针或一个封装了指针的类（如function，
参见14。8。3节，第512页）。
我们可以确定shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型

Page626
600
678
第16章模板与泛型编程
直到运行时才会知道。实际上，在一个shared_ptr的生存期中，我们可以随时改变其
删除器的类型。我们可以使用一种类型的删除器构造一个shared_ptr，随后使用reset
赋予此shared_ptr另一种类型的删除器。通常，类成员的类型在运行时是不能改变的。
因此，不能直接保存删除器。
为了考察删除器是如何正确工作的，让我们假定shared_ptr将它管理的指针保存
在一个成员p中，且删除器是通过一个名为del的成员来访问的。则shared_ptr的析
构函数必须包含类似下面这样的语句：
//del的值只有在运行时才知道；通过一个指针来调用它
del?del（p）：deletep；//del（p）需要运行时跳转到del的地址
由于删除器是间接保存的，调用del（p）需要一次运行时的跳转操作，转到del中保存的
地址来执行对应的代码。
在编译时绑定删除器
现在，让我们来考察unique_ptr可能的工作方式。在这个类中，删除器的类型是
类类型的一部分。即，unique_ptr有两个模板参数，一个表示它所管理的指针，另一个
表示删除器的类型。由于删除器的类型是unique_ptr类型的一部分，因此删除器成员
的类型在编译时是知道的，从而删除器可以直接保存在unique_ptr对象中。
unique_ptr的析构函数与shared_ptr的析构函数类似，也是对其保存的指针调
用用户提供的删除器或执行delete：
//del在编译时绑定；直接调用实例化的删除器
del（p）；//无运行时额外开销
del的类型或者是默认删除器类型，或者是用户提供的类型。到底是哪种情况没有关系，
应该执行的代码在编译时肯定会知道。实际上，如果删除器是类似DebugDelete（参见
16。1。4节，第595页）之类的东西，这个调用甚至可能被编译为内联形式。
通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过
在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。
16。1。6节练习
练习16。28：编写你自己版本的shared_ptr和unique_ptr。
练习16。29：修改你的Blob类，用你自己的shared_ptr代替标准库中的版本。
练习16。30：重新运行你的一些程序，验证你的shared_ptr类和修改后的Blob类。
（注意：实现weak_ptr类型超出了本书范围，因此你不能将BlobPtr类与你修改后
的Blob一起使用。）
练习16。31：如果我们将DebugDelete与unique_ptr一起使用，解释编译器将删
除器处理为内联形式的可能方式。
16。2模板实参推断
我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从
函数实参来确定模板实参的过程被称为模板实参推断（templateargumentdeduction）。在模

Page627
16。2模板实参推断
板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参
生成的函数版本与给定的函数调用最为匹配。
16。2。1类型转换与模板类型参数
与非模板函数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形
参。如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则。只有
很有限的几种类型转换会自动地应用于这些实参。编译器通常不是对实参进行类型转换，
而是生成一个新的模板实例。
与往常一样，顶层const（参见2。4。3节，第57页）无论是在形参中还是在实参中，
都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。
•const转换：可以将一个非const对象的引用（或指针）传递给一个const的
引用（或指针）形参（参见4。11。2节，第144页）。
•数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实
参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似
的，一个函数实参可以转换为一个该函数类型的指针（参见4。11。2节，第143页）。
其他类型转换，如算术转换（参见4。11。1节，第142页）、派生类向基类的转换（参见15。2。2
节，第530页）以及用户定义的转换（参见7。5。4节，第263页和14。9节，第514页），都
不能应用于函数模板。
作为一个例子，考虑对函数fobj和fref的调用。fobj函数拷贝它的参数，而fref
的参数是引用类型：
template<typenameT>Tfobj（T，T）；//实参被拷贝
template<typenameT>Tfref（constT&，constT&）；//引用
strings1（"avalue"）；
conststrings2（"anothervalue"）；
fobj（s1，s2）；
fref（s1，s2）；
inta[10]，b[42]；
fobj（a，b）；
fref（a，b）；
//调用fobj（string，string）；const被忽略
//调用fref（conststring&，conststring&）
//将s1转换为const是允许的
//调用f（int*，int*）
//错误：数组类型不匹配
在第一对调用中，我们传递了一个string和一个conststring。虽然这些类型不严格
匹配，但两个调用都是合法的。在fobj调用中，实参被拷贝，因此原对象是否是const
没有关系。在fref调用中，参数类型是const的引用。对于一个引用参数来说，转换
为const是允许的，因此这个调用也是合法的。
Note
在下一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在
fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型
为int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针
（参见6。2。4节，第195页）。a和b的类型是不匹配的，因此调用是错误的。
将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const
转换及数组或函数到指针的转换。
601
679
680

Page628
602
681
使用相同模板参数类型的函数形参
一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，
因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是
错误的。例如，我们的compare函数（参见16。1。1节，第578页）接受两个constT&
参数，其实参必须是相同类型：
longlng；
compare（ing，1024）；//错误：不能实例化compare（long，int）
此调用是错误的，因为传递给compare的实参类型不同。从第一个函数实参推断出的模
板实参为long，从第二个函数实参推断出的模板实参为int。这些类型不匹配，因此模
板实参推断失败。
如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型
参数：
//实参类型可以不同，但必须兼容
template<typenameA，typenameB>
intflexibleCompare（constA&vl，constB&v2）
{
第16章模板与泛型编程
if（v1<v2）return-1；
if（v2<vl）return1；
return0；
}
现在用户可以提供不同类型的实参了：
longing；
flexibleCompare（Ing，1024）；//正确：调用flexibleCompare（long，int）
当然，必须定义了能比较这些类型的值的<运算符。
{
正常类型转换应用于普通函数实参
函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数
实参不进行特殊处理；它们正常转换为对应形参的类型（参见6。1节，第183页）。例如，
考虑下面的模板：
template<typenameT>ostream&print（ostream&os，constT&obj）
returnos<<obj；
}
第一个函数参数是一个已知类型ostream&。第二个参数obj则是模板参数类型。由于
os的类型是固定的，因此当调用print时，传递给它的实参会进行正常的类型转换：
print（cout，42）；//实例化print（ostream&，int）
ofstreamf（"output"）；
print（f，10）；
//使用print（ostream&，int）；将f转换为ostream&
在第一个调用中，第一个实参的类型严格匹配第一个参数的类型。此调用会实例化接受一
个ostream&和一个int的print版本。在第二个调用中，第一个实参是一个ofstream，
它可以转换为ostream&（参见8。2。1节，第284页）。由于此参数的类型不依赖于模板参
数，因此编译器会将f隐式转换为ostream&。

Page629
16。2模板实参推断
Note
如果函数参数类型不是模板参数，则对实参进行正常的类型转换。
16。2。1节练习
练习16。32：在模板实参推断过程中发生了什么?
练习16。33：指出在模板实参推断过程中允许对函数实参进行的两种类型转换。
练习16。34：对下面的代码解释每个调用是否合法。如果合法，T的类型是什么?如果
不合法，为什么?
template<classT>intcompare（constT&，constT&）；
（a）compare（"hi"，"world"）；（b）compare（"bye"，"dad"）；
练习16。35：下面调用中哪些是错误的（如果有的话）?如果调用合法，T的类型是什
么?如果调用不合法，问题何在?
template<typenameT>Tcalc（T，int）；
template<typenameT>Tfcn（T，T）；
doubled；floatf；charc；
（a）calc（c，'c'）；
（c）fcn（c，'c'）；
练习16。36：进行下面的调用会发生什么：
（b）calc（d，f）；
（d）fcn（d，f）；
template<typenameT>f1（T，T）；
template<typenameT1，typenameT2）f2（T1，T2）；
inti=0，j42，*p1=&i，*p2=j
constint*cp1=&i，*cp2=&j；
=
（a）f1（p1，p2）；
（d）f2（cp1，cp2）；
（b）f2（p1，p2）；（c）f1（cp1，cp2）；
（e）f1（p1，cp1）；（e）f2（p1，cp1）；
16。2。2函数模板显式实参
在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许
用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最
常出现。
指定显式模板实参
作为一个允许用户指定使用类型的例子，我们将定义一个名为sum的函数模板，它
接受两个不同类型的参数。我们希望允许用户指定结果的类型。这样，用户就可以选择合
适的精度。
我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：
//编译器无法推断T1，它未出现在函数参数列表中
template<typenameT1，typenameT2，typenameT3>
Tlsum（T2，T3）；
在本例中，没有任何函数实参的类型可用来推断T1的类型。每次调用sum时调用者都必
须为T1提供一个显式模板实参（explicittemplateargument）。
我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号
中给出，位于函数名之后，实参列表之前：
603
682

Page630
604
683
第16章模板与泛型编程
//T1是显式指定的，T2和T3是从函数实参类型推断而来的
autoval3=sum<longlong>（i，lng）；//longlongsum（int，long）
此调用显式指定T1的类型。而T2和T3的类型则由编译器从i和lng的类型推断出来。
显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模
板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部（最右）参数的显式模
板实参才可以忽略，而且前提是它们可以从函数参数推断出来。如果我们的sum函数按
照如下形式编写：
//糟糕的设计：用户必须指定所有三个模板参数
template<typenameT1，typenameT2，typenameT3>
T3alternative_sum（T2，T1）；
则我们总是必须为所有三个形参指定实参：
//错误：不能推断前几个模板参数
autoval3=alternative_sum<longlong>（i，lng）；
//正确：显式指定了所有三个参数
autoval2=alternative_sum<longlong，int，long>（i，lng）；
正常类型转换应用于显式指定的实参
对于用普通类型定义的函数参数，允许进行正常的类型转换（参见16。2。1节，第602
页），出于同样的原因，对于模板类型参数已经显式指定了的函数实参，也进行正常的类型
转换：
longlng；
compare（Ing，1024）；
compare<long>（lng，1024）；
compare<int>（lng，1024）；
//错误：模板参数不匹配
//正确：实例化compare（long，long）
//正确：实例化compare（int，int）
如我们所见，第一个调用是错误的，因为传递给compare的实参必须具有相同的类
型。如果我们显式指定模板类型参数，就可以进行正常类型转换了。因此，调用
compare<long>等价于调用一个接受两个constlong&参数的函数。int类型的参数
被自动转化为long。在第三个调用中，T被显式指定为int，因此lng被转换为int。
16。2。2节练习
练习16。37：标准库max函数有两个参数，它返回实参中的较大者。此函数有一个模板
类型参数。你能在调用max时传递给它一个int和一个double吗?如果可以，如何
做?如果不可以，为什么?
练习16。38：当我们调用makeshare（参见12。1。1节，第401页）时，必须提供一个
显式模板实参。解释为什么需要显式模板实参以及它是如何使用的。
练习16。39：对16。1。1节（第578页）中的原始版本的compare函数，使用一个显式
模板实参，使得可以向函数传递两个字符串字面常量。
16。2。3尾置返回类型与类型转换
当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效
的。但在其他情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么
好处。例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个

Page631
16。2模板实参推断
元素的引用：
template<typenameIt>
???&fcn（Itbeg，Itend）
{
//处理序列
return*beg；//返回序列中一个元素的引用
}
我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型：
vector<int>vi={1，2，3，4，5}；
Blob<string>ca={"hi"，"bye"}；
auto&i=fcn（vi。begin（），vi。end（））；//fcn应该返回int&
auto&s=fcn（ca。begin（），ca。end（））；//fcn应该返回string&
此例中，我们知道函数应该返回*beg，而且知道我们可以用decltype（*beg）来获取此
表达式的类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义
此函数，我们必须使用尾置返回类型（参见6。3。3节，第206页）。由于尾置返回出现在参
数列表之后，它可以使用函数的参数：
//尾置返回允许我们在参数列表之后声明返回类型
template<typenameIt>
autofcn（Itbeg，Itend）->decltype（*beg）
{
//处理序列
return*beg；//返回序列中一个元素的引用
}
此例中我们通知编译器fen的返回类型与解引用beg参数的结果类型相同。解引用运算
符返回一个左值（参见4。1。1节，第121页），因此通过decltype推断的类型为beg表
示的元素的类型的引用。因此，如果对一个string序列调用fcn，返回类型将是
string&。如果是int序列，则返回类型是int&。
进行类型转换的标准库模板类
有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似fen的函
数，但返回一个元素的值（参见6。3。2节，第201页）而非引用。
在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一
无所知。在此函数中，我们知道唯一可以使用的操作是迭代器操作，而所有迭代器操作都
不会生成元素，只能生成元素的引用。
为了获得元素类型，我们可以使用标准库的类型转换（typetransformation）模板。这
些模板定义在头文件type_traits中。这个头文件中的类通常用于所谓的模板元程序设
计，这一主题已超出本书的范围。但是，类型转换模板在普通编程中也很有用。表16。1
列出了这些模板，我们将在16。5节（第624页）中看到它们是如何实现的。
在本例中，我们可以使用removereference来获得元素类型。remove_reference
模板有一个模板类型参数和一个名为type的（public）类型成员。如果我们用一个引
用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实
例化remove_reference<int&>，则type成员将是int。类似的，如果我们实例化
remove_reference<string&>，则type成员将是string，依此类推。更一般的，
给定一个迭代器beg：
605
684
C++
11

Page632
606
685
remove_reference<decltype（*beg）>：：type
将获得beg引用的元素的类型：decitype（*beg）返回元素类型的引用类型。
remove_reference：：type脫去引用，剩下元素类型本身。
组合使用remove_reference、尾置返回及decltype，我们就可以在函数中返回
元素值的拷贝：
//为了使用模板参数的成员，必须用typename，参见16。1。3节（第593页）
template<typenameIt>
autofcn2（Itbeg，Itend）->
typenameremove_reference<decltype（*beg）>：：type
{
//处理序列
return*beg；//返回序列中一个元素的拷贝
}
注意，type是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型
的声明中使用typename来告知编译器，type表示一个类型（参见16。1。3节，第593页）
对Mod<T>，其中Mod为
remove_reference
addconst
add_lvalue_reference
add_rvalue_reference
remove_pointer
add_pointer
make_signed
make_unsigned
removeextent。
表16。1：标准类型转换模板
若T为
X&或X&&
否则
removeallextents
第16章模板与泛型编程
X&sconstx或函数
否则
X&
X&&
否则
X&或X&&
否则
x*
否则
X&或X&&
否则
unsignedX
否则
带符号类型
否则
X[n]
否则
则Mod<T>：：type为
X
T
T
constT
T
X&
T&
T
T&&
x
T
x*
x
T
*
unsignedX
T
x
T
X[nl][n2]。。。
否则
表16。1中描述的每个类型转换模板的工作方式都与remove_reference类似。每
个模板都有一个名为type的public成员，表示一个类型。此类型与模板自身的模板类
型参数相关，其关系如模板名所示。如果不可能（或者不必要）转换模板参数，则type
成员就是模板参数类型本身。例如，如果T是一个指针类型，则
remove_pointer<T>：：type是T指向的类型。如果T不是一个指针，则无须进行任何
X
T

Page633
16。2模板实参推断
转换，从而type具有与T相同的类型。
16。2。3节练习
练习16。40：下面的函数是否合法?如果不合法，为什么?如果合法，对可以传递的实
参类型有什么限制（如果有的话）?返回类型是什么?
template<typenameIt>
autofcn3（Itbeg，Itend）->decltype（*beg+0）
{
//处理序列
return*beg；//返回序列中一个元素的拷贝
}
练习16。41：编写一个新的sum版本，它的返回类型保证足够大，足以容纳加法结果。
16。2。4函数指针和实参推断
当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值（参见6。7节，第
221页）时，编译器使用指针的类型来推断模板实参。
例如，假定我们有一个函数指针，它指向的函数返回int，接受两个参数，每个参数
都是指向constint的引用。我们可以使用该指针指向compare的一个实例：
template<typenameT>intcompare（constT&，constT&）；
//pf1指向实例intcompare（constint&，constint&）
int（*pf1）（constint&，constint&）=compare；
pf1中参数的类型决定了T的模板实参的类型。在本例中，T的模板实参类型为int。指
针pf1指向compare的int版本实例。如果不能从函数指针类型确定模板实参，则产
生错误：
//func的重载版本；每个版本接受一个不同的函数指针类型
voidfunc（int（*）（conststring&，conststring&））；
voidfunc（int（*）（constint&，constint&））；
func（compare）；//错误：使用compare的哪个实例?
这段代码的问题在于，通过func的参数类型无法确定模板实参的唯一类型。对func的
调用既可以实例化接受int的compare版本，也可以实例化接受string的版本。由于
不能确定func的实参的唯一实例化版本，此调用将编译失败。
我们可以通过使用显式模板实参来消除func调用的歧义：
//正确：显式指出实例化哪个compare版本
func（compare<int>）；//传递compare（constint&，constint&）
此表达式调用的func版本接受一个函数指针，该指针指向的函数接受两个constint&
参数。
Note
607
686
当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，687
能唯一确定其类型或值。

Page634
608
第16章模板与泛型编程
16。2。5模板实参推断和引用
为了理解如何从函数调用进行类型推断，考虑下面的例子：
template<typenameT>voidf（T&p）；
其中函数参数p是一个模板类型参数T的引用，非常重要的是记住两点：编译器会应用正
常的引用绑定规则；const是底层的，不是顶层的。
从左值引用函数参数推断类型
当一个函数参数是模板类型参数的一个普通（左值）引用时（即，形如T&），绑定规
则告诉我们，只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。实
参可以是const类型，也可以不是。如果实参是const的，则T将被推断为const类型：
template<typenameT>voidf1（T&）；//实参必须是一个左值
//对f1的调用使用实参所引用的类型作为模板参数类型
f1（i）；
//i是一个int；模板参数类型T是int
f1（ci）；//ci是一个constint；模板参数T是constint
f1（5）；//错误：传递给一个&参数的实参必须是一个左值
如果一个函数参数的类型是constT&，正常的绑定规则告诉我们可以传递给它任何
类型的实参——一个对象（const或非const）、一个临时对象或是一个字面常量值。当
函数参数本身是const时，T的类型推断的结果不会是一个const类型。const已经是
函数参数类型的一部分；因此，它不会也是模板参数类型的一部分：
template<typenameT>voidf2（constT&）；//可以接受一个右值
//f2中的参数是const&；实参中的const是无关的
//在每个调用中，f2的函数参数都被推断为constint&
f2（i）；//i是一个int；模板参数T是int
f2（ci）；//ci是一个constint，但模板参数T是int
f2（5）；//一个const&参数可以绑定到一个右值；T是int
从右值引用函数参数推断类型
当一个函数参数是一个右值引用（参见13。6。1节，第471页）（即，形如T&&）时，
正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通
左值引用函数参数的推断过程。推断出的T的类型是该右值实参的类型：
template<typenameT>voidf3（T&&）；
f3（42）；//实参是一个int类型的右值；模板参数T是int
688引用折叠和右值引用参数
假定i是一个int对象，我们可能认为像f3（i）这样的调用是不合法的。毕竟，i
是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。但是，C++语言在正常
绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是move这种标准库
设施正确工作的基础。
第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值（如i）传递
给函数的右值引用参数，且此右值引用指向模板类型参数（如T&&）时，编译器推断模板
类型参数为实参的左值引用类型。因此，当我们调用f3（i）时，编译器推断T的类型为
int&，而非int。
T被推断为int&看起来好像意味着f3的函数参数应该是一个类型int&的右值引用。

Page635
16。2模板实参推断
通常，我们不能（直接）定义一个引用的引用（参见2。3。1节，第46页）。但是，通过类
型别名（参见2。5。1节，第60页）或通过模板类型参数间接定义是可以的。
在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个引用的引
用，则这些引用形成了“折叠”。在所有情况下（除了一个例外），引用会折叠成一个普通
的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折
叠成右值引用：右值引用的右值引用。即，对于一个给定类型x：
•X&&&&&和X&&&都折叠成类型X&
•类型X&&&&折叠成X&&
引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。
Note
如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以
对一个左值调用f3。当我们将一个左值传递给f3的（右值引用）函数参数时，编译器推
断T为一个左值引用类型：
f3（i）；//实参是一个左值；模板参数T是int&
f3（ci）；//实参是一个左值；模板参数T是一个constint&
当一个模板参数T被推断为引用类型时，折叠规则告诉我们函数参数T&&折叠为一个左值
引用类型。例如，f3（i）的实例化结果可能像下面这样：
//无效代码，只是用于演示目的
voidf3<int&>（int&&&）；//当T是int&时，函数参数为int&&&
f3的函数参数是T&&且T是int&，因此T&&是int&&&，会折叠成int&。因此，即使
f3的函数参数形式是一个右值引用（即，T&&），此调用也会用一个左值引用类型（即，
int&）实例化f3：
voidf3<int&>（int&）；//当T是int&时，函数参数折叠为int&
这两个规则导致了两个重要结果：
•如果一个函数参数是一个指向模板类型参数的右值引用（如，T&&），则它可以被
绑定到一个左值；且
•如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将
被实例化为一个（普通）左值引用参数（T&）
另外值得注意的是，这两个规则暗示，我们可以将任意类型的实参传递给T&&类型的函数
参数。对于这种类型的参数，（显然）可以传递给它右值，而如我们刚刚看到的，也可以
传递给它左值。
Note
如果一个函数参数是指向模板参数类型的右值引用（如，T&&），则可以传递
給它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例
化为一个普通的左值引用（T&）。
编写接受右值引用参数的模板函数
模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响：
template<typenameT>voidf3（T&&val）
{
Tt=val；//拷贝还是绑定一个引用?
609
C++
11
689

Page636
610
690
第16章模板与泛型编程
t=fcn（t）；//赋值只改变t还是既改变t又改变val?
if（val==t）{/*。。。*/}//若T是引用类型，则一直为true
}
当我们对一个右值调用f3时，例如字面常量42，T为int。在此情况下，局部变量t的
类型为int，且通过拷贝参数val的值被初始化。当我们对t赋值时，参数val保持
不变。
另一方面，当我们对一个左值i调用f3时，则T为int&。当我们定义并初始化局
部变量t时，赋予它类型int&。因此，对t的初始化将其绑定到val。当我们对t赋值
时，也同时改变了val的值。在f3的这个实例化版本中，if判断永远得到true。
当代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的
代码就变得异常困难（虽然removereference这样的类型转换类可能会有帮助（参见
16。2。3节，第605页））。
在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。我们将在
16。2。7节（第612页）中介绍实参转发，在16。3节（第614页）中介绍模板重载。
目前应该注意的是，使用右值引用的函数模板通常使用我们在13。6。3节（第481页）
中看到的方式来进行重载：
template<typenameT>voidf（T&&）；
//绑定到非const右值
template<typenameT>voidf（constT&）；//左值和const右值
与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或
const右值。
16。2。5节练习
练习16。42：对下面每个调用，确定T和val的类型：
template<typenameT>voidg（T&&val）；
inti=0；constintci=i；
（a）g（i）；（b）g（ci）；（c）g（i*ci）；
=
ci），g的模板参数将是什
练习16。43：使用上一题定义的函数，如果我们调用g（i
么?
练习16。44：使用与第一题中相同的三个调用，如果g的函数参数声明为T（而不是T&&），
确定T的类型。如果g的函数参数是constT&呢?
练习16。45：给定下面的模板，如果我们对一个像42这样的字面常量调用g，解释会发
生什么?如果我们对一个int类型的变量调用g呢?
template<typenameT>voidg（T&&val）{vector<T>v；}
16。2。6理解std：：move
标准库move函数（参见13。6。1节，第472页）是使用右值引用的模板的一个很好的
例子。幸运的是，我们不必理解move所使用的模板机制也可以直接使用它。但是，研究
move是如何工作的可以帮助我们巩固对模板的理解和使用。
在13。6。2节（第473页）中我们注意到，虽然不能直接将一个右值引用绑定到一个左
值上，但可以用move获得一个绑定到左值上的右值引用。由于move本质上可以接受任

Page637
16。2模板实参推断
何类型的实参，因此我们不会惊讶于它是一个函数模板。
std：：move是如何定义的
标准库是这样定义move的：
//在返回类型和类型转换中也要用到typename，参见16。1。3节（第593页）
//remove_reference是在16。2。3节（第605页）中介绍的
template<typenameT>
typename
{
remove_reference<T>：：type&&move（T&&t）
//static_cast是在4。11。3节（第145页）中介绍的
returnstatic_cast<typenameremove_reference<T>：：type&&>（t）；
}
这段代码很短，但其中有些微妙之处。首先，move的函数参数T&&是一个指向模板类型
参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可
以传递给move一个左值，也可以传递给它一个右值：
stringsl（"hi!"），s2；
s2=std：：move（string（"bye!"））；//正确：从一个右值移动数据
s2=std：：move（s1）；//正确：但在赋值之后，s1的值是不确定的
std：：move是如何工作的
在第一个赋值中，传递给move的实参是string的构造函数的右值结果一
string（"bye!"）。如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，
由实参推断出的类型为被引用的类型（参见16。2。5节，第608页）。因此，在
std：：move（string（"bye!"））中：
推断出的T的类型为string。
因此，remove_reference用string进行实例化。
string。
remove_reference<string>type
•move的返回类型是string&&。
•move的函数参数t的类型为string&&。
因此，这个调用实例化move<string>，即函数
string&&move（string&&t）
函数体返回static_cast<string&&>（t）。t的类型已经是string&&，于是类型转
换什么都不做。因此，此调用的结果就是它所接受的右值引用。
现在考虑第二个赋值，它调用了std：：move（）。在此调用中，传递给move的实参
是一个左值。这样：
•推断出的T的类型为string&（string的引用，而非普通string）。
•因此，remove_reference用string&进行实例化。
•remove_reference<string&>type
•move的返回类型仍是string&&。
move的函数参数t实例化为string&&&，会折叠为string&。
因此，这个调用实例化move<string&>，即
string&&move（string&t）
string。
611
691

Page638
612
这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返
回static_cast<string&&>（t）。在此情况下，t的类型为string&，cast将其转
换为string&&。
从一个左值static_cast到一个右值引用是允许的
11
C++通常情况下，staticcast只能用于其他合法的类型转换（参见4。11。3节，第145
页）。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为
右值引用，但我们可以用static_cast显式地将一个左值转换为一个右值引用。
对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断
692左值。有时候，例如在我们的StrVec类的reallocate函数（参见13。6。1节，第469
页）中，我们知道截断一个左值是安全的。一方面，通过允许进行这样的转换，C++语言
认可了这种用法。但另一方面，通过强制使用static_cast，C++语言试图阻止我们意
外地进行这种转换。
最后，虽然我们可以直接编写这种类型转换代码，但使用标准库move函数是容易得
多的方式。而且，统一使用std：：move使得我们在程序中查找潜在的截断左值的代码变
得很容易。
第16章模板与泛型编程
16。2。6节练习
练习16。46：解释下面的循环，它来自13。5节（第469页）中的StrVec：：reallocate：
for（sizeti=0；i!=size（）；++i）
alloc。construct（dest++，std：：move（*elem++））；
16。2。7转发
某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们
需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。
作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我
们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函
数的初步模样：
//接受一个可调用对象和另外两个参数的模板
//对“翻转”的参数调用给定的可调用对象
//flipl是一个不完整的实现：顶层const和引用丟失了
template<typenameF，typenameT1，typenameT2>
voidflip1（Ff，T1t1，T2t2）
{
f（t2，t1）；
}
}
这个函数一般情况下工作得很好，但当我们希望用它调用一个接受引用参数的函数时就会
出现问题：
voidf（intv1，int&v2）//注意v2是一个引用
{
cout<<v1<<"<<++v2<<endl；

Page639
16。2模板实参推断
在这段代码中，f改变了绑定到v2的实参的值。但是，如果我们通过flip1调用f，f
所做的改变就不会影响实参：
f（42，i）；
//f改变了实参i
flipl（f，j，42）；//通过flip1调用f不会改变j
问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非
int&。因此，这个flip1调用会实例化为
voidflipl（void（*fcn）（int，int&），intt1，intt2）；
j的值被拷贝到t1中。f中的引用参数被绑定到t1，而非j，从而其改变不会影响j。
定义能保持类型信息的函数参数
为了通过翻转函数传递一个引用，我们需要重写函数，使其参数能保持给定实参的“左
值性”。更进一步，可以想到我们也希望保持参数的const属性。
通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应
实参的所有类型信息。而使用引用参数（无论是左值还是右值）使得我们可以保持const
属性，因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&&和T2&&，
通过引用折叠（参见16。2。5节，第608页）就可以保持翻转实参的左值/右值属性（参见
16。2。5节，第608页）：
template<typenameF，typenameT1，typenameT2>
voidflip2（Ff，T1&&t1，T2&&t2）
{
f（t2，t1）；
}
与较早的版本一样，如果我们调用flip2（f，j，42），将传递给参数t1一个左值j。
但是，在flip2中，推断出的T1的类型为int&，这意味着t1的类型会折叠为int&。
由于是引用类型，t1被绑定到j上。当flip2调用f时，f中的引用参数v2被绑定到
t1，也就是被绑定到j当f递增v2时，它也同时改变了j的值。
Note
如果一个函数参数是指向模板类型参数的右值引用（如T&&），它对应的实参
的const属性和左值/右值属性将得到保持。
这个版本的flip2解决了一半问题。它对于接受一个左值引用的函数工作得很好，
但不能用于接受右值引用参数的函数。例如：
voidg（int&&i，int&j）
{
cout<<i<<""<<j<<endl；
}
如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传
递一个右值给flip2：
flip2（g，i，42）；//错误：不能从一个左值实例化int&&
传递给g的将是flip2中名为t2的参数。函数参数与其他任何变量一样，都是左值表
达式（参见13。6。1节，第471页）。因此，flip2中对g的调用将传递给g的右值引用参
数一个左值。
613
693

Page640
614
694
11
695
在调用中使用std：：forward保持类型信息
我们可以使用一个名为forward的新标准库设施来传递flip2的参数，它能保持原
始实参的类型｡类似move，forward定义在头文件utility中。与move不同，forward
必须通过显式模板实参来调用（参见16。2。2节，第603页）。forward返回该显式实参类
型的右值引用。即，forward<T>的返回类型是T&&。
通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参
数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值属性：
template<typenameType>intermediary（Type&&arg）
{
第16章模板与泛型编程
Note
finalFcn（std：：forward<Type>（arg））；
//。。。
}
本例中我们使用Type作为forward的显式模板实参类型，它是从arg推断出来的。由
于arg是一个模板类型参数的右值引用，Type将表示传递给arg的实参的所有类型信息。
如果实参是一个右值，则Type是一个普通（非引用）类型，forward<Type>将返回
Type&&。如果实参是一个左值，则通过引用折叠，Type本身是一个左值引用类型。在此
情况下，返回类型是一个指向左值引用类型的右值引用。再次对forward<Type>的返回
类型进行引用折叠，将返回一个左值引用类型。
Note
当用于一个指向模板参数类型的右值引用函数参数（T&&）时，forward会保
持实参类型的所有细节。
使用forward，我们可以再次重写翻转函数：
template<typenameF，typenameT1，typenameT2>
voidflip（Ff，T1&&t1，T2&&t2）
{
f（std：：forward<T2>（t2），std：：forward<T1>（t1））；
}
如果我们调用flip（g，i，42），i将以int&类型传递给g，42将以int&&类型传递
给go
与std：：move相同，对std：：forward不使用using声明是一个好主意。
我们将在18。2。3节（第706页）中解释原因。
16。2。7节练习
练习16。47：编写你自己版本的翻转函数，通过调用接受左值和右值引用参数的函数来
测试它。
16。3重载与模板
函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函
数必须具有不同数量或类型的参数。
如果涉及函数模板，则函数匹配规则（参见6。4节，第209页）会在以下几方面受到

Page641
16。3重载与模板
影响：
•对于一个调用，其候选函数包括所有模板实参推断（参见16。2节，第600页）成
功的函数模板实例。
候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。
●
与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来
排序。当然，可以用于函数模板调用的类型转换是非常有限的（参见16。2。1节，第
601页）。
•与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。
但是，如果有多个函数提供同样好的匹配，则：
如果同样好的函数中只有一个是非模板函数，则选择此函数。
如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比
其他模板更特例化，则选择此模板。
否则，此调用有歧义。
WARNING
编写重载模板
作为一个例子，我们将构造一组函数，它们在调试中可能很有用。我们将这些调试函
数命名为debug_rep，每个函数都返回一个给定对象的string表示。我们首先编写此
函数的最通用版本，将它定义为一个模板，接受一个const对象的引用：
正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的
实参类型转换有深刻的理解。
//打印任何我们不能处理的类型
template<typenameT>stringdebug_rep（constT&t）
{
ostringstreamret；//参见8。3节（第287页）
ret<<t；//使用T的输出运算符打印t的一个表示形式
returnret。str（）；//返回ret绑定的string的一个副本
}
此函数可以用来生成一个对象对应的string表示，该对象可以是任意具备输出运算符的
类型。
{
接下来，我们将定义打印指针的debug_rep版本：
//打印指针的值，后跟指针指向的对象
//注意：此函数不能用于char*；参见16。3节（第617页）
template<typenameT>stringdebug_rep（T*p）
ostringstreamret；
ret<<"pointer："
if（p）
else
<<pi
"1
//打印指针本身的值
ret<<"<<debug_rep（*p）；//打印p指向的值
ret<<"nullpointer"；//或指出p为空
returnret。str（）；//返回ret绑定的string的一个副本
}
此版本生成一个string，包含指针本身的值和调用debug_rep获得的指针指向的值。
注意此函数不能用于打印字符指针，因为IO库为char*值定义了一个<<版本。此<<版本
假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。我们将在16。3
615
696

Page642
616
697
节（第617页）介绍如何处理字符指针。
我们可以这样使用这些函数：
strings（"hi"）；
cout<<debug_rep（s）<<endl；
对于这个调用，只有第一个版本的debug_rep是可行的。第二个debug_rep版本要求
一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指
针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。由于只有一个可行
函数，所以此函数被调用。
如果我们用一个指针调用debug_rep：
cout<<debug_rep（&s）<<endl；
两个函数都生成可行的实例：
第16章模板与泛型编程
•debug_rep（conststring*&），由第一个版本的debug_rep实例化而来，T
被绑定到string*。
•debug_rep（string*），由第二个版本的debug_rep实例化而来，T被绑定到
string。
第二个版本的debug_rep的实例是此调用的精确匹配。第一个版本的实例需要进行普通
指针到const指针的转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编
译器确实选择了这个版本。
多个可行模板
作为另外一个例子，考虑下面的调用：
conststring*sp=&s；
cout<<debug_rep（sp）<<endl；
此例中的两个模板都是可行的，而且两个都是精确匹配：
debug_rep（conststring*&），由第一个版本的debug_rep实例化而来，T
被绑定到string*。
debug_rep（conststring*），由第二个版本的debug_rep实例化而来，T
被绑定到conststring。
在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义
的。但是，根据重载函数模板的特殊规则，此调用被解析为debug_rep（T*），即，更特
例化的版本。
设计这条规则的原因是，没有它，将无法对一个const的指针调用指针版本的
debug_rep。问题在于模板debug_rep（constT&）本质上可以用于任何类型，包括指
针类型。此模板比debug_rep（T*）更通用，后者只能用于指针类型。没有这条规则，传
递const的指针的调用永远是有歧义的。
Note
当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。
非模板和模板重载
作为下一个例子，我们将定义一个普通非模板版本的debug_rep来打印双引号包围

Page643
16。3重载与模板
的string：
//打印双引号包围的string
stringdebug_rep（conststring&s）
{
}
现在，当我们对一个string调用debug_rep时：
return57+S+'''；
strings（"hi"）；
cout<<debug_rep（s）<<endl；
有两个同样好的可行函数：
•debug_rep<string>（conststring&），第一个模板，T被绑定到string*。
•debug_rep（conststring&），普通非模板函数。
在本例中，两个函数具有相同的参数列表，因此显然两者提供同样好的匹配。但是，编译
器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，出
于相同的原因，一个非模板函数比一个函数模板更好。
对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选
Note择非模板版本。
重载模板和类型转换
还有一种情况我们到目前为止尚未讨论：C风格字符串指针和字符串字面常量。现在
有了一个接受string的debug_rep版本，我们可能期望一个传递字符串的调用会匹配
这个版本。但是，考虑这个调用：
cout<<debug_rep（"hiworld!"）<<endl；//调用debug_rep（T*）
本例中所有三个debug_rep版本都是可行的：
•debug_rep（constT&），T被绑定到char[10]。
•debug_rep（T*），T被绑定到constchar。
•debug_rep（conststring&），要求从constchar*到string的类型转换。
对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次（许可的）数组
到指针的转换，而对于函数匹配来说，这种转换被认为是精确匹配（参见6。6。1节，第219
页）。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配
那么好，所以两个模板成为可能调用的函数。与之前一样，T*版本更加特例化，编译器会
选择它。
如果我们希望将字符指针按string处理，可以定义另外两个非模板重载版本：
//将字符指针转换为string，并调用string版本的debug_reg
stringdebug_rep（char*p）
{
}
}
returndebug_rep（string（p））；
stringdebug_rep（constchar*p）
{
returndebug_rep（string（p））；
617
698

Page644
618
699
C++
11
缺少声明可能导致程序行为异常
值得注意的是，为了使char*版本的debug_rep正确工作，在定义此版本时，
debug_rep（conststring&）的声明必须在作用域中。否则，就可能调用错误的
debug_rep版本：
template<typenameT>stringdebug_rep（constT&t）；
template<typenameT>stringdebug_rep（T*p）；
//为了使debug_rep（char*）的定义正确工作，下面的声明必须在作用域中
stringdebug_rep（conststring&）；
stringdebug_rep（char*p）
{
V
第16章模板与泛型编程
}
通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而
言，则不是这样。如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不
重要了。在本例中，如果忘记了声明接受string参数的debug_rep版本，编译器会默
默地实例化接受constT&的模板版本。
Tip
//如果接受一个conststring&的版本的声明不在作用域中，
//返回语句将调用debug_rep（constT&）的T实例化为string的版本
returndebug_rep（string（p））；
在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器
由于未遇到你希望调用的函数而实例化一个并非你所需的版本。
16。3节练习
练习16。48：编写你自己版本的debug_rep函数。
练习16。49：解释下面每个调用会发生什么：
template<typenameT>voidf（T）；
template<typenameT>voidf（constT*）；
template<typenameT>voidg（T）；
template<typenameT>voidT*）
inti=42，*p=&i；
constintci=0，*p2=&ci；
g（42）；g（p）；g（ci）；g（p2）；
f（42）；f（p）；f（ci）；f（p2）；
练习16。50：定义上一个练习中的函数，令它们打印一条身份信息。运行该练习中的代
码。如果函数调用的行为与你预期不符，确定你理解了原因。
16。4可变参数模板
一个可变参数模板（variadictemplate）就是一个接受可变数目参数的模板函数或模板
类。可变数目的参数被称为参数包（parameterpacket）。存在两种参数包：模板参数包
700（templateparameterpacket），表示零个或多个模板参数；函数参数包（functionparameter
packet），表示零个或多个函数参数。
我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表

Page645
16。4可变参数模板
中，class。。。或typename。。。指出接下来的参数表示零个或多个类型的列表；一个类型
名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，
如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：
//Args是一个模板参数包；rest是一个函数参数包
//Args表示零个或多个模板类型参数
//rest表示零个或多个函数参数
template<typenameT，typename。。。Args>
voidfoo（constT&t，constArgs&
rest）；
声明了foo是一个可变参数函数模板，它有一个名为T的类型参数，和一个名为Args
的模板参数包。这个包表示零个或多个额外的类型参数。foo的函数参数列表包含一个
const&类型的参数，指向T的类型，还包含一个名为rest的函数参数包，此包表示零
个或多个函数参数。
与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译
器还会推断包中参数的数目。例如，给定下面的调用：
inti=0；doubled=3。14；strings="hownowbrowncow"；
//包中有三个参数
//包中有两个参数
//包中有一个参数
//空包
foo（i，s，42，d）；
foo（s，42，"hi"）；
foo（d，s）；
foo（"hi"）；
编译器会为foo实例化出四个不同的版本：
voidfoo（constint&，conststring&，constint&，constdouble&）；
voidfoo（conststring&，constint&，constchar[3]&）；
voidfoo（constdouble&，conststring&）；
voidfoo（constchar[3]&）；
在每个实例中，T的类型都是从第一个实参的类型推断出来的。剩下的实参（如果有的话）
提供函数额外实参的数目和类型。
sizeof。。。运算符
当我们需要知道包中有多少元素时，可以使用sizeof。。。运算符。类似sizeof（参
见4。9节，第139页），sizeof。。。也返回一个常量表达式（参见2。4。4节，第58页），而且
不会对其实参求值：
template<typename
Args>voidg（Args
args）{
cout<<sizeof。。。（Args）<<endl；//类型参数的数目
cout<<sizeof。。。（args）<<endl；//函数参数的数目
}
16。4节练习
练习16。51：调用本节中的每个foo，确定sizeof。。。（Args）和sizeof（rest）分别
返回什么。
练习16。52：编写一个程序验证上一题的答案。
619
C++
11
701

Page646
620
16。4。1编写可变参数函数模板
如6。2。6节（第198页）所述，我们可以使用一个initializer_list来定义一个
可接受可变数目实参的函数。但是，所有实参必须具有相同的类型（或它们的类型可以转
换为同一个公共类型）。当我们既不知道想要处理的实参的数目也不知道它们的类型时，
可变参数函数是很有用的。作为一个例子，我们将定义一个函数，它类似较早的
error_msg函数，差别仅在于新函数实参的类型也是可变的。我们首先定义一个名为
print的函数，它在一个给定流上打印给定实参列表的内容。
可变参数函数通常是递归的（参见6。3。2节，第204页）。第一步调用处理包中的第一
个实参，然后用剩余实参调用自身。我们的print函数也是这样的模式，每次递归调用
将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变
参数的print函数，它接受一个流和一个对象：
//用来终止递归并打印最后一个元素的函数
//此函数必须在可变参数版本的print定义之前声明
template<typenameT>
ostream&print（ostream&os，constT&t）
{
returnos<<t；//包中最后一个元素之后不打印分隔符
}
//包中除了最后一个元素之外的其他元素都会调用这个版本的print
第16章模板与泛型编程
template<typenameT，typename。。。Args>
ostream&print（ostream&os，constT&t，constArgs&。。。rest）
{
os<<t<<"，"；
returnprint（os，rest。。。）；
//打印第一个实参
//递归调用，打印其他实参
}
第一个版本的print负责终止递归并打印初始调用中的最后一个实参。第二个版本的
print是可变参数版本，它打印绑定到t的实参，并调用自身来打印函数参数包中的剩
余值。
这段程序的关键部分是可变参数函数中对print的调用：
returnprint（os，rest。。。）；//递归调用，打印其他实参
我们的可变参数版本的print函数接受三个参数：一个ostream&，一个constT&和
个参数包。而此调用只传递了两个实参。其结果是rest中的第一个实参被绑定到t，剩
702余实参形成下一个print调用的参数包。因此，在每个调用中，包中的第一个实参被移
除，成为绑定到t的实参。即，给定：
print（cout，i，s，42）；//包中有两个参数
递归会执行如下：
调用
print（cout，i，s，42）
print（cout，s，42）
S
print（cout，42）调用非可变参数版本的print
t
i
rest。。。
s，42
42
前两个调用只能与可变参数版本的print匹配，非可变参数版本是不可行的，因为这两
个调用分别传递四个和三个实参，而非可变参数print只接受两个实参。

Page647
16。4可变参数模板
对于最后一次递归调用print（cout，42），两个print版本都是可行的。这个调
用传递两个实参，第一个实参的类型为ostream&。因此，可变参数版本的print可以
实例化为只接受两个参数：一个是ostream&参数，另一个是constT&参数。
对于最后一个调用，两个函数提供同样好的匹配。但是，非可变参数模板比可变参数
模板更特例化，因此编译器选择非可变参数版本（参见16。3节，第615页）。
当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。
WARNING否则，可变参数版本会无限递归。
16。4。1节练习
练习16。53：编写你自己版本的print函数，并打印一个、两个及五个实参来测试它，
要打印的每个实参都应有不同的类型。
练习16。54：如果我们对一个没有<<运算符的类型调用print，会发生什么?
练习16。55：如果我们的可变参数版本print的定义之后声明非可变参数版本，解释可
变参数的版本会如何执行。
16。4。2包扩展
对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）
它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）。扩展一个包就是
将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边
放一个省略号（。。。）来触发扩展操作。
例如，我们的print函数包含两个扩展：
template<typenameT，typename。。。Args>
ostream&
print（ostream&os，constT&t，constArgs&。。。rest）
{
os<<t<<"，"；
returnprint（os，rest。。。）；
//扩展Args
//扩展rest
}
第一个扩展操作扩展模板参数包，为print生成函数参数列表。第二个扩展操作出现在
对print的调用中。此模式为print调用生成实参列表。
对Args的扩展中，编译器将模式constArg&应用到模板参数包Args中的每个元
素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如
consttype&。例如：
print（cout，i，s，42）；//包中有两个参数
最后两个实参的类型和模式一起确定了尾置参数的类型。此调用被实例化为：
ostream&
print（ostream&，constint&，conststring&，constint&）；
第二个扩展发生在对print的（递归）调用中。在此情况下，模式是函数参数包的
名字（即rest）。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调
621
703

Page648
622
704
C++
11
用等价于：
print（os，s，42）；
理解包扩展
print中的函数参数包扩展仅仅将包扩展为其构成元素，C++语言还允许更复杂的扩
展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用debug_rep（参
见16。3节，第615页），然后调用print打印结果string：
//在print调用中对每个实参调用debug_rep
template<typename。。。Args>
ostream&errorMsg（ostream&os，constArgs&。。。rest）
{
第16章模板与泛型编程
//print（os，debug_rep（al），debug_rep（a2），
returnprint（os，debug_rep（rest）。。。）；
}
这个print调用使用了模式debug_reg（rest）。此模式表示我们希望对函数参数
包rest中的每个元素调用debug_rep。扩展结果将是一个逗号分隔的debug_rep调
用列表。即，下面调用：
debug_rep（an）
errorMsg（cerr，fcnName，code。num（），otherData，"other"，item）；
就好像我们这样编写代码一样
print（cerr，debug_rep（fcnName），debug_rep（code。num（）），
debug_rep（otherData），debug_rep（"otherData"），
debug_rep（item））；
Note
与之相对，下面的模式会编译失败
//将包传递给debug_rep；print（os，debug_rep（al，a2，
print（os，debug_rep（rest。。。））；//错误：此调用无匹配函数
这段代码的问题是我们在debug_rep调用中扩展了rest，它等价于
print（cerr，debug_rep（fcnName，code。num（），
扩展中的模式会独立地应用于包中的每个元素。
otherData，"otherData"，item））；
在这个扩展中，我们试图用一个五个实参的列表来调用debug_rep，但并不存在与此调
用匹配的debug_rep版本。debug_rep函数不是可变参数的，而且没有哪个debug_rep
版本接受五个参数。
an））
16。4。2节练习
练习16。56：编写并测试可变参数版本的errorMsg。
练习16。57：比较你的可变参数版本的errorMsg和6。2。6节（第198页）中的error_msg
函数。两种方法的优点和缺点各是什么?
16。4。3转发参数包
在新标准下，我们可以组合使用可变参数模板与forward机制来编写函数，实现将

Page649
16。4可变参数模板
其实参不变地传递给其他函数。作为例子，我们将为StrVec类（参见13。5节，第465
页）添加一个emplace_back成员。标准库容器的emplace_back成员是一个可变参
数成员模板（参见16。1。4节，第596页），它用其实参在容器管理的内存空间中直接构造
一个元素。
我们为StrVec设计的emplace_back版本也应该是可变参数的，因为string有
多个构造函数，参数各不相同。由于我们希望能使用string的移动构造函数，因此还需
要保持传递给emplace_back的实参的所有类型信息。
如我们所见，保持类型信息是一个两阶段的过程。首先，为了保持实参中的类型信息，
必须将emplace_back的函数参数定义为模板类型参数的右值引用（参见16。2。7节，第
613页）：
classStrVec{
public：
template<class。。。Args>voidemplace_back（Args&&。。。）；
//其他成员的定义，同13。5节（第465页）
}；
模板参数包扩展中的模式是&&，意味着每个函数参数将是一个指向其对应实参的右值引
用。
其次，当emplace_back将这些实参传递给construct时，我们必须使用forward
来保持实参的原始类型（参见16。2。7节，第614页）：
template<class。。。Args>
inline。
voidStrVec：：emplace_back（Args&&。。。args）
{
chknalloc（）；//如果需要的话重新分配StrVec内存空间
alloc。construct（firstfree++，std：：forward<Args>（args）。。。）；
emplace_back的函数体调用了chk_n_alloc（参见13。5节，第465页）来确保有足
够的空间容纳一个新元素，然后调用了construct在first_free指向的位置中创建
了一个元素。construct调用中的扩展为
std：：forward<Args>（args）。。。
它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素
std：：forward<T>（t）
其中T表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如，
假定svec是一个StrVec，如果我们调用
svec。emplace_back（10，'c'）；//将cccccccccc添加为新的尾元素
construct调用中的模式会扩展出
std：：forward<int>（10），std：：forward<char>（c）
通过在此调用中使用forward，我们保证如果用一个右值调用emplace_back，则
construct也会得到一个右值。例如，在下面的调用中：
svec。emplace_back（s1+s2）；//使用移动构造函数
传递给emplace_back的实参是一个右值，它将以如下形式传递给construct
623
705

Page650
624
706
第16章模板与泛型编程
std：：forward<string>（string（"theend"））
forward<string>的结果类型是string&&，因此construct将得到一个右值引用实
参。construct会继续将此实参传递给string的移动构造函数来创建新元素。
建议：转发和可变参数模板
可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的
emplace_back函数一样的形式：
//fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用
template<typename。。。Args>
voidfun（Args&&。。。args）//将Args扩展为一个右值引用的列表
（
//work的实参既扩展Args又扩展args
work（std：：forward<Args>（args）。。。）；
}
这里我们希望将fun的所有实参转发给另一个名为work的函数，假定由它完成函数的
实际工作。类似emplace_back中对construct的调用，work调用中的扩展既扩展
了模板参数包也扩展了函数参数包。
由于fun的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们
使用std：：forward传递这些实参，因此它们的所有类型信息在调用work时都会得
到保持。
16。4。3节练习
练习16。58：为你的StrVec类及你为16。1。2节（第591页）练习中编写的Vec类添加
emplaceback函数。
练习16。59：假定s是一个string，解释调用svec。emplace_back（s）会发生什么。
练习16。60：解释make_shared（参见12。1。1节，第401页）是如何工作的。
练习16。61：定义你自己版本的makeshared。
16。5模板特例化
编写单一模板，使之对任何可能的模板实参都是最适合的，都能实例化，这并不总是
能办到。在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败
或做得不正确。其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从
通用模板实例化。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一
个特例化版本。
我们的compare函数是一个很好的例子，它展示了函数模板的通用定义不适合一个
特定类型（即字符指针）的情况。我们希望compare通过调用strcmp比较两个字符指
针而非比较指针值。实际上，我们已经重载了compare函数来处理字符串字面常量（参
见16。1。1节，第579页）：

Page651
16。5模板特例化
//第一个版本；可以比较任意两个类型
template<typenameT>intcompare（constT&，constT&）；
//第二个版本处理字符串字面常量
template<size_tN，size_tM>
intcompare（constchar（&）[N]，constchar（&）[M]）；
但是，只有当我们传递给compare一个字符串字面常量或者一个数组时，编译器才会调
用接受两个非类型模板参数的版本。如果我们传递给它字符指针，就会调用第一个版本：
constchar*p1="hi"，*p2="mom"；
compare（p1，p2）；
compare（"hi"，"mom"）；
//调用第一个模板
//调用有两个非类型参数的版本
我们无法将一个指针转换为一个数组的引用，因此当参数是p1和p2时，第二个版本的
compare是不可行的。
为了处理字符指针（而不是数组），可以为第一个版本的compare定义一个模板特例
化（templatespecialization）版本。一个特例化版本就是模板的一个独立的定义，在其中一
个或多个模板参数被指定为特定的类型。
定义函数模板特例化
当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指
出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对（<>）。空尖
括号指出我们将为原模板的所有模板参数提供实参：
//compare的特殊版本，处理字符数组的指针
template<>
intcompare（constchar*const&pl，constchar*const&p2）
{
returnstrcmp（p1，p2）；
}
理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数
类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：
template<typenameT>intcompare（constT&，constT&）；
其中函数参数为一个const类型的引用。类似类型别名，模板参数类型、指针及const
之间的相互作用会令人惊讶（参见2。5。1节，第60页）。
我们希望定义此函数的一个特例化版本，其中T为constchar*。我们的函数要求
一个指向此类型const版本的引用。一个指针类型的const版本是一个常量指针而不是
指向const类型的指针（参见2。4。2节，第56页）。我们需要在特例化版本中使用的类型
是constchar*const&，即一个指向constchar的const指针的引用。
Note
函数重载与模板特例化
当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模
板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而
非函数名的一个重载版本。
特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。
625
707
708

Page652
626
709
第16章模板与泛型编程
我们将一个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到
函数匹配。例如，我们已经定义了两个版本的compare函数模板，一个接受数组引用参
数，另一个接受constT&。我们还定义了一个特例化版本来处理字符指针，这对函数匹
配没有影响。当我们对字符串字面常量调用compare时
compare（"hi"，"mom"）
对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字
符数组参数的版本更特例化（参见16。3节，第615页），因此编译器会选择它。
如果我们将接受字符指针的compare版本定义为一个普通的非模板函数（而不是模
板的一个特例化版本），此调用的解析就会不同。在此情况下，将会有三个可行的函数：
两个模板和非模板的字符指针版本。所有三个函数都提供同样好的匹配。如前所述，当一
个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本（参见16。3节，
第615页）。
关键概念：普通作用域规则应用于特例化
为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例
的代码之前，特例化版本的声明也必须在作用域中。
对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处
理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生
成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特
例化版本声明顺序导致的错误，而这种错误又很难查找。
如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参
集合，就会产生错误。但是，这种错误编译器又无法发现。
Best
Practices
模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放
在前面，然后是这些模板的特例化版本。
类模板特例化
除了特例化函数模板，我们还可以特例化类模板。作为一个例子，我们将为标准库
hash模板定义一个特例化版本，可以用它来将Sales_data对象保存在无序容器中。默
认情况下，无序容器使用hash<key_type>（参见11。4节，第394页）来组织其元素。
为了让我们自己的数据类型也能使用这种默认组织方式，必须定义hash模板的一个特例
化版本。一个特例化hash类必须定义：
•一个重载的调用运算符（参见14。8节，第506页），它接受一个容器关键字类型的
对象，返回一个sizet。
两个类型成员，result_type和argument_type，分别调用运算符的返回类型
和参数类型。
‧默认构造函数和拷贝赋值运算符（可以隐式定义，参见13。1。2节，第443页）。
在定义此特例化版本的hash时，唯一复杂的地方是：必须在原模板定义所在的命名空
间中特例化它。我们将在18。2节（第695页）中介绍更多命名空间的相关内容。现在，我
们只需知道——我们可以向命名空间添加成员。为了达到这一目的，首先必须打开命名空间：
//打开std命名空间，以便特例化std：：hash
namespacestd{

Page653
16。5模板特例化
}//关闭std命名空间；注意：右花括号之后没有分号
花括号对之间的任何定义都将成为命名空间std的一部分。
下面的代码定义了一个能处理Sales_data的特例化hash版本：
//打开std命名空间，以便特例化std：：hash
namespacestd{
template<>//我们正在定义一个特例化版本，模板参数为Salesdata
structhash<Sales_data>
{
//用来散列一个无序容器的类型必须要定义下列类型
typedefsize_tresult_type；
typedefSales_dataargument_type；//默认情况下，此类型需要==
size_toperator（）（constSales_data&s）const；
//我们的类使用合成的拷贝控制成员和默认构造函数
}；
sizet
{
hash<Sales_data>：：operator（）（constSales_data&s）const
returnhash<string>（）（s。bookNo）
hash<unsigned>（）（s。units_sold）
hash<double>（）（s。revenue）；
}
}//关闭std命名空间；注意：右花括号之后没有分号
^
我们的hash<Sales_data>定义以template<>开始，指出我们正在定义一个全特例化
的模板。我们正在特例化的模板名为hash，而特例化版本为hash<Sales_data>。接
下来的类成员是按照特例化hash的要求而定义的。
类似其他任何类，我们可以在类内或类外定义特例化版本的成员，本例中就是在类外
定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任
何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）
应该产生不同的结果。
在本例中，我们将定义一个好的哈希函数的复杂任务交给了标准库。标准库为内置类
型和很多标准库类型定义了hash类的特例化版本。我们使用一个（未命名的）
hash<string>对象来生成bookNo的哈希值，用一个hash<unsigned>对象来生成
units_sold的哈希值，用一个hash<double>对象来生成revenue的哈希值。我们
将这些结果进行异或运算（参见4。8节，第137页），形成给定Salesdata对象的完整
的哈希值。
值得注意的是，我们的hash函数计算所有三个数据成员的哈希值，从而与我们为
Sales_data定义的operator==（参见14。3。1节，第497页）是兼容的。默认情况下，
为了处理特定关键字类型，无序容器会组合使用key_type对应的特例化hash版本和
key_type上的相等运算符。
假定我们的特例化版本在作用域中，当将Sales_data作为容器的关键字类型时，
编译器就会自动使用此特例化版本：
//使用hash<Salesdata>和14。3。1节（第497页）中Salesdata的operator==
unorderedmultiset<Salesdata>SDset；
由于hash<Sales_data>使用Sales_data的私有成员，我们必须将它声明为
627
710

Page654
628
711
Sales_data的友元：
template<classT>classstd：：hash；//友元声明所需要的
classSalesdata{
friendclassstd：：hash<Salesdata>；
//其他成员定义，如前
}；
这段代码指出特殊实例hash<Sales_data>是Sales_data的友元。由于此实例定义
在std命名空间中，我们必须记得在friend声明中应使用std：：hash。
Note
第16章模板与泛型编程
Note
为了让Salesdata的用戶能使用hash的特例化版本，我们应该在
Salesdata的头文件中定义该特例化版本。
类模板部分特例化
与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一
部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化
（partialspecialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指
定的模板参数提供实参。
我们只能部分特例化类模板，而不能部分特例化函数模板。
在16。2。3节（第605页）中我们介绍了标准库remove_reference类型。该模板是
通过一系列的特例化版本来完成其功能的：
//原始的、最通用的版本
template<classT>structremove_reference{
typedefTtype；
}；
//部分特例化版本，将用于左值引用和右值引用
template<classT>structremove_reference<T&>//左值引用
{typedefTtype；}；
template<classT>structremove_reference<T&&>//右值引用
{typedefTtype；}；
第一个模板定义了最通用的模板。它可以用任意类型实例化；它将模板实参作为type成
员的类型。接下来的两个类是原始模板的部分特例化版本。
由于一个部分特例化版本本质是一个模板，与往常一样，我们首先定义模板参数。类
似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定
类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们
为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始
模板中的参数按位置对应。
部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例
化版本。在本例中，特例化版本的模板参数的数目与原始模板相同，但是类型不同。两个
特例化版本分别用于左值引用和右值引用类型：
inti；
//decltype（42）为int，使用原始模板
remove_reference<decltype（42）>：：typea；

Page655
16。5模板特例化
//decltype（i）为int&，使用第一个（T&）部分特例化版本
remove_reference<decltype（i）>：：type
b；
//decltype（std：：move（i））为int&&，使用第二个（即T&&）部分特例化版本
remove_reference<decltype（std：：move（i））>：：typec；
三个变量a、b和c均为int类型。
特例化成员而不是类
我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果Foo是一个模
板类，包含一个成员Bar，我们可以只特例化该成员：
template<typenameT>structFoo{
Foo（constT&t=T（））：mem（t）{}
voidBar（）{/*。。。*/}
}；
Tmem；
//Foo的其他成员
template<>
//我们正在特例化一个模板
voidFoo<int>：：Bar（）//我们正在特例化Foo<int>的成员Bar
{
//进行应用于int的特例化处理
}
本例中我们只特例化Foo<int>类的一个成员，其他成员将由Foo模板提供：
//实例化Foo<string>：：Foo（）
//实例化Foo<string>：：Bar（）
//实例化Foo<int>：：Foo（）
//使用我们特例化版本的Foo<int>：：Bar（）
Foo<string>fs；
fs。Bar（）；
Foo<int>fi；
fi。Bar（）；
当我们用int之外的任何类型使用Foo时，其成员像往常一样进行实例化。当我们用int
使用Foo时，Bar之外的成员像往常一样进行实例化。如果我们使用Foo<int>的成员
Bar，则会使用我们定义的特例化版本。
16。5节练习
练习16。62：定义你自己版本的hash<Salesdata>，并定义一个Salesdata对象
的unordered_multiset。将多条交易记录保存到容器中，并打印其内容。
练习16。63：定义一个函数模板，统计一个给定值在一个vector中出现的次数。测试
你的函数，分别传递给它一个double的vector，一个int的vector以及一个
string的vector。
练习16。64为上一题中的模板编写特例化版本来处理vector<constchar*>。编
写程序使用这个特例化版本。
练习16。65：在16。3节（第617页）中我们定义了两个重载的debug_rep版本，一个
接受constchar*参数，另一个接受char*参数。将这两个函数重写为特例化版本。
练习16。66：重载debug_rep函数与特例化它相比，有何优点和缺点?
练习16。67：定义特例化版本会影响debug_rep的函数匹配吗?如果不影响，为什么?
629
712

Page656
630
713
小结
模板是C++语言与众不同的特性，也是标准库的基础。一个模板就是一个编译器用来
生成特定类类型或函数的蓝图。生成特定类或函数的过程称为实例化。我们只编写一次模
板，就可以将其用于多种类型和值，编译器会为每种类型和值进行模板实例化。
我们既可以定义函数模板，也可以定义类模板。标准库算法都是函数模板，标准库容
器都是类模板。
显式模板实参允许我们固定一个或多个模板参数的类型或值。对于指定了显式模板实
参的模板参数，可以应用正常的类型转换。
一个模板特例化就是一个用户提供的模板实例，它将一个或多个模板参数绑定到特定
类型或值上。当我们不能（或不希望）将模板定义用于某些特定类型时，特例化非常有用。
第16章模板与泛型编程
最新C++标准的一个主要部分是可变参数模板。一个可变参数模板可以接受数目和类
型可变的参数。可变参数模板允许我们编写像容器的emplace成员和标准库
makeshared函数这样的函数，实现将实参传递给对象的构造函数。
术语表
类模板（classtemplate）模板定义，可
从它实例化出特定的类。类模板的定义以
关键字template开始，后跟尖括号对<
和>，其内为一个用逗号分隔的一个或多个
模板参数的列表，随后是类的定义。
默认模板实参（defaulttemplateargument）
一个类型或一个值，当用户未提供对应模
板实参时，模板会使用它。
显式模板实参（explicittemplateargument）
在一个函数调用中或定义模板类类型时，
由用户提供的模板实参。显式模板实参在
紧跟在模板名的尖括号对中给出。
显式实例化（explicitinstantiation）
的类或函数。
声明，为所有模板参数提供了显式实参。714实例（instantiation）编译器从模板生成
用来指导实例化过程。如果声明是extern
的，模板将不会被实例化；否则，模板将
利用指定的实参进行实例化。对每个
extern模板声明，在程序中某处必须有
一个extern的显式实例化。
函数参数包（functionparameterpack）表
示零个或多个函数参数的参数包。
函数模板（functiontemplate）模板定义，
可从它实例化出特定函数。函数模板的定
义以关键字template开始，后跟尖括号
对<和>，其内为一个用逗号分隔的一个或
多个模板参数的列表，随后是函数的定义。
实例化（instantiate）编译器处理过程，
用实际的模板实参来生成模板的一个特殊
实例，其中参数被替换为对应的实参。当
函数模板被调用时，会自动根据传递给它
的实参来实例化。而使用类模板时，则需
要我们提供显式模板实参。
成员模板（membertemplate）本身是模
板的成员函数。成员模板不能是虚函数。
非类型参数（nontypeparameter）表示
值的模板参数。非类型模板参数的实参必
须是常量表达式。
包扩展（packexpansion）处理过程，将
一个参数包替换为其中元素的列表。
参数包（parameterpack）表示零个或多
个参数的模板或函数参数。
部分特例化（partialspecialization）类模
板的一个版本，其中指定了某些但不是所

Page657
术语表
有模板参数，或是一个或多个参数的属性
未被完全指定。
模式（pattern）定义了扩展后参数包中每
个元素的形式。
模板实参（templateargument）用来实
例化模板参数的类型或值。
模板实参推断（templateargument
deduction）编译器确定实例化哪个函数
模板的过程。编译器检查那些使用模板参
数的实参的类型，将这些类型或值绑定到
模板参数，来自动实例化一个函数版本。
模板参数（templateparameter）在模板
参数列表中指定的名字，可在模板定义内
部使用。模板参数可以是类型参数，也可
以是非类型参数。为了使用一个类模板，
我们必须为每个模板参数提供显式实参。
编译器使用这些类型或值实例化出一个类
版本，其中所有用到模板参数的地方都被
替换为实际的实参。当使用一个函数模板
时，编译器使用调用中的函数实参推断模
板实参，并使用推断出的模板实参实例化
出一个特定的函数。
模板参数列表（templateparameterlist）
用逗号分隔的参数列表，用于模板的定义
或声明中。每个参数可以是一个类型参数，
也可以是一个非类型参数。
模板参数包（templateparameterpack）
表示零个或多个模板参数的参数包。
模板特例化（templatespecialization）类
模板、类模板的成员或函数模板的重定义，
其中指定了某些（或全部）模板参数。模
板特例化版本必须出现在原模板的声明之
后，必须出现在任何利用特殊实参来使用
模板的代码之前。一个函数模板中的每个
模板参数都必须完全特例化。
类型参数（typeparameter）模板参数列
表中的名字，用来表示类型。类型参数在
关键字typename或class之后指定。
类型转换（typetransformation）由标准
库定义的类模板，可将给定的模板类型参
数转换为一个相关类型。
可变参数模板（variadictemplate）接受
可变数目模板实参的模板。模板参数包用
省略号指定（如class。。。、typename。。。或
type-name。。。）
631

Page658


Page659
第IV部分
高级主题
内容
第17章
第18章
第19章
标准库特殊设施，
用于大型程序的工具，
特殊工具与技术。。。
635
683
725
第IV部分将介绍C++和标准库的一些附加特性，虽然这些特性在特定的情况下很有
用，但并非每个C++程序员都需要它们。这些特性分为两类：一类对于求解大规模的问题
很有用；另一类适用于特殊问题而非通用问题。针对特殊问题的特性既有属于C++语言的
（将在第19章介绍），也有属于标准库的（将在第17章进行介绍）。
在第17章中我们介绍四个具有特殊目的的标准库设施：bitset类和三个新标准库
设施（tuple、正则表达式和随机数）。我们还将介绍IO库中某些不常用的部分。
第18章介绍异常处理、命名空间和多重继承。这些特性在设计大序时是最有用的。
即使是一个程序员就能编写的足够简单的程序，也能从异常处理机制受益，这也是为
什么我们在第5章介绍了异常处理的基本知识的原因。但是，对于需要大型团队才能完成
的程序设计问题，运行时错误处理才显得更为重要也更难于管理。在第18章中，我们会
额外介绍一些有用的异常处理设施。我们还将详细讨论异常是如何处理的，并展示如何定
义和使用自己的异常类。这一章还会介绍新标准中异常处理方面的改进-如何指出一个
特定函数不会抛出异常。
大型应用程序通常会使用来自多个提供商的代码。如果提供商不得不将他们定义的名
字放置在单一的命名空间中，那么将多个独立开发的库组合起来是很困难的（如果能组合
的话）。独立开发的库几乎必然会使用与其他库相同的名字；对于某个库中定义的名字，
如果另一个库中使用了相同的名字，就会引起冲突。为了避免名字冲突，我们可以在一个
namespace中定义名字。
715
716

Page660
634
第IV部分高级主题
无论何时我们使用一个来自标准库的名字，实际上都是在使用名为std的命名空间
中的名字。第18章将会展示如何定义我们自己的命名空间。
第18章最后介绍一个很重要但不太常用的语言特性：多重继承。多重继承对非常复
杂的继承层次很有用。
第19章介绍几种用于特定类别问题的特殊工具和技术，包括如何重定义内存分配机
制；C++对运行时类型识别（run-timetypeidentification，RTTI）的支持——允许我们在运
行时才确定一个表达式的实际类型；以及如何定义和使用指向类成员的指针。类成员指针
不同于普通数据或函数指针。普通指针仅根据对象或函数的类型而变化，而类成员指针还
必须反映成员所属的类。我们还将介绍三种附加的聚合类型：联合、嵌套类和局部类。这
一章最后将简要介绍一组本质上不可移植的语言特性：volatile修饰符、位域以及链接
指令。

Page661
第17章
标准库特殊设施
内容
17。1tuple类型
17。2bitset类型
17。3正则表达式。
17。4随机数
17。5IO库再探。
小结
术语表。
636
640
645
659
666
680
680
最新的C++标准极大地扩充了标准库的规模和范围。实际上，从1998年的第一版标
准到2011年的最新标准，标准库部分的篇幅增加了两倍以上。因此，介绍所有C++标准
库类的知识大大超出了本书范围。但是，有4个标准库设施，虽然它们比我们已经介绍的
其他标准库设施更特殊，但也足够通用，应该放在一本入门书籍中进行介绍。这4个标准
库设施是：tuple、bitset、随机数生成及正则表达式。此外，我们还将介绍IO库中一
些具有特殊目的的部分。
717

Page662
636
718
C++
11
标准库占据了新标准文本将近三分之二的篇幅。虽然我们不能详细介绍所有标准库设
施，但仍有一些标准库设施在很多应用中都是有用的：tuple、bitset、正则表达式以
及随机数。我们还将介绍一些附加的IO库功能：格式控制、未格式化IO和随机访问。
17。1tuple类型
tuple是类似pair（参见11。2。3节，第379页）的模板。每个pair的成员类型都
不相同，但每个pair都恰好有两个成员。不同tuple类型的成员类型也不相同，但一
个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个
tuple类型的成员数目可以与另一个tuple类型不同。
当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示
这些数据时，tuple是非常有用的。表17。1列出了tuple支持的操作。tuple类型及其
伴随类型和函数都定义在tuple头文件中。
tuple<T1，T2，
tuple<T1，T2，。。。，Tn>t（v1，
v2，
vn）；
make_tuple（v1，v2，
t1==t2
t1!=t2
t1relopt2
get<i>（t）
Tn>t；
tuple_element<i，
tupleType>：：type
第17章标准库特殊设施
tuple_size<tupleType>：：value
Note
vn）
表17。1：tuple支持的操作
t是一个tuple，成员数为n，第i个成员的类型为Ti。
所有成员都进行值初始化（参见3。3。1节，第88页）
t是一个tuple，成员类型为T1。Tn，每个成员用对应的
初始值v进行初始化。此构造函数是explicit的（参
见7。5。4节，第265页）
返回一个用给定初始值初始化的tuple。tuple的类型
从初始值的类型推断
当两个tuple具有相同数量的成员且成员对应相等时，
两个tuple相等。这两个操作使用成员的==运算符来完
成。一旦发现某对成员不等，接下来的成员就不用比较了
tuple的关系运算使用字典序（参见9。2。7节，第304页）。
两个tuple必须具有相同数量的成员。使用<运算符比较
t1的成员和t2中的对应成员
返回t的第i个数据成员的引用；如果t是一个左值，结
果是一个左值引用；否则，结果是一个右值引用。tuple
的所有成员都是public的
一个类模板，可以通过一个tuple类型来初始化。它有
一个名为value的publicconstexprstatic数据
成员，类型为size_t，表示给定tuple类型中成员的数
量
一个类模板，可以通过一个整型常量和一个tuple类型
来初始化。它有一个名为type的public成员，表示给
定tuple类型中指定成员的类型
我们可以将tuple看作一个“快速而随意”的数据结构。

Page663
17。1tuple类型
17。1。1定义和初始化tuple
当我们定义一个tuple时，需要指出每个成员的类型：
tuple<size_t，size_t，size_t>threeD；//三个成员都设置为0
tuple<string，vector<double>，int，list<int>>
someVal（"constants"，{3。14，2。718}，42，{0，1，2，3，4，5}）
当我们创建一个tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行
值初始化（参见3。3。1节，第88页）；也可以像本例中初始化someVal一样，为每个成员
提供一个初始值。tuple的这个构造函数是explicit的（参见7。5。4节，第265页），
因此我们必须使用直接初始化语法：
tuple<size_t，size_t，size_t>threed={1，2，3）；//错误
tuple<size_t，size_t，size_t>threeD{1，2，3}；
//正确
类似make_pair函数（参见11。2。3节，第381页），标准库定义了make_tuple函
数，我们还可以用它来生成tuple对象：
//表示书店交易记录的tuple，包含：ISBN、数量和每册书的价格
autoitem=make_tuple（"0-999-78345-X"，3，20。00）；
类似make_pair，make_tuple函数使用初始值的类型来推断tuple的类型。在本例
中，item是一个tuple，类型为tuple<constchar*，int，double>。
访问tuple的成员
一个pair总是有两个成员，这样，标准库就可以为它们命名（如，first和second）。
但这种命名方式对tuple是不可能的，因为一个tuple类型的成员数目是没有限制的。
因此，tuple的成员都是未命名的。要访问一个tuple的成员，就要使用一个名为get
的标准库函数模板。为了使用get，我们必须指定一个显式模板实参（参见16。2。2节，第
603页），它指出我们想要访问第几个成员。我们传递给get一个tuple对象，它返回指
定成员的引用：
autobook=get<0>（item）；
autocnt=get<1>（item）；
autoprice=get<2>（item）/cnt；
get<2>（item）*=0。8；
//返回item的第一个成员
//返回item的第二个成员
//返回item的最后一个成员
//T20%
尖括号中的值必须是一个整型常量表达式（参见2。4。4节，第58页）。与往常一样，我们
从0开始计数，意味着get<0>是第一个成员。
如果不知道一个tuple准确的类型细节信息，可以用两个辅助类模板来查询tuple
成员的数量和类型：
typedefdecltype（item）trans；//trans是item的类型
//返回trans类型对象中成员的数量
size_tsz=tuple_size<trans>：：value；//返回3
//cnt的类型与item中第二个成员相同
tuple_element<1，trans>：：typecnt=get<1>（item）；//cnt是一个int
为了使用tuple_size或tuple_element，我们需要知道一个tuple对象的类型。与
往常一样，确定一个对象的类型的最简单方法就是使用decltype（参见2。5。3节，第62
页）。在本例中，我们使用decltype来为item类型定义一个类型别名，用它来实例化
637
719
720

Page664
638
721
两个模板。
tuple_size有一个名为value的publicstatic数据成员，它表示给定tuple
中成员的数量。tuple_element模板除了一个tuple类型外，还接受一个索引值。它
有一个名为type的public类型成员，表示给定tuple类型中指定成员的类型。类似
get，tuple_element所使用的索引也是从0开始计数的。
关系和相等运算符
tuple的关系和相等运算符的行为类似容器的对应操作（参见9。2。7节，第304页）。
这些运算符逐对比较左侧tuple和右侧tuple的成员。只有两个tuple具有相同数量
的成员时，我们才可以比较它们。而且，为了使用tuple的相等或不等运算符，对每对
成员使用==运算符必须都是合法的；为了使用关系运算符，对每对成员使用<必须都是合
法的。例如：
tuple<string，string>duo（"1"，"2"）；
tuple<size_t，size_t>twod（1，2）；
boolb=（duo==twoD）；//错误：不能比较size_t和string
第17章标准库特殊设施
tuple<size_t，size_t，size_t>threed（1，2，3）；
b=（twoD<threeD）；
//错误：成员数量不同
tuple<size_t，size_t>origin（0，0）；
b=（origin<two）；
Note
//正确：b为true
由于tuple定义了<和==运算符，我们可以将tuple序列传递给算法，并且
可以在无序容器中将tuple作为关键字类型。
17。1。1节练习
练习17。1：定义一个保存三个int值的tuple，并将其成员分别初始化为10、20和
30。
练习17。2：定义一个tuple，保存一个string、一个vector<string>和一个
pair<string，int>。
练习17。3：重写12。3节（第430页）中的TextQuery程序，使用tuple代替
QueryResult类。你认为哪种设计更好?为什么?
17。1。2使用tuple返回多个值
tuple的一个常见用途是从一个函数返回多个值。例如，我们的书店可能是多家连锁
书店中的一家。每家书店都有一个销售记录文件，保存每本书近期的销售数据。我们可能
希望在所有书店中查询某本书的销售情况。
假定每家书店都有一个销售记录文件。每个文件都将每本书的所有销售记录存放在一
起。进一步假定已有一个函数可以读取这些销售记录文件，为每个书店创建一个
vectorales_data>，并将这些vector保存在vector的vector中：
//files中的每个元素保存一家书店的销售记录
vector<vector<Salesdata>>files；
我们将编写一个函数，对于一本给定的书，在files中搜索出售过这本书的书店。对每
家有匹配销售记录的书店，我们将创建一个tuple来保存这家书店的索引和两个迭代器。

Page665
17。1tuple类型
索引指出了书店在files中的位置，而两个迭代器则标记了给定书籍在此书店的
vector<Sales_data>中第一条销售记录和最后一条销售记录之后的位置。
返回tuple的函数
我们首先编写查找给定书籍的函数。此函数的参数是刚刚提到的vector的vector
以及一个表示书籍ISBN的string。我们的函数将返回一个tuple的vector，凡是销
售了给定书籍的书店，都在vector中有对应的一项：
//matches有三个成员：一家书店的索引和两个指向书店vector中元素的迭代器
typedeftuple<vector<Sales_data>：：size_type，
//files保存每家书店的销售记录
//findBook返回一个vector，每家销售了给定书籍的书店在其中都有一项
vector<matches>
vector<Sales_data>：：const_iterator，
vector<Salesdata>：：constiterator>matches；
findBook（constvector<vector<Sales_data>>&files，
conststring&book）
{
vector<matches>ret；//初始化为空vector
//对每家书店，查找与给定书籍匹配的记录范围（如果存在的话）
for（autoit=files。cbegin（）；it!=files。cend（）；++it）{
//查找具有相同ISBN的Sales_data范围
autofound=equal_range（it->cbegin（），it->cend（），
book，compareIsbn）；
if（found。first!=found。second）//此书店销售了给定书籍
//记住此书店的索引及匹配的范围
ret。push_back（make_tuple（it-files。cbegin（），
{
found。first，found。second））；
}
returnret；//如果未找到匹配记录的话，ret为空
}
for循环遍历files中的元素，每个元素都是一个vector。在for循环内，我们调用
了一个名为equal_range的标准库算法，它的功能与关联容器的同名成员类似（参见
11。3。5节，第390页）。equal_range的前两个实参是表示输入序列的迭代器（参见10。1
节，第336页），第三个参数是一个值。默认情况下，equal_range使用<运算符来比较
元素。由于Sales_data没有<运算符，因此我们传递给它一个指向compareIsbn函数
的指针（参见11。2。2节，第379页）。
equal_range算法返回一个迭代器pair，表示元素的范围。如果未找到book，则
两个迭代器相等，表示空范围。否则，返回的pair的first成员将表示第一条匹配的
记录，second则表示匹配的尾后位置。
使用函数返回的tuple
一旦我们创建了vector保存包含匹配的销售记录的书店，就需要处理这些记录了。
在此程序中，对每家包含匹配销售记录的书店，我们将打印其汇总销售信息：
voidreportResults（istream&in，ostream&os，
constvector<vector<Salesdata>>&files）
strings；//要查找的书
639
722

Page666
640
723
while（in>>s）{
autotrans
}
}
for
findBook（files，s）；//销售了这本书的书店
if（trans。empty（））{
cout<<s<<"notfoundinanystores"<<endl；
continue；//获得下一本要查找的书
第17章标准库特殊设施
（constauto&store：trans）//对每家销售了给定书籍的书店
//get<n>返回store中tuple的指定的成员
os<<"store"<<get<0>（store）<<"sales：
<<accumulate（get<1>（store），get<2>（store），
<<endl；
Sales_data（s））
11
}
while循环反复读取名为in的istream来获得下一本要处理的书｡我们调用findBook
来检查s是否存在，并将结果赋予trans。我们使用auto来简化trans类型的代码编
写，它是一个tuple的vector。
如果trans为空，表示没有关于s的销售记录。在此情况下，我们打印一条信息并
返回，执行下一步while循环来获取下一本要查找的书。
for循环将store绑定到trans中的每个元素。由于不希望改变trans中的元素，
我们将store声明为const的引用。我们使用get来打印相关数据：get<0>表示对应
书店的索引、get<1>表示第一条交易记录的迭代器、get<2>表示尾后位置的迭代器。
由于Salesdata定义了加法运算符（参见14。3节，第497页），因此我们可以用标
准库的accumulate算法（参见10。2。1节，第338页）来累加销售记录。我们用
Sales_data的接受一个string参数的构造函数（参见7。1。4节，第236页）来初始化
一个Sales_data对象，将此对象传递给accumulate作为求和的起点。此构造函数用
给定的string初始化bookNo，并将units_sold和revenue成员置为0。
17。1。2节练习
练习17。4：编写并测试你自己版本的findBook函数。
练习17。5：重写findBook，令其返回一个pair，包含一个索引和一个迭代器pair。
练习17。6：重写findBook，不使用tuple或pair。
练习17。7：解释你更倾向于哪个版本的findBook，为什么。
练习17。8：在本节最后一段代码中，如果我们将Salesdata（）作为第三个参数传递
给accumulate，会发生什么?
17。2bitset类型
在4。8节（第135页）中我们介绍了将整型运算对象当作二进制位集合处理的一些内
置运算符。标准库还定义了bitset类，使得位运算的使用更为容易，并且能够处理超过
最长整型类型大小的位集合。bitset类定义在头文件bitset中。

Page667
17。2bitset类型
17。2。1定义和初始化bitset
表17。2列出了bitset的构造函数。bitset类是一个类模板，它类似array类，
具有固定的大小（参见9。2。4节，第301页）。当我们定义一个bitset时，需要声明它包
含多少个二进制位：
bitset<32>bitvec（10）；//32位；低位为1，其他位为0
大小必须是一个常量表达式（参见2。4。4节，第58页）。这条语句定义bitvec为一个包
含32位的bitset。就像vector包含未命名的元素一样，bitset中的二进制位也是
未命名的，我们通过位置来访问它们。二进制位的位置是从0开始编号的。因此，bitvec
包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），
编号到31结束的二进制位被称为高位（high-order）。
bitset<n>b；
bitset<n>b（u）；
bitset<n>b（s，pos，
m，zero，one）；
bitset<n>b（cp，pos，
m，zero，one）；
表17。2：初始化bitset的方法
b有n位；每一位均为0。此构造函数是一个constexpr（参
见7。5。6节，第267页）
b是unsignedlonglong值u的低n位的拷贝。如果n大
于unsignedlonglong的大小，则b中超出unsignedlong
long的高位被置为0。此构造函数是一个constexpr（参见
7。5。6节，第267页）
b是strings从位置pos开始m个字符的拷贝。s只能包含
字符zero或one；如果s包含任何其他字符，构造函数会抛出
invalid_argument异常。字符在b中分别保存为zero和
one。pos默认为0，m默认为string：：npos，zero默认
为'0'，one默认为'1′
与上一个构造函数相同，但从cp指向的字符数组中拷贝字符。
如果未提供m，则cp必须指向一个C风格字符串。如果提供了
m，则从cp开始必须至少有m个zero或one字符
接受一个string或一个字符指针的构造函数是explicit的（参见7。5。4节，第265页）。在新
标准中增加了为0和1指定其他字符的功能。
unsigned
bitset
当我们使用一个整型值来初始化bitset时，此值将被转换为unsignedlonglong
类型并被当作位模式来处理｡bitset中的二进制位将是此模式的一个副本。如果bitset
的大小大于一个unsignedlonglong中的二进制位数，则剩余的高位被置为0。如果
bitset的大小小于一个unsignedlonglong中的二进制位数，则只使用给定值中的
低位，超出bitset大小的高位被丢弃：
//bitvec1比初始值小；初始值中的高位被丢弃
bitset<13>bitvec1（0xbeef）；//二进制位序列为1111011101111
//bitvec2比初始值大；它的高位被置为0
bitset<20>it
（0xbeef）；//二进制位序列为00001011111011101111
//在64位机器中，longlongOULL是64个0比特，因此~OULL是64个1
bitset<128>bitvec3（~0ULL）；//0~63位为1；63~127位为0
641
724

Page668
642
725
从一个string初始化bitset
我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符
都直接表示位模式。与往常一样，当我们使用字符串表示数时，字符串中下标最小的字符
对应高位，反之亦然：
bitset<=2>bitvec4（"1100"）；//2、3两位为1，剩余两位为0
如果string包含的字符数比bitset少，则bitset的高位被置为0。
Note
string的下标编号习惯与bitset恰好相反：string中下标最大的字符（最
右字符）用来初始化bitset中的低位（下标为0的二进制位）。当你用一个
string初始化一个bitset时，要记住这个差别。
我们不必使用整个string来作为bitset的初始值，可以只用一个子串作为初始值：
stringstr（"1111111000000011001101"）；
bitset<=2>bitvec5（str，5，4）；//从str[5]开始的四个二进制位，1100
bitset<32>bitvec6（str，str。size（）-4）；//使用最后四个字符
此处，bitvec5用str中从str[5]开始的长度为4的子串进行初始化。与往常一样，
子串的最右字符表示最低位。因此，bitvec5中第3位到第0位被设置为1100，剩余
位被设置为0｡传递给bitvec6的初始值是一个string和一个开始位置，因此bitvec6
用str中倒数第四个字符开始的子串进行初始化。bitvec6中剩余二进制位被初始化为
0。下图说明了这两个初始化过程
从str拷贝的元素
str
111111100000
str[5]
str
（首元素）
↑
str[5+4]
（尾后位置）
从str拷贝的元素
第17章标准库特殊设施
1001101
十
str。size（）-4
bitvec5
bitvec6
00000001100
t
bitvec5[4]
10101
用str初始化
17。2。1节练习
练习17。9：解释下列每个bitset对象所包含的位模式：
（a）bitset<64>bitvec（32）；
（b）bitset<32>bv（1010101）；
（c）stringbstr；cin>>bstr；bitset<8>bv（bstr）；
bitvec5[0]
用str初始化
0001101
bitvec6[4]
bitvec6[0]

Page669
17。2bitset类型
17。2。2bitset操作
bitset操作（参见表17。3）定义了多种检测或设置一个或多个二进制位的方法。
bitset类还支持我们在4。8节（第136页）中介绍过的位运算符｡这些运算符用于bitset
对象的含义与内置运算符用于unsigned运算对象相同。
b。any（）
b。all（）
b。none（）
b。count（）
b。size（）
b。test（pos）
b。set（pos，v）
b。set（）
b。reset（pos）
b。reset（）
b。flip（pos）
b。flip（）
b[pos]
b。to_ulong（）
b。to_ullong（）
b。to_string（zero，
one）
os<<b
is>>b
表17。3：bitset操作
b中是否存在置位的二进制位
b中所有位都置位了吗
b中不存在置位的二进制位吗
b中置位的位数
一个constexpr函数（参见2。4。4节，第58页），返回b中
的位数
若pos位置的位是置位的，则返回true，否则返回false
将位置pos处的位设置为bool值v。v默认为true。如果
未传递实参，则将b中所有位置位
将位置pos处的位复位或将b中所有位复位
改变位置pos处的位的状态或改变b中每一位的状态
访问b中位置pos处的位；如果b是const的，则当该位置
位时b[pos]返回一个bool值true，否则返回false
返回一个unsignedlong或一个unsignedlonglong值，
其位模式与b相同｡如果b中位模式不能放入指定的结果类型，
则抛出一个overflowerror异常
返回一个string，表示b中的位模式。zero和one的默认
值分别为0和1，用来表示b中的0和1
将b中二进制位打印为字符1或0，打印到流os
从is读取字符存入b。当下一个字符不是1或0时，或是已
经读入b。size（）个位时，读取过程停止
count、size、all、any和none等几个操作都不接受参数，返回整个bitset
的状态。其他操作--set、reset和flip则改变bitset的状态。改变bitset状态
的成员函数都是重载的。对每个函数，不接受参数的版本对整个集合执行给定的操作；接
受一个位置参数的版本则对指定位执行操作：
bitset<32>bitvec（1U）；
boolis_setbitvec。any（）；
boolis_not_set=bitvec。none（）；
boolallset
bitvec。all（）；
sizetonBits=bitvec。count（）；
sizetsz=bitvec。size（）；
//32位；低位为1，剩余位为0
//true，因为有1位置位
//false，因为有1位置位了
//false，因为只有1位置位
//返回1
//返回32
bitvec。flip（）；//翻转bitvec中的所有位
bitvec。reset（）；//将所有位复位
bitvec。set（）；
//将所有位置位
当bitset对象的一个或多个位置位（即，等于1）时，操作any返回true。相反，当
所有位复位时，none返回true。新标准引入了all操作，当所有位置位时返回true。
643
726
C++
11

Page670
644
727
728
操作count和size返回size_t类型的值（参见3。5。2节，第103页），分别表示对象
中置位的位数或总位数。函数size是一个constexpr函数，因此可以用在要求常量表
达式的地方（参见2。4。4节，第58页）。
成员flip、set、reset及test允许我们读写指定位置的位：
bitvec。flip（0）；
//翻转第一位
bitvec。set（bitvec。size（）-1）；//置位最后一位
bitvec。set（0，0）；//复位第一位
bitvec。reset（i）；
bitvec。test（0）；
//复位第i位
//返回false，因为第一位是复位的
下标运算符对const属性进行了重载。const版本的下标运算符在指定位置位时返
回true，否则返回false。非const版本返回bitset定义的一个特殊类型，它允许
我们操纵指定位的值：
bitvec[0]=0；
bitvec[31]=bitvec[0]；
bitvec[0]。flip（）；
~bitvec[0]；
boolb=bitvec[0]；
第17章标准库特殊设施
unsignedlongulong=
cout<<"ulong
Note
提取bitset的值
to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式。
只有当bitset的大小小于等于对应的大小（to_ulong为unsignedlong，to_ullong
为unsignedlonglong）时，我们才能使用这两个操作：
//将第一位复位
//将最后一位设置为与第一位一样
//翻转第一位
//等价操作，也是翻转第一位
//将bitvec[0]的值转换为bool类型
bitvec3。to_ulong（）；
<<ulong<<endl；
如果bitset中的值不能放入给定类型中，则这两个操作会抛出一个
overflowerror异常（参见5。6节，第173页）。
bitset的IO运算符
输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的
字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输
入错误时，读取过程才停止。随即用临时string对象来初始化bitset（参见17。2。1节，
第642页）。如果读取的字符数小于bitset的大小，则与往常一样，高位将被置为0。
输出运算符打印一个bitset对象中的位模式：
bitset<16>bits；
cin>>bits；//从cin读取最多16个0或1
cout<<"bits：<<bits<<endl；//打印刚刚读取的內容
boolstatus；
//使用位运算符的版本
unsignedlongquizA=0；
1bitset
为了说明如何使用biset，我们重新实现4。8节（第137页）中的评分程序，用bitset
代替unsignedlong表示30个学生的测验结果——“通过/失败”：
//此值被当作位集合使用

Page671
17。3正则表达式
quiza|=1UL<<27；
status=quiz&（1UL<<27）；
quizh&=~（1UL<<27）；
//使用标准库类bitset完成等价的工作
bitset<30>quizB；
quizB。set（27）；
status=quiz[27]；
quizB。reset（27）；
17。2。2节练习
练习17。10：使用序列1、2、3、5、8、13、21初始化一个bitset，将这些位置置位。
对另一个bitset进行默认初始化，并编写一小段程序将其恰当的位置位。
练习17。11：定义一个数据结构，包含一个整型对象，记录一个包含10个问题的真/假
测验的解答｡如果测验包含100道题，你需要对数据结构做出什么改变（如果需要的话）?
练习17。12：使用前一题中的数据结构，编写一个函数，它接受一个问题编号和一个表
示真/假解答的值，函数根据这两个参数更新测验的解答。
//指出第27个学生通过了测验
//检查第27个学生是否通过了测验
//第27个学生未通过测验
练习17。13：编写一个整型对象，包含真/假测验的正确答案。使用它来为前两题中的数
据结构生成测验成绩。
regex
//每个学生分配一位，所有位都被初始化为0
//指出第27个学生通过了测验
//检查第27个学生是否通过了测验
//第27个学生未通过测验
17。3正则表达式
正则表达式（regularexpression）是一种描述字符序列的方法，是一种极其强大的计
算工具。但是，用于定义正则表达式的描述语言已经大大超出了本书的范围。因此，我们
重点介绍如何使用C++正则表达式库（RE库），它是新标准库的一部分。RE库定义在头
文件regex中，它包含多个组件，列于表17。4中。
regex_match
regex_search。
regex_replace
sregexiterator
smatch
ssubmatch
Tip
表17。4：正则表达式库组件
表示有一个正则表达式的类
将一个字符序列与一个正则表达式匹配
寻找第一个与正则表达式匹配的子序列
使用给定格式替换一个正则表达式
迭代器适配器，调用regex_search来遍历一个string中所有匹
配的子串
容器类，保存在string中搜索的结果
string中匹配的子表达式的结果
如果你还不熟悉正则表达式的使用，你应该浏览这一节，以获得正则表达式可
以做什么的一些概念。
regex类表示一个正则表达式。除了初始化和赋值之外，
作。表17。6（第647页）列出了regex支持的操作。
函数regex_match和regex_search确定一个给定字符序列与一个给定regex
regex还支持其他一些操
645
C++
11
729

Page672
646
730
是否匹配。如果整个输入序列与表达式匹配，则regex_match函数返回true；如果输
入序列中一个子串与表达式匹配，则regex_search函数返回true。还有一个
regex_replace函数，我们将在17。3。4节（第657页）中介绍。
表17。5列出了regex的函数的参数。这些函数都返回bool值，且都被重载了：其
中一个版本接受一个类型为smatch的附加参数。如果匹配成功，这些函数将成功匹配的
相关信息保存在给定的smatch对象中。
第17章标准库特殊设施
表17。5：regex_search和regex_match的参数
注意：这些操作返回bool值，指出是否找到匹配。
（seq，m，r，mft）
（seq，r，mft）
在字符序列seq中查找regex对象r中的正则表达式｡seq可以是一
个string、表示范围的一对迭代器以及一个指向空字符结尾的字符
数组的指针
m是一个match对象，用来保存匹配结果的相关细节。m和seq必须
具有兼容的类型（参见17。3。1节，第649页）
mft是一个可选的regex_constants：：match_flag_type值。
表17。13（第659页）描述了这些值，它们会影响匹配过程
17。3。1使用正则表达式库
我们从一个非常简单的例子开始——查找违反众所周知的拼写规则“i除非在c之后，
否则必须在e之前”的单词：
//查找不在字符c之后的字符串ei
stringpattern（"[^c]ei"）；
//我们需要包含pattern的整个单词
pattern="[[：alpha：]]*"+pattern+"[[：alpha：]]*"；
//构造一个用于查找模式的regex
//定义一个对象保存搜索结果
regexr（pattern）；
smatchresults；
//定义一个string保存与模式匹配和不匹配的文本
stringtest_str="receiptfreindtheifreceive"；
//用r在test_str中查找与pattern匹配的子串
if（regex_search（test_str，results，r））
cout<<results。str（）<<endl；
//如果有匹配子串
//打印匹配的单词
我们首先定义了一个string来保存希望查找的正则表达式。正则表达式[^c]表明我们
希望匹配任意不是'c'的字符，而[^clei指出我们想要匹配这种字符后接ei的字符串。
此模式描述的字符串恰好包含三个字符。我们想要包含此模式的单词的完整内容。为了与
整个单词匹配，我们还需要一个正则表达式与这个三字母模式之前和之后的字母匹配。
这个正则表达式包含零个或多个字母后接我们的三字母的模式，然后再接零个或多个
额外的字母。默认情况下，regex使用的正则表达式语言是ECMAScript。在ECMAScript
中，模式[[：：alpha：]]匹配任意字母，符号+和*分别表示我们希望“一个或多个”或
“零个或多个”匹配。因此[[：：alpha：]]*将匹配零个或多个字母。
将正则表达式存入pattern后，我们用它来初始化一个名为r的regex对象。接
下来我们定义了一个string，用来测试正则表达式。我们将test_str初始化为与模式
匹配的单词（如"freind"和"thief"）和不匹配的单词（如"recepit"和"receive"）。
我们还定义了一个名为results的smatch对象，它将被传递给regex_search。如果
找到匹配子串，results将会保存匹配位置的细节信息。

Page673
17。3正则表达式
接下来我们调用了regex_search。如果它找到匹配子串，就返回true。我们用
results的str成员来打印test_str中与模式匹配的部分。函数regex_search在
输入序列中只要找到一个匹配子串就会停止查找。因此，程序的输出将是
freind
17。3。2节（第650页）将会介绍如何查找输入序列中所有的匹配子串。
指定regex对象的选项
当我们定义一个regex或是对一个regex调用assign为其赋予新值时，可以指定
一些标志来影响regex如何操作。这些标志控制regex对象的处理过程。表17。6列出的
最后6个标志指出编写正则表达式所用的语言。对这6个标志，我们必须设置其中之一，
且只能设置一个。默认情况下，ECMAScript标志被设置，从而regex会使用ECMA-262
规范，这也是很多Web浏览器所使用的正则表达式语言。
regexr（re）
regexr（re，f）
r1=re
rl。assign（re，f）
optimize
ECMAScript
表17。6：regex（和wregex）选项
re表示一个正则表达式，它可以是一个string、一个表示字符
范围的迭代器对、一个指向空字符结尾的字符数组的指针、一个
字符指针和一个计数器或是一个花括号包围的字符列表。f是指
出对象如何处理的标志。f通过下面列出的值来设置。如果未指
定f，其默认值为ECMAScript
r。mark_count（）
r。flags（）
注：构造函数和赋值操作可能拋出类型为regex_error的异常。
定义regex时指定的标志
basic
extended
将r1中的正则表达式替换为re。re表示一个正则表达式，它可
以是另一个regex对象、一个string、一个指向空字符结尾的
字符数组的指针或是一个花括号包围的字符列表
定义在regex和regex_constants：：syntax_option_type中
icase
在匹配过程中忽略大小写
nosubs
不保存匹配的子表达式
执行速度优先于构造速度
使用ECMA-262指定的语法
使用POSIX基本的正则表达式语法
使用POSIX扩展的正则表达式语法
使用POSIX版本的awk语言的语法
使用POSIX版本的grep的语法
使用POSIX版本的egrep的语法
awk
grep
egrep
与使用赋值运算符（=）效果相同；可选的标志f也与regex的
构造函数中对应的参数含义相同
r中子表达式的数目（我们将在17。3。3节（第654页）中介绍）
返回r的标志集
其他3个标志允许我们指定正则表达式处理过程中与语言无关的方面。例如，我们可
以指出希望正则表达式大小写无关的方式进行匹配。
647
作为一个例子，我们可以用icase标志查找具有特定扩展名的文件名。大多数操作
系统都是按大小写无关的方式来识别扩展名的——可以将一个C++程序保存在。cc结尾的
文件中，也可以保存在。cc、。cc或是。CC结尾的文件中，效果是一样的。如下所示，我731

Page674
648
732
们可以编写一个正则表达式来识别上述任何一种扩展名以及其他普通文件扩展名：
//一个或多个字母或数字字符后接一个'。'再接"cpp"或"cxx"或"cc"
regexr（"[[：alnum：]]+\\。（cpp|cxx|cc）$"，regex：：icase）；
smatchresults；
stringfilename；
while（cin>>filename）
第17章标准库特殊设施
if（regex_search（filename，results，r））
cout<<results。str（）<<endl；//打印匹配结果
此表达式将匹配这样的字符串：一个或多个字母或数字后接一个句点再接三个文件扩展名
之一。这样，此正则表达式将会匹配指定的文件扩展名而不理会大小写。
就像C++语言中有特殊字符一样（参见2。1。3节，第36页），正则表达式语言通常也
有特殊字符。例如，字符点（。）通常匹配任意字符。与C++一样，我们可以在字符之前放
置一个反斜线来去掉其特殊含义。由于反斜线也是C++中的一个特殊字符，我们在字符串
字面常量中必须连续使用两个反斜线来告诉C++我们想要一个普通反斜线字符。因此，为
了表示与句点字符匹配的正则表达式，必须写成\\。（第一个反斜线去掉C++语言中反斜线
的特殊含义，即，正则表达式字符串为\，第二个反斜线则表示在正则表达式中去掉。的特
殊含义）。
Note
指定或使用正则表达式时的错误
我们可以将正则表达式本身看作用一种简单程序设计语言编写的“程序”。这种语言
不是由C++编译器解释的。正则表达式是在运行时，当一个regex对象被初始化或被赋
予一个新模式时，才被“编译”的。与任何其他程序设计语言一样，我们用这种语言编写
的正则表达式也可能有错误。
需要意识到的非常重要的一点是，一个正则表达式的语法是否正确是在运行时
解析的。
如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为
regex_error的异常（参见5。6节，第173页）。类似标准异常类型，regex_error有
一个what操作来描述发生了什么错误（参见5。6。2节，第175页）。regex_error还有
一个名为code的成员，用来返回某个错误类型对应的数值编码。code返回的值是由具
体实现定义的。RE库能拋出的标准错误如表17。7所示。
例如，我们可能在模式中意外遇到一个方括号：
try{
//错误：alnum漏掉了右括号，构造函数会抛出异常
regexr（"[[：alnum：]+\\。（cpp|cxx|cc）$"，regex：：icase）；
}catch（regex_errore）
{cout<<e。what（）<<"\ncode："<<e。code（）<<endl；}
当这段程序在我们的系统上运行时，程序会生成：
regex_error（error_brack）：
Theexpressioncontainedmismatched[and]。
code：4

Page675
17。3正则表达式
定义在regex
error_collate
error_ctype
error_escape
error_backref
error_brack
error_paren
和
表17。7：正则表达式错误类型
regex_constants：：error_type中
无效的元素校对请求
无效的字符类
无效的转义字符或无效的尾置转义
无效的向后引用
不匹配的方括号（[或]）
不匹配的小括号（（或））
不匹配的花括号（{或}）
{}中无效的范围
无效的字符范围（如[z-a]）
内存不足，无法处理此正则表达式
errorbrace
error_badbrace
error_range
error_space
error_badrepeat。
error_complexity
error_stack
重复字符（*、?、+或{）之前没有有效的正则表
达式
要求的匹配过于复杂
栈空间不足，无法处理匹配
我们的编译器定义了code成员，返回表17。7列出的错误类型的编号，与往常一样，
编号从0开始。
建议：避免创建不必要的正则表达式
如我们所见，一个正则表达式所表示的“程序”是在运行时而非编译时编译的。正
则表达式的编译是一个非常慢的操作，特别是在你使用了扩展的正则表达式语法或是复
杂的正则表达式时。因此，构造一个regex对象以及向一个已存在的regex赋予一个
新的正则表达式可能是非常耗时的。为了最小化这种开销，你应该努力避免创建很多不
必要的regex。特别是，如果你在一个循环中使用正则表达式，应该在循环外创建它，
而不是在每步迭代时都编译它。
正则表达式类和输入序列类型
我们可以搜索多种类型的输入序列。输入可以是普通char数据或wchar_t数据，
字符可以保存在标准库string中或是char数组中（或是宽字符版本，wstring或
wchar_t数组中）。RE为这些不同的输入序列类型都定义了对应的类型。
例如，regex类保存类型char的正则表达式。标准库还定义了一个wregex类保存
类型wachar_t，其操作与regex完全相同。两者唯一的差别是wregex的初始值必须
使用wchar_t而不是char。
匹配和迭代器类型（我们将在下面小节中介绍）更为特殊。这些类型的差异不仅在于
字符类型，还在于序列是在标准库string中还是在数组中：smatch表示string类型
的输入序列；cmatch表示字符数组序列；wsmatch表示宽字符串（wstring）输入；
而wcmatch表示宽字符数组。
重点在于我们使用的RE库类型必须与输入序列类型匹配。表17。8指出了RE库类型
与输入序列类型的对应关系。例如：
649
733

Page676
650
734
regex：：icase）；
regexr（"[[：alnum：]]+\\。（cpp|cxx|cc）$"，
smatchresults；//将匹配string输入序列，而不是char*
if（regex_search（"myfile。cc"，results，r））//错误：输入为char*
cout<<results。str（）<<endl；
这段代码会编译失败，因为match参数的类型与输入序列的类型不匹配。如果我们希望
搜索一个字符数组，就必须使用cmatch对象：
cmatchresults；//将匹配字符数组输入序列
if（regex_search（"myfile。cc"，results，r））
cout<<results。str（）<<endl；//打印当前匹配
本书程序一般会使用string输入序列和对应的string版本的RE库组件。
如果输入序列类型
string
constchar*
第17章标准库特殊设施
wstring
constwchart*
表17。8：正则表达式库类
则使用正则表达式类
regex、smatch、ssub_match和sregex_iterator
regexcmatch，csub_matchcregex_iterator
wregex，wsmatch，wssub_matchlwsregex_iterator
wregex，wcmatch，wesub_match1wcregex_iterator
17。3。1节练习
练习17。14：编写几个正则表达式，分别触发不同错误。运行你的程序，观察编译器对
每个错误的输出。
练习17。15：编写程序，使用模式查找违反“i在e之前，除非在c之后”规则的单词。
你的程序应该提示用户输入一个单词，然后指出此单词是否符合要求。用一些违反和未
违反规则的单词测试你的程序。
练习17。16：如果前一題程序中的regex对象用"[^clei"进行初始化，将会发生什么?
用此模式测试你的程序，检查你的答案是否正确。
sregex_iterator
it（b，e，r）；
17。3。2匹配与Regex迭代器类型
第646页中的程序查找违反“i在e之前，除非在c之后”规则的单词，它只打印输
入序列中第一个匹配的单词。我们可以使用sregex_iterator来获得所有匹配。regex
迭代器是一种迭代器适配器（参见9。6节，第329页），被绑定到一个输入序列和一个regex
对象上。如表17。8所述，每种不同输入序列类型都有对应的特殊regex迭代器类型。迭
代器操作如表17。9所述。
表17。9：sregex_iterator操作
这些操作也适用于cregex_iterator、wsregex_iterator和wcregex_iterator。
一个sregex_iterator，遍历迭代器b和e表示的string。
它调用sregex_search（b，e，r）将it定位到输入中第一个匹
配的位置

Page677
17。3正则表达式
sregex_iterator
end；
*it
it->
++it
it++
itl==it2
it1!=it2
sregex_iterator的尾后迭代器
根据最后一个调用regex_search的结果，返回一个smatch对
象的引用或一个指向smatch对象的指针
续表
从输入序列当前匹配位置开始调用regex_search。前置版本返
回递增后迭代器；后置版本返回旧值
如果两个sregex_iterator都是尾后迭代器，则它们相等两个
非尾后迭代器是从相同的输入序列和regex对象构造，则它们相等
当我们将一个sregex_iterator绑定到一个string和一个regex对象时，迭代
器自动定位到给定string中第一个匹配位置。即，sregex_iterator构造函数对给
定string和regex调用regex_search。当我们解引用迭代器时，会得到一个对应最
近一次搜索结果的smatch对象。当我们递增迭代器时，它调用regex_search在输入
string中查找下一个匹配。
使用sregex_iterator
作为一个例子，我们将扩展之前的程序，在一个文本文件中查找所有违反“i在e之
前，除非在c之后”规则的单词。我们假定名为file的string保存了我们要搜索的输
入文件的全部内容。这个版本的程序将使用与前一个版本一样的pattern，但会使用一
个sregex_iterator来进行搜索：
//查找前一个字符不是c的字符串ei
stringpattern（"[^c]ei"）；
//我们想要包含pattern的单词的全部内容
pattern="[[：alpha：]]*"+pattern+"[[：alpha：]]*"；
regexr（pattern，regex：：icase）；//在进行匹配时将忽略大小写
//它将反复调用regex_search来寻找文件中的所有匹配
for（sregex_iteratorit（file。begin（），file。end（），r），end_it；
it!=endit；++it）
cout<<it->str（）<<endl；//匹配的单词
for循环遍历file中每个与r匹配的子串。for语句中的初始值定义了it和endit。
当我们定义it时，sregex_iterator的构造函数调用regex_search将it定位到
file中第一个与r匹配的位置。而end_it是一个空sregex_iterator，起到尾后迭
代器的作用。for语句中的递增运算通过regex_search来“推进”迭代器。当我们解
引用迭代器时，会得到一个表示当前匹配结果的smatch对象。我们调用它的str成员
来打印匹配的单词。
我们可以将此循环想象为不断从一个匹配位置跳到下一个匹配位置，如图17。1所示。
651
735

Page678
652
736
sregex_iteratorit（file。begin（），
将it初始化为第一个匹配位置
Į
matchi
十
file。begin（）
match2
matchi
图17。1：使用sregex_iterator
第17章标准库特殊设施
file。end（），r）
最后一个匹配
Į
matchn
file。end（）
使用匹配数据
如果我们对最初版本程序中的test_str运行此循环，则输出将是
freind
theif
但是，仅获得与我们的正则表达式匹配的单词还不是那么有用。如果我们在一个更大的输
入序列——例如，在本章英文版的文本上运行此程序——可能希望看到匹配单词出现的上
下文，如
heyreadorwriteaccordingtothetype

>>>being<<<
>>>handled。Theinputoperatorsignorewhi
>>>除了允许打印输入字符串中匹配的部分之外，匹配结果类还提供了有关匹配结果的更多细
>>>节信息。表17。10和表17。11列出了这些类型支持的操作。
>>>当it指向第i个smatch对象时
>>>it->prefix（）。str（）
>>>十
>>>我们将在下一节中介绍更多有关smatch和ssub_match类型的内容。目前，我们
>>>只需知道它们允许我们获得匹配的上下文即可。匹配类型有两个名为prefix和suffix
>>>的成员，分别返回表示输入序列中当前匹配之前和之后部分的ssub_match对象。一个
>>>ssub_match对象有两个名为str和length的成员，分别返回匹配的string和该
>>>string的大小。我们可以用这些操作重写语法程序的循环。
>>>//循环头与之前一样
>>>for（sregex_iteratorit（file。begin（），file。end（），r），end_it；
>>>it!=end_it；++it）{
>>>autopos=it->prefix（）。length（）；
>>>//前缀的大小
>>>pos=pos>40?pos
>>>400；
>>>//我们想要最多40个字符
>>>cout<<it->prefix（）。str（）。substr（pos）
>>>//前缀的最后一部分
>>><<"\n\t\t>>>"<<it->str（）<<"<<<\n"//匹配的单词
>>><<it->suffix（）。str（）。substr（0，40）
>>><<endl；
>>>//后缀的第一部分
>>>}
>>>循环本身的工作方式与前一个程序相同。改变的是循环内部，如图17。2所示。
>>>it->str（）
>>>↓
>>>xxxeixxxit->suffix（）。str（）
>>>图17。2：smatch对象表示一个特定匹配
>>>我们调用prefix，返回一个ssub_match对象，表示file中当前匹配之前的部分。

Page679
17。3正则表达式
我们对此ssub_match对象调用length，获得前缀部分的字符数目。接下来调整pos，
使之指向前缀部分末尾向前40个字符的位置。如果前缀部分的长度小于40个字符，我
们将pos置为0，表示要打印整个前缀部分。我们用substr（参见9。5。1节，第321页）
来打印指定位置到前缀部分末尾的内容。
打印了当前匹配之前的字符之后，我们接下来用特殊格式打印匹配的单词本身，使得
它在输出中能突出显示出来。打印匹配单词之后，我们打印file中匹配部分之后的前（最
多）40个字符。
表17。10：smatch操作
这些操作也适用于cmatch、wsmatch、wcmatch和对应的csub_match、wssub_match
和wcsubmatch。
m。ready（）
m。size（）
m。str（n）
m[n]
如果已经通过调用regex_serach或regex_match设置了m，
则返回true；否则返回false。如果ready返回false，则
对m进行操作是未定义的
m。empty（）
m。prefix（）
m。suffix（）
m。format（。。。）
在接受一个索引的操作中，n的默认值为（）且必须小于m。size（）。
第一个子匹配（索引为（））表示整个匹配。
m。length（n）
第n个匹配的子表达式的大小
m。position（n）
第n个子表达式距序列开始的距离
第n个子表达式匹配的string
对应第n个子表达式的ssub_match对象
表示中submatch元素范围的迭代器。与往常一样，cbegin
cendconstiterator
m。begin（），m。end（）
m。cbegin（），m。cend（）
如果匹配失败，则返回0；否则返回最近一次匹配的正则表达式
中子表达式的数目
若m。size（）为0，则返回true
一个ssub_match对象，表示当前匹配之前的序列
一个ssub_match对象，表示当前匹配之后的部分
见表17。12（第657页）
17。3。2节练习
练习17。17：更新你的程序，令它查找输入序列中所有违反“ei”语法规则的单词。
练习17。18：修改你的程序，忽略包含“ei”但并非拼写错误的单词，如“albeit”和
“neighbor”。
17。3。3使用子表达式
正则表达式中的模式通常包含一个或多个子表达式（subexpression）。一个子表达式是
模式的一部分，本身也具有意义。正则表达式语法通常用括号表示子表达式。
例如，我们用来匹配C++文件的模式（参见17。3。1节，第646页）就是用括号来分组
可能的文件扩展名。每当我们用括号分组多个可行选项时，同时也就声明了这些选项形成
子表达式。我们可以重写扩展名表达式，以使得模式中点之前表示文件名的部分也形成子
表达式，如下所示：
653
737
738

Page680
654
739
第17章标准库特殊设施
//r有两个子表达式：第一个是点之前表示文件名的部分，第二个表示文件扩展名
regexr（"（[[：alnum：]]+）\\。（cpp|cxx|cc）$"，regex：：icase）；
现在我们的模式包含两个括号括起来的子表达式：
•（[[：alnum：]]+），匹配一个或多个字符的序列
•（cpp|cxx|cc），匹配文件扩展名
我们还可以重写17。3。1节（第646页）中的程序，通过修改输出语句使之只打印文件名。
if（regex_search（filename，results，r））
cout<<results。str（1）<<endl；//打印第一个子表达式
与最初的程序一样，我们还是调用regex_search在名为filename的string中查找
模式r，并且传递smatch对象results来保存匹配结果。如果调用成功，我们打印结
果。但是，在此版本中，我们打印的是str（1），即，与第一个子表达式匹配的部分。
匹配对象除了提供匹配整体的相关信息外，还提供访问模式中每个子表达式的能力。
子匹配是按位置来访问的。第一个子匹配位置为0，表示整个模式对应的匹配，随后是每
个子表达式对应的匹配。因此，本例模式中第一个子表达式，即表示文件名的子表达式，
其位置为1，而文件扩展名对应的子表达式位置为2。
例如，如果文件名为foo。cpp，则results。str（0）将保存foo。cpp；
results。str（1）将保存foo；而results。str（2）将保存cpp。在此程序中，我们想
要点之前的那部分名字，即第一个子表达式，因此我们打印results。str（1）。
子表达式用于数据验证
子表达式的一个常见用途是验证必须匹配特定格式的数据。例如，美国的电话号码有
十位数字，包含一个区号和一个七位的本地号码。区号通常放在括号里，但这并不是必需
的。剩余七位数字可以用一个短横线、一个点或是一个空格分隔，但也可以完全不用分隔
符。我们可能希望接受任何这种格式的数据而拒绝任何其他格式的数。我们将分两步来实
现这一目标：首先，我们将用一个正则表达式找到可能是电话号码的序列，然后再调用一
个函数来完成数据验证。
在编写电话号码模式之前，我们需要介绍一下ECMAScript正则表达式语言的一些特
性：
•\{d}表示单个数字而\{d}{n}则表示一个n个数字的序列。（如，\{d}{3}匹配
三个数字的序列。）
•在方括号中的字符集合表示匹配这些字符中任意一个。（如，[-。]匹配一个短横
线或一个点或一个空格。注意，点在括号中没有特殊含义。）
●
后接’?’的组件是可选的。（如，\{d}{3}[-。]?\{d}{4}匹配这样的序列：开
始是三个数字，后接一个可选的短横线或点或空格，然后是四个数字。此模式可以
匹配555-0132或555。0132或5550132或5550132）
•类似C++，ECMAScript使用反斜线表示一个字符本身而不是其特殊含义。由于我
们的模式包含括号，而括号是ECMAScript中的特殊字符，因此我们必须用\（和\）
来表示括号是我们的模式的一部分而不是特殊字符。
由于反斜线是C++中的特殊字符，在模式中每次出现\的地方，我们都必须用一个额外的
反斜线来告知C++我们需要一个反斜线字符而不是一个特殊符号｡因此，我们用\\{d}{3}
来表示正则表达式\{d}{3}。

Page681
17。3正则表达式
为了验证电话号码，我们需要访问模式的组成部分。例如，我们希望验证区号部分的
数字如果用了左括号，那么它是否也在区号后面用了右括号。即，我们不希望出现
（908。555。1800这样的号码。
为了获得匹配的组成部分，我们需要在定义正则表达式时使用子表达式。每个子表达
式用一对括号包围：
//整个正则表达式包含七个子表达式：（ddd）分隔符ddd分隔符dddd
//子表达式1、3、4和6是可选的；2、5和7保存号码
"（\\（）?（\\d{3}）（\\））?（[-。]）?（\\d{3}）（[-。1?）（\\d{4}）"；
由于我们的模式使用了括号，而且必须去除反斜线的特殊含义，因此这个模式很难读（也
很难写!）。理解此模式的最简单的方法是逐个剥离（括号包围的）子表达式：
1。（\\（）?表示区号部分可选的左括号
2。（\\d{3}）表示区号
3。（\\））?表示区号部分可选的右括号
4。（[-。]）?表示区号部分可选的分隔符
5。（\\d{3}）表示号码的下三位数字
6。（[-。]）?表示可选的分隔符
7。（\\d{4}）表示号码的最后四位数字
下面的代码读取一个文件，并用此模式查找与完整的电话号码模式匹配的数据。它会
调用一个名为valid的函数来检查号码格式是否合法：
stringphone=
"（\\（）?（\\d{3}）（\\））?（[-]）?（\\d{3}）（[-。]?）（\\d{4}）"；
regexr（phone）；//regex对象，用于查找我们的模式
smatchm；
strings；
//从输入文件中读取每条记录
while（getline（cin，s））{
//对每个匹配的电话号码
for（sregex_iteratorit（s。begin（），s。end（），r），end_it；
it!=end_it；++it）
//检查号码的格式是否合法
if（valid（*it））
else
cout<<"valid：<<it->str（）<<endl；
cout<<"notvalid："1
<<it->str（）<<endl；
使用子匹配操作
我们将使用表17。11中描述的子匹配操作来编写valid函数｡需要记住的重要一点是，
我们的pattern有七个子表达式。与往常一样，每个smatch对象会包含八个
ssub_match元素。位置[0]的元素表示整个匹配；元素[1]。。。[7]表示每个对应的子表达式。
当调用valid时，我们知道已经有一个完整的匹配，但不知道每个可选的子表达式
是否是匹配的一部分。如果一个子表达式是完整匹配的一部分，则其对应的ssubmatch
对象的matched成员为true。
655
740

Page682
656
741
17。11：7子匹配操作
注意：这些操作适用于ssub_match、csub_match、wssub_match、wcsub_match。
一个publicbool数据成员，指出此ssubmatch是否匹配了
matched。
first
second
length（）
str（）
s=ssub
public数据成员，指向匹配序列首元素和尾后位置的迭代器。如果
未匹配，则first和second是相等的
匹配的大小。如果matched为false，则返回0
返回一个包含输入中匹配部分的string。如果matched为false，
则返回空string
第17章标准库特殊设施
将ssub_match对象ssub转化为string对象s。等价于
s=ssub。str（）。转换运算符不是explicit的（参见14。9。1节，
第515页）
在一个合法的电话号码中，区号要么是完整括号包围的，要么完全没有括号。因此，
valid要做什么工作依赖于号码是否以一个括号开始：
boolvalid（constsmatch&m）
{
else
//如果区号前有一个左括号
if（m[1]。matched）
//则区号后必须有一个右括号，之后紧跟剩余号码或一个空格
returnm[3]。matched
&&（m[4]。matched==0||m[4]。str（）
//否则，区号后不能有右括号
//另两个组成部分间的分隔符必须匹配
return!m[3]。matched

&&m[4]。str（）==m[6]。str（）；
==

}
我们首先检查第一个子表达式（即，左括号）是否匹配了。这个子表达式在m[1]中。
如果匹配了，则号码是以左括号开始的。在此情况下，如果区号后的子表达式也匹配了（意
味着区号后有右括号）则整个号码是合法的。而且，如果号码正确使用了括号，则下一个
字符必须是一个空格或下一部分的第一个数字。
如果m[1]未匹配，（即，没有左括号），则区号后的子表达式也不应该匹配。如果它
为空，则整个号码是合法的。
17。3。3节练习
练习17。19：为什么可以不先检查[4]是否匹配了就直接调用m[4]。str（）?
练习17。20：编写你自己版本的验证电话号码的程序。
练习17。21：使用本节中定义的valid函数重写8。3。2节（第289页）中的电话号码程序。
练习17。22：重写你的电话号码程序，使之允许在号码的三个部分之间放置任意多个空
白符。
练习17。23：编写查找邮政编码的正则表达式。一个美国邮政编码可以由五位或九位数
字组成。前五位数字和后四位数字之间可以用一个短横线分隔。

Page683
17。3正则表达式
17。3。4使用regex_replace
正则表达式不仅用在我们希望查找一个给定序列的时候，还用在当我们想将找到的序
列替换为另一个序列的时候｡例如，我们可能希望将美国的电话号码转换为“ddd。ddd。dddd"
的形式，即，区号和后面三位数字用一个点分隔。
当我们希望在输入序列中查找并替换一个正则表达式时，可以调用
regex_replace。表17。12描述了regex_replace，类似搜索函数，它接受一个输入字符
序列和一个regex对象，不同的是，它还接受一个描述我们想要的输出形式的字符串。
m。format（dest，fmt，mft）
m。format（fmt，mft）
表17。12：正则表达式替换操作
regex_replace（dest，seq，r，
fmt，mft）
regex_replace（seq，r，fmt，mft）
使用格式字符串fmt生成格式化输出，匹配在m中，可选的
match_flag_type标志在mft中。第一个版本写入迭代
器dest指向的目的位置（参见10。5。1节，第365页）并接
受fmt参数，可以是一个string，也可以是表示字符数组
中范围的一对指针。第二个版本返回一个string，保存输
出，并接受fmt参数，可以是一个string，也可以是一个
指向空字符结尾的字符数组的指针。mft的默认值为
format_default
908。555。1800
遍历seq，用regex_search查找与regex对象r匹配的
子串。使用格式字符串fmt和可选的match_flag_type
标志来生成输出。第一个版本将输出写入到迭代器dest指
定的位置，并接受一对迭代器seq表示范围。第二个版本返
回一个string，保存输出，且seq既可以是一个string
也可以是一个指向空字符结尾的字符数组的指针。在所有情
况下，fmt既可以是一个string也可以是一个指向空字符
结尾的字符数组的指针，且mft的默认值为
matchdefault。
替换字符串由我们想要的字符组合与匹配的子串对应的子表达式而组成。在本例中，
我们希望在替换字符串中使用第二个、第五个和第七个子表达式。而忽略第一个､第三个、
第四个和第六个子表达式，因为这些子表达式用来形成号码的原格式而非新格式中的一部
分。我们用一个符号$后跟子表达式的索引号来表示一个特定的子表达式：
stringfmt="$2。$5。$7"；//将号码格式改为ddd。ddd。dddd
可以像下面这样使用我们的正则表达式模式和替换字符串：
regexr（phone）；//用来寻找模式的regex对象
stringnumber="（908）555-1800"；
cout<<regex_replace（number，r，fmt）<<endl；
此程序的输出为：
657
742

Page684
658
743
只替换输入序列的一部分
正则表达式更有意思的一个用处是替换一个大文件中的电话号码。例如，我们有一个
保存人名及其电话号码的文件：
morgan（201）555-2368862-555-0123
drew（973）555。0130
lee（609）555-01322015550175800。555-0000
我们希望将数据转换为下面这样：
morgan201。555。2368862。555。0123
drew973。555。0130
lee609。555。0132201。555。0175800。555。0000
可以用下面的程序完成这种转换：
intmain（）
{
第17章标准库特殊设施
stringphone
"（\\（）?（\\d{3}）（\\））?（[-。1）?（\\d{3}）（[-。]）?（\\d{4}）"；
regexr（phone）；//寻找模式所用的regex对象
smatchm；
=
strings；
stringfmt="$2。$5。$7"；//将号码格式改为ddd。ddd。dddd
//从输入文件中读取每条记录
while（getline（cin，s））
return0；
cout<<regex_replace（s，r，fmt）<<endl；
}
我们读取每条记录，保存到s中，并将其传递给regex_replace。此函数在输入序列中
查找并转换所有匹配子串。
用来控制匹配和格式的标志
就像标准库定义标志来指导如何处理正则表达式一样，标准库还定义了用来在替换过
程中控制匹配或格式的标志。表17。13列出了这些值。这些标志可以传递给函数
regex_searchregex_match
smatchformat。
匹配和格式化标志的类型为match_flag_type。这些值都定义在名为
regex_constants的命名空间中。类似用于bind的placeholders（参见10。3。4节，
第355页），regex_constants也是定义在命名空间std中的命名空间。为了使用
regex_constants中的名字，我们必须在名字前同时加上两个命名空间的限定符：
usingstd：：regex_constants：：format_no_copy；
此声明指出，如果代码中使用了format_no_copy，则表示我们想要使用命名空间
std：：constants中的这个名字。如下所示，我们也可以用另一种形式的using来代替
上面的代码，我们将在18。2。2节（第702页）中介绍这种形式：
usingnamespacestd：：regex_constants；

Page685
17。4随机数
表17。13：匹配标志
定义在regex_constants：：match_flag_type中
matchdefault
match_not_bol
match_not_eol
match_not_bow
match_not_eow
match_any
match_not_null
match_continuous
match_prev_avail
formatdefault
format_sed
format_no_copy
format_first_only
等价于formatdefault
不将首字符作为行首处理
不将尾字符作为行尾处理
不将首字符作为单词首处理
不将尾字符作为单词尾处理
如果存在多于一个匹配，则可返回任意一个匹配
不匹配任何空序列
匹配必须从输入的首字符开始
输入序列包含第一个匹配之前的內容
用ECMAScript规则替换字符串
用POSIXsed规则替换字符串
不输出输入序列中未匹配的部分
只替换子表达式的第一次出现
使用格式标志
默认情况下，regex_replace输出整个输入序列。未与正则表达式匹配的部分会原
样输出；匹配的部分按格式字符串指定的格式输出。我们可以通过在regex_replace
调用中指定format_no_copy来改变这种默认行为：
//只生成电话号码：使用新的格式字符串
stringfmt2="$2。$5。$7"；//在最后一部分号码后放置空格作为分隔符
//通知regex_replace只拷贝它替换的文本
cout<<regex_replace（s，r，fmt2，format_no_copy）<<endl；
给定相同的输入，此版本的程序生成
201。555。2368862。555。0123
973。555。0130
609。555。0132201。555。0175800。555。0000
17。3。4节练习
练习17。24：编写你自己版本的重排电话号码格式的程序。
练习17。25：重写你的电话号码程序，使之只输出每个人的第一个电话号码。
练习17。26：重写你的电话号码程序，使之对多于一个电话号码的人只输出第二个和后
续电话号码。
练习17。27：编写程序，将九位数字邮政编码的格式转换为ddddd-dddd。
17。4随机数
程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库
函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和
一个系统相关的最大值（至少为32767）之间。
659
744
745
C++
11

Page686
660
746
rand函数有一些问题：即使不是大多数，也有很多程序需要不同范围的随机数。
些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试
图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。
定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎
类（random-numberengines）和随机数分布类（random-numberdistribution）。表17。14描
述了这些类。一个引擎类可以生成unsigned随机数序列，一个分布类使用一个引擎类
生成指定类型的、在给定范围内的、服从特定概率分布的随机数。
引擎
分布
Best
Practices
第17章标准库特殊设施
表17。14：随机数库的组成
类型，生成随机unsigned整数序列
类型，使用引擎返回服从特定概率分布的随机数
C++程序不应该使用库函数rand，而应使用default_random_engine类
和恰当的分布类对象。
17。4。1随机数引擎和分布
随机数引擎是函数对象类（参见14。8节，第506页），它们定义了一个调用运算符，
该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引
擎对象来生成原始随机数：
default_random_enginee；//生成随机无符号数
for（size_ti=0；i<10；++i）
//e（）“调用”对象来生成下一个随机数
cout<<e（）<<""；
在我们的系统中，此程序生成：
1680728247524916226500739849436581144108930470211272
在本例中，我们定义了一个名为e的default_random_engine对象。在for循环内，
我们调用对象e来获得下一个随机数。
Enginee；
Enginee（s）；
e。seed（s）
e。min（）
e。max（）
标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会
指定其中一个作为default_random_engine类型。此类型一般具有最常用的特性。表
17。15列出了随机数引擎操作，标准库定义的引擎类型列在附录A。3。2（第783页）中。
Engine：：result_type
e。discard（u）
表17。15：随机数引擎操作
默认构造函数；使用该引擎类型默认的种子
使用整型值s作为种子
使用种子s重置引擎的状态
此引擎可生成的最小值和最大值
此引擎生成的unsigned整型类型
将引擎推进u步；u的类型为unsignedlonglong
对于大多数场合，随机数引擎的输出是不能直接使用的，这也是为什么早先我们称之
为原始随机数。问题出在生成的随机数的值范围通常与我们需要的不符，而正确转换随机
数的范围是极其困难的。

Page687
17。4随机数
分布类型和引擎
为了得到在一个指定范围内的数，我们使用一个分布类型的对象：
//生成0到9之间（包含）均匀分布的随机数
uniform_int_distribution<unsigned>
u（0，9）；
default_random_enginee；//生成无符号随机整数
for（size_ti=0；i<10；++i）
//将u作为随机数源
//每个调用返回在指定范围内并服从均匀分布的值
cout<<u（e）<<""；
此代码生成下面这样的输出
0174520669
此处我们将u定义为uniform_int_distribution<unsigned>。此类型生成均勻分
布的unsigned值。当我们定义一个这种类型的对象时，可以提供想要的最小值和最大
值。在此程序中，u（0，9）表示我们希望得到0到9之间（包含）的数。随机数分布类会
使用包含的范围，从而我们可以得到给定整型类型的每个可能值。
类似引擎类型，分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受
一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的
分布。
注意，我们传递给分布对象的是引擎对象本身，即u（e）。如果我们将调用写成
u（e（）），含义就变为将e生成的下一个值传递给u，会导致一个编译错误。我们传递的
是引擎本身，而不是它生成的下一个值，原因是某些分布可能需要调用引擎多次才能得到
一个值。
Note
当我们说随机数发生器时，是指分布对象和引擎对象的组合。
比较随机数引擎和rand函数
对熟悉C库函数rand的读者，值得注意的是：调用一个default_random_engine
对象的输出类似rand的输出。随机数引擎生成的unsigned整数一个系统定义的范围
内，而rand生成的数的范围在0到RAND_MAX之间。一个引擎类型的范围可以通过调
用该类型对象的min和max成员来获得：
cout<<"min：
在我们的系统中，此程序生成下面的输出：
min：1max：2147483646
"<<e。min（）<<"max：<<e。max（）<<endl；
11
引擎生成一个数值序列
随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对一
个给定的发生器，每次运行程序它都会返回相同的数值序列。序列不变这一事实在调试时
非常有用。但另一方面，使用随机数发生器的程序也必须考虑这一特性。
作为一个例子，假定我们需要一个函数生成一个vector，包含100个均匀分布在0
到9之间的随机数。我们可能认为应该这样编写此函数：
661
747

Page688
662
748
//几乎肯定是生成随机整数vector的错误方法
//每次调用这个函数都会生成相同的100个数!
vector<unsigned>bad_randVec（）
{
default_random_enginee；
{
uniform_int_distribution<unsigned>u（0，9）；
vector<unsigned>ret；
for（sizeti=0；i<100；++i）
ret。push_back（u（e））；
returnret；
}
但是，每次调用这个函数都会返回相同的vector：
vector<unsigned>vl（bad_randVec（））；
vector<unsigned>v2（bad_randVec（））；
//将打印"equal"
cout<<（（v1
此代码会打印equal，因为vectorv1和v2具有相同的值。
编写此函数的正确方法是将引擎和关联的分布对象定义为static的（参见6。1。1节，

第185页）：
==

//返回一个vector，包含100个均匀分布的随机数
vector<unsigned>good_randVec（）
第17章标准库特殊设施
v2）?"equal"："notequal"）<<endl；
//由于我们希望引擎和分布对象保持状态，因此应该将它们
//定义为static的，从而每次调用都生成新的数
staticdefault_random_enginee；
staticuniform_int_distribution<unsigned>u（0，9）；
vector<unsigned>ret；
for（size_ti=0；i<100；++i）
ret。push_back（u（e））；
returnret；
}
由于e和u是static的，因此它们在函数调用之间会保持住状态。第一次调用会使用
u（e）生成的序列中的前100个随机数，第二次调用会获得接下来100个，依此类推。
一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了
局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。
WARNING否则，每次调用函数都会生成相同的序列。
设置随机数发生器种子
随机数发生器会生成相同的随机数序列这一特性在调试中很有用。但是，一旦我们的
程序调试完毕，我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个
种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置
重新开始生成随机数。
为引擎设置种子有两种方式：在创建引擎对象时提供种子，或者调用引擎的seed成
员：

Page689


Page690
664
uniform_real_distribution类型的对象，并让标准库来处理从随机整数到随机浮点
数的映射。与处理uniformintdistribution一样，在定义对象时，我们指定最小
值和最大值：
default_random_enginee；//生成无符号随机整数
//0到1（包含）的均勻分布
uniform_real_distribution<double>u（0，1）；
for（size_ti=0；i<10；++i）
cout<<u（e）<<""；
这段代码与之前生成unsigned值的程序几乎相同。但是，由于我们使用了一个不同的
分布类型，此版本会生成不同的结果：
0。1315380。458650。2189590。6788650。9346930。519416。。。
Distd；
d（e）
第17章标准库特殊设施
d。min（）
d。max（）
d。reset（）
表17。16：分布类型的操作
默认构造函数；使d准备好被使用。
其他构造函数依赖于Dist的类型；参见附录A。3节（第781页）。
分布类型的构造函数是explicit的（参见7。5。4节，第265页）
用相同的e连续调用d的话，会根据d的分布式类型生成一个随机数序
列；e是一个随机数引擎对象
返回d（e）能生成的最小值和最大值
重建d的状态，使得随后对d的使用不依赖于d已经生成的值
使用分布的默认结果类型
分布类型都是模板，具有单一的模板类型参数，表示分布生成的随机数的类型，对此
有一个例外，我们将在17。4。2节（第665页）中进行介绍。这些分布类型要么生成浮点类
型，要么生成整数类型。
每个分布模板都有一个默认模板实参（参见16。1。3节，第594页）。生成浮点值的分
布类型默认生成double值，而生成整型值的分布默认生成int值。由于分布类型只有
一个模板参数，因此当我们希望使用默认随机数类型时要记得在模板名之后使用空尖括号
（参见16。1。3节，第594页）：
//空<>表示我们希望使用默认结果类型
uniform_real_distribution<>u（0，1）；//默认生成double值
751生成非均匀分布的随机数
除了正确生成在指定范围内的数之外，新标准库的另一个优势是可以生成非均匀分布
的随机数。实际上，新标准库定义了20种分布类型，这些类型列在附录A。3（第781）中。
作为一个例子，我们将生成一个正态分布的值的序列，并画出值的分布。由于
normal_distribution生成浮点值，我们的程序使用头文件cmath中的Iround函数
将每个随机数舍入到最接近的整数。我们将生成200个数，它们以均值4为中心，标准差
为1。5。由于使用的是正态分布，我们期望生成的数中大约99%都在0到8之间（包含）。
我们的程序会对这个范围内的每个整数统计有多少个生成的数映射到它：
default_random_enginee；
normal_distribution<>n（4，1。5）；
//生成随机整数
//均值4，标准差1。5

Page691
17。4随机数
vector<unsigned>vals（9）；
for（sizeti=0；i!=200；++i）{
}
for
unsignedv=lround（n（e））；
if（v<vals。size（））
++vals[v]；
//9个元素均为0
（size_tj=0；j!=vals。size（）；++j）
cout<<j<<"；"<<string（vals[j]，'*'）<<endl；
我们首先定义了随机数发生器对象和一个名为vals的vector。我们用vals来统计范
围0。。。8中的每个数出现了多少次。与我们使用vector的大多数程序不同，此程序按需
求大小为vals分配空间，每个元素都被初始化为0。

***

//舍入到最接近的整数
//如果结果在范围内
//统计每个数出现了多少次
在for循环中，我们调用lround（n（e））来将n（e）返回的值舍入到最接近的整数。
获得浮点随机数对应的整数后，我们将它作为计数器vector的下标。由于n（e）可能生
成范围0到8之外的数，所以我们首先检查生成的数是否在范围内，然后再将其作为vals
的下标。如果结果确实在范围内，我们递增对应的计数器。
当循环结束时，我们打印vals的内容，可能会打印出像下面这样的结果：
0：***
1：********
2：***********
3：**************
4：**************

*****

5：************************
6：***********************
7：*******
8：*

********

**************

******

******

*******

本例中我们打印一个由星号组成的string，有多少随机数等于此下标我们就打印多少个
星号。注意，此图并不是完美对称的。如果打印出的图是完美对称的，我们反倒有理由怀
疑随机数发生器的质量了。
bernoulli_distribution*
我们注意到有一个分布不接受模板参数，即bernoulli_distribution，因为它
是一个普通类，而非模板。此分布总是返回一个bool值。它返回true的概率是一个常
数，此概率的默认值是0。5。

***

作为一个这种分布的例子，我们可以编写一个程序，这个程序与用户玩一个游戏。为
了进行这个游戏，其中一个游戏者——用户或是程序——必须先行。我们可以用一个值范
围是0到1的uniform_int_distribution来选择先行的游戏者，但也可以用伯努利
分布来完成这个选择。假定已有一个名为play的函数来进行游戏，我们可以编写像下面
这样的循环来与用户交互：
stringresp；
default_random_enginee；//e应保持状态，所以必须在循环外定义!
bernoulli_distributionb；//默认是50/50的机会
do{
boolfirst=b（e）；//如果为true，则程序先行
cout<<（first?"Wegofirst"
："Yougettogofirst"）<<endl；
665
752

Page692
666
753
WARNING
第17章标准库特殊设施
//传递谁先行的指示，进行游戏
cout<<（（play（first））?"sorry，youlost"
："congrats，youwon"）<<endl；
cout<<"playagain?Enter'yes'or'no'"<<endl；
'y'）；
}while（cin>>resp&&resp[0]

我们用一个dowhile循环（参见5。4。4节，第169页）来反复提示用户进行游戏。
==

由于引擎返回相同的随机数序列（参见17。4。1节，第661页），所以我们必须
在循环外声明引擎对象。否则，每步循环都会创建一个新引擎，从而每步循环
都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外
定义。
在此程序中使用bernoulli_distribution的一个原因是它允许我们调整选择先
行一方的概率：
bernoullidistributionb（。55）；//给程序一个微小的优势
如果b定义如上，则程序有55/45的机会先行。
17。4。2节练习
练习17。31：对于本节中的游戏程序，如果在do循环内定义b和e，会发生什么?
练习17。32：如果我们在循环内定义resp，会发生什么?
练习17。33：修改11。3。6节（第392页）中的单词转换程序，允许对一个给定单词有多
种转换方式，每次随机选择一种进行实际转换。
17。5IO库再探
在第8章中我们介绍了IO库的基本结构及其最常用的部分。在本节中，我们将介绍
三个更特殊的IO库特性：格式控制、未格式化IO和随机访问。
17。5。1格式化输入与输出
除了条件状态外（参见8。1。2节，第279页），每个iostream对象还维护一个格式
状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型值是几进制、
浮点值的精度、一个输出元素的宽度等。
标准库定义了一组操纵符（manipulator）（参见1。2节，第6页）来修改流的格式状态，
如表17。7和表17。8所示。一个操纵符是一个函数或是一个对象，会影响流的状态，并能
用作输入或输出运算符的运算对象。类似输入和输出运算符，操纵符也返回它所处理的流
对象，因此我们可以在一条语句中组合操纵符和数据。
我们已经在程序中使用过一个操纵符——endl，我们将它“写”到输出流，就像它是
一个值一样。但endi不是一个普通值，而是一个操作：它输出一个换行符并刷新缓冲区。

Page693
17。5IO库再探
很多操纵符改变格式状态
操纵符用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。大多
数改变格式状态的操纵符都是设置/复原成对的；一个操纵符用来将格式状态设置为一个新
值，而另一个用来将其复原，恢复为正常的默认格式。
当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。
WARNING
当我们有一组IO操作希望使用相同的格式时，操纵符对格式状态的改变是持久的这
一特性很有用。实际上，一些程序会利用操纵符的这一特性对其所有输入或输出重置一个
或多个格式规则的行为。在这种情况下，操纵符会改变流这一特性就是满足要求的了。
但是，很多程序（而且更重要的是，很多程序员）期望流的状态符合标准库正常的默
认设置。在这些情况下，将流的状态置于一个非标准状态可能会导致错误。因此，通常最
好在不再需要特殊格式时尽快将流恢复到默认状态。
控制布尔值的格式
操纵符改变对象的格式状态的一个例子是boolalpha操纵符。默认情况下，bool
值打印为1或0。一个true值输出为整数1，而false输出为0。我们可以通过对流使
用boolalpha操纵符来覆盖这种格式：
cout<<"defaultboolvalues：
<<"\nalphaboolvalues：<<boolalpha
<<true<<"<<false<<endl；
执行这段程序会得到下面的结果：
defaultboolvalues：10
alphaboolvalues：truefalse
"1
11
<<boolval
<<noboolalpha；
11
一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打
印bool值的操作都会打印true或false而非1或0。
为了取消cout格式状态的改变，我们使用noboolalpha：
<<true<<""<<false
boolbool_val=get_status（）；
cout<<boolalpha//设置cout的內部状态
11
//将内部状态恢复为默认格式
本例中我们改变了bool值的格式，但只对bool_val的输出有效。一旦完成此值的打印，
我们立即将流恢复到初始状态。
指定整型值的进制
默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct和dec
将其改为十六进制、八进制或是改回十进制：
cout<<"default："<<20<"<<1024<<endl；
<<ct<<20<<"
cout<<"octal：
cout<<"hex：
cout<<"decimal：
当编译并执行这段程序时，会得到如下输出：
<<hex<<20<<
"1<<1024<<endl；
<<1024<<endl；
<<dec<<20<<"11
<<1024<<endl；
667
754

Page694
668
755
default：201024
octal：242000
hex：14400
decimal：201024
注意，类似boolalpha，这些操纵符也会改变格式状态。它们会影响下一个和随后
所有的整型输出，直至另一个操纵符又改变了格式为止。
操纵符hex、oct和dec只影响整型运算对象，浮点值的表示形式不受影响。
Note
在输出中指出进制
默认情况下，当我们打印出数值时，没有可见的线索指出使用的是几进制。例如，20
是十进制的20还是16的八进制表示?当我们按十进制打印数值时，打印结果会符合我们
的期望。如果需要打印八进制值或十六进制值，应该使用showbase操纵符。当对流应
用showbase操纵符时，会在输出结果中显示进制，它遵循与整型常量中指定进制相同
的规范：
●
前导0x表示十六进制。
前导0表示八进制。
无前导字符串表示十进制。
我们可以使用showbase修改前一个程序：
cout<<showbase；//当打印整型值时显示进制
cout<<"default：
<20
<<1024<<endl；
cout<<"inoctal："<<oct<<20<<"<<1024<<endl；
cout<<"inhex：<<hex<<20<<""<<1024<<endl；
cout<<"indecimal："<<de<<20<<"<<1024<<endl；
cout<<noshowbase；//恢复流状态
修改后的程序的输出会更清楚地表明底层值到底是什么：
default：201024
inoctal：02402000
inhex：0x140x400
indecimal：201024
"1
cout<<uppercase<<showbase<<hex
第17章标准库特殊设施
操纵符noshowbase恢复cout的状态，从而不再显示整型值的进制。
默认情况下，十六进制值会以小写打印，前导字符也是小写的x。我们可以通过使用
uppercase操纵符来输出大写的x并将十六进制数字a-f以大写输出：
这条语句生成如下输出：
11
<<"printedinhexadecimal："<<20<<"<<1024
<<nouppercase<<noshowbase<<dec<<endl；
控制浮点数格式
我们可以控制浮点数输出三个种格式：
printedinhexadecimal：0x140X400
我们使用了操纵符nouppercase、noshowbase和dec来重置流的状态。
"

Page695
17。5IO库再探
•以多高精度（多少个数字）打印浮点值
●数值是打印为十六进制、定点十进制还是科学记数法形式
•对于没有小数部分的浮点值是否打印小数点
默认情况下，浮点值按六位数字精度打印；如果浮点值没有小数部分，则不打印小数点；
根据浮点数的值选择打印成定点十进制或科学记数法形式。标准库会选择一种可读性更好
的格式：非常大和非常小的值打印为科学记数法形式，其他值打印为定点十进制形式。
指定打印精度
默认情况下，精度会控制打印的数字的总数。当打印时，浮点值按当前精度舍入而非
截断。因此，如果当前精度为四位数字，则3。14159将打印为3。142；如果精度为三位
数字，则打印为3。14。
我们可以通过调用IO对象的precision成员或使用setprecision操纵符来改变
精度。precision成员是重载的（参见6。4节，第206页）。一个版本接受一个int值，
将精度设置为此值，并返回旧精度值。另一个版本不接受参数，返回当前精度值。
setprecision操纵符接受一个参数，用来设置精度。
Note
操纵符setprecision和其他接受参数的操纵符都定义在头文件iomanip
中。
下面的程序展示了控制浮点值打印精度的不同方法：
//cout。precision返回当前精度值
cout<<"Precision："<<cout。precision（）
<<"，Value："
<<sqrt（2。0）<<endl；
//cout。precision（12）将打印精度设置为12位数字
cout。precision（12）；
cout<<"Precision："<<cout。precision（）
<<"，Value："
<<sqrt（2。0）<<endl；
//另一种设置精度的方法是使用setprecision操纵符
cout<<setprecision（3）；
cout<<"Precision："<<cout。precision（）
<<"，Value："<<sqrt（2。0）<<endl；
编译并执行这段程序，会得到如下输出：
Precision：6，Value：1。41421
Precision：12，Value：1。41421356237
Precision：3，Value：1。41
此程序调用标准库sqrt函数，它定义在头文件cmath中。sqrt函数是重载的，不同版
本分别接受一个float、double或longdouble参数，返回实参的平方根。
boolalpha
*noboolalpha
showbase
*noshowbase
showpoint
表17。17：定义在iostream中的操纵符
将true和false输出为字符串
将true和false输出为1，0
对整型值输出表示进制的前缀
不生成表示进制的前缀
对浮点值总是显示小数点
669
756
757

Page696
670
C++
11
758
*noshowpoint
showpos
*noshowpos
uppercase
*nouppercase
*dec
hex
oct
left
right
internal。
fixed
scientific
hexfloat
defaultfloat
unitbuf
*nounitbuf
*skipws
Best
Practices
noskipws
flush
ends
endl
表示默认流状态
指定浮点数记数法
第17章标准库特殊设施
只有当浮点值包含小数部分时才显示小数点
对非负数显示+
对非负数不显示+
在十六进制值中打印0x，在科学记数法中打印E
在十六进制值中打印0x，在科学记数法中打印e
整型值显示为十进制
整型值显示为十六进制
整型值显示为八进制
在值的右侧添加填充字符
在值的左侧添加填充字符
在符号和值之间添加填充字符
浮点值显示为定点十进制
浮点值显示为科学记数法
浮点值显示为十六进制（C++11新特性）
重置浮点数格式为十进制（C++11新特性）
每次输出操作后都刷新缓冲区
恢复正常的缓冲区刷新方式
输入运算符跳过空白符
输入运算符不跳过空白符
刷新ostream缓冲区
插入空字符，然后刷新ostream缓冲区
插入换行，然后刷新ostream缓冲区
除非你需要控制浮点数的表示形式（如，按列打印数据或打印表示金额或百分
比的数据），否则由标准库选择记数法是最好的方式。
续表
通过使用恰当的操纵符，我们可以强制一个流使用科学记数法、定点十进制或是十六
进制记数法。操纵符scientific改变流的状态来使用科学记数法。操纵符fixed改变
流的状态来使用定点十进制。
11
在新标准库中，通过使用hexfloat也可以強制浮点数使用十六进制格式。新标准
库还提供另一个名为defaultfloat的操纵符，它将流恢复到默认状态——根据要打印
的值选择记数法。
这些操纵符也会改变流的精度的默认含义。在执行scientific、fixed或
hexfloat后，精度值控制的是小数点后面的数字位数，而默认情况下精度值指定的是数
字的总位数——既包括小数点之后的数字也包括小数点之前的数字。使用fixed或
scientific令我们可以按列打印数值，因为小数点距小数部分的距离是固定的：
cout<<"defaultformat："<<100*sqrt（2。0）<<'\n'
<<"scientific："<<scientific<<100*sqrt（2。0）<<'\n'
<<"fixeddecimal：<<fixed<<100*sqrt（2。0）<<'\n'
<<"hexadecimal："<<hexfloat<<100*sqrt（2。0）<<'\n'
<<"usedefaults："<<defaultfloat<<100*sqrt（2。0）

Page697
17。5IO库再探
<<"\n\n"；
此程序会生成下面的输出：
defaultformat：141。421
scientific：1。414214e+002
fixeddecimal：141。421356
hexadecimal：0x1。1ad7bcp+7
usedefaults：141。421
默认情况下，十六进制数字和科学记数法中的e都打印成小写形式。我们可以用uppercase
操纵符打印这些字母的大写形式。
打印小数点
默认情况下，当一个浮点值的小数部分为0时，不显示小数点。showpoint操纵符
強制打印小数点：
cout<<10。0<<endl；
cout<<showpoint<<10。0
//打印10
//TEP10。0000
<<noshowpoint<<endl；//恢复小数点的默认格式
操纵符noshowpoint恢复默认行为。下一个输出表达式将有默认行为，即，当浮点值的
小数部分为0时不输出小数点。
输出补白
当按列打印数据时，我们常常需要非常精细地控制数据格式。标准库提供了一些操纵
符帮助我们完成所需的控制：
setw指定下一个数字或字符串值的最小空间。
•left表示左对齐输出。
•right表示右对齐输出，右对齐是默认格式。
•internal控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中
间空间。
•setfill允许指定一个字符代替默认的空格来补白输出。
setw类似endl，不改变输出流的内部状态。它只决定下一个输出的大小。
Note
下面程序展示了如何使用这些操纵符：
inti=-16；
doubled=3。14159；
//补白第一列，使用输出中最小12个位置
cout<<"i："<<setw（12）<<i<<"nextcol"<<'\n'
<<"d：11
<<setw（12）<<d<<"nextcol"<<'\n'；
//补白第一列，左对齐所有列
cout<<left
<<"i：
<<setw（12）<<i<<"nextcol"<<'\n'
<<"d："1
<<setw（12）<<d<<"nextcol"<<'\n'
<<right；//恢复正常对齐
//补白第一列，右对齐所有列
cout<<right
<<"i：<<setw（12）<<i<<"nextcol"<<'\n'
671
759

Page698
672
760
//补白第一列，但补在域的內部
cout<<internal
<<"d："<<setw（12）<<d<<"nextcol"<<'\n'；
i：
<<"i："<<setw（12）<<i<<
"nextcol"<<'\n'
<<"d：<<setw（12）<<d<<"nextcol"<<'\n'；
//补白第一列，用#作为补白字符
cout<<setfill（'#'）
"1
<<"i：<<setw（12）<<i<<"nextcol"<<'\n'
<<"d：<<setw（12）<<d<<"nextcol"<<'\n'
<<setfill（''）；//恢复正常的补白字符
执行这段程序，会得到下面的输出：
-16nextcol
d：
3。14159nextcol
i：-16
nextcol
d：3。14159
nextcol
i：
-16nextcol
d：
3。14159nextcol
i：
16nextcol
d：
3。14159nextcol
i：一#########16nextcol
d：#####3。14159nextcol
"1
第17章标准库特殊设施
setfill（ch）
setprecision（n）
setw（w）
setbase（b）
C
charch；
while（cin>>ch）
cout<<ch；
当给定下面输入序列时
ab
d
表17。18：定义在iomanip中的操纵符
用ch填充空白
将浮点精度设置为n
读或写值的宽度为w个字符
将整数输出为b进制
控制输入格式
默认情况下，输入运算符会忽略空白符（空格符、制表符､换行符、换纸符和回车符）。
下面的循环
循环会执行4次，读取字符a到d，跳过中间的空格以及可能的制表符和换行符。此程序
的输出是
abcd
操纵符noskipws会令输入运算符读取空白符，而不是跳过它们。为了恢复默认行
为，我们可以使用skipws操纵符：
cin>>noskipws；//设置cin读取空白符
while（cin>>ch）
cout<<ch；

Page699
17。5IO库再探
cin>>skipws；//将cin恢复到默认状态，从而丢弃空白符
给定与前一个程序相同的输入，此循环会执行7次，从输入中既读取普通字符又读取空白
符。此循环的输出为
ab
d
C
17。5。1节练习
练习17。34：编写一个程序，展示如何使用表17。17和表17。18中的每个操纵符。
练习17。35：修改第670页中的程序，打印2的平方根，但这次打印十六进制数字的大
写形式。
练习17。36：修改上一题中的程序，打印不同的浮点数，使它们排成一列。
17。5。2未格式化的输入/输出操作
到目前为止，我们的程序只使用过格式化IO（formattedIO）操作。输入和输出运算
符（<<和>>）根据读取或写入的数据类型来格式化它们。输入运算符忽略空白符，输出
运算符应用补白、精度等规则。
标准库还提供了一组低层操作，支持未格式化IO（unformattedIO）。这些操作允许我
们将一个流当作一个无解释的字节序列来处理。
单字节操作
有几个未格式化操作每次一个字节地处理流。这些操作列在表17。19中，它们会读取而
不是忽略空白符。例如，我们可以使用未格式化IO操作get和put来读取和写入一个字符：
charch；
while（cin。get（ch））
cout。put（ch）；
此程序保留输入中的空白符，其输出与输入完全相同。它的执行过程与前一个使用
noskipws的程序完全相同。
is。get（ch）
os。put（ch）
is。get（）
is。putback（ch）
is。unget（）
is。peek（）
表17。19：单字节低层IO操作
从istreamis读取下一个字节存入字符ch中。返回is
将字符ch输出到ostreamos。返回os
将is的下一个字节作为int返回
将字符ch放回is。返回is
将is向后移动一个字节。返回is
将下一个字节作为int返回，但不从流中删除它
将字符放回输入流
有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将
字符放回流中。标准库提供了三种方法退回字符，它们有着细微的差别：
•peek返回输入流中下一个字符的副本，但不会将它从流中删除，peek返回的值
仍然留在流中。
673
761

Page700
674
762
•unget使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最
后从流中读取什么值，仍然可以调用unget。
•putback是更特殊版本的unget：它退回从流中读取的最后一个值，但它接受一
个参数，此参数必须与最后读取的值相同。
一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即，标准库不
保证在中间不进行读取操作的情况下能连续调用putback或unget。
从输入操作返回的int值
函数peek和无参的get版本都以int类型从输入流返回一个字符。这有些令人吃
惊，可能这些函数返回一个char看起来会更自然。
这些函数返回一个int的原因是：可以返回文件尾标记。我们使用char范围中的每
个值来表示一个真实字符，因此，取值范围中没有额外的值可以用来表示文件尾。
返回int的函数将它们要返回的字符先转换为unsignedchar，然后再将结果提升
到int。因此，即使字符集中有字符映射到负值，这些操作返回的int也是正值（参见
2。1。2节，第32页）。而标准库使用负值表示文件尾，这样就可以保证与任何合法字符的值
都不同。头文件cstdio定义了一个名为EOF的const，我们可以用它来检测从get返
回的值是否是文件尾，而不必记忆表示文件尾的实际数值。对我们来说重要的是，用一个
int来保存从这些函数返回的值：
intch；//使用一个int，而不是一个char来保存get（）的返回值
//循环读取并输出输入中的所有数据
while（（ch
=
第17章标准库特殊设施
cin。get（））!=EOF）
cout。put（ch）；
此程序与第673页中的程序完成相同的工作，唯一的不同是用来读取输入的get版本不同。
多字节操作
一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些
操作是很重要的，但类似其他低层操作，这些操作也容易出错。特别是，这些操作要求我
们自己分配并管理用来保存和提取数据的字符数组（参见12。2节，第423页）。表17。20
列出了多字节操作。
表17。20：多字节低层IO操作
is。gcount（）
is。get（sink，size，delim）
从is中读取最多size个字节，并保存在字符数组中，字符数组的起始地址由sink给
出。读取过程直至遇到字符delim或读取了size个字节或遇到文件尾时停止。如果遇
到了delim，则将其留在输入流中，不读取出来存入sink
is。getline（sink，size，delim）
与接受三个参数的get版本类似，但会读取并丢弃delim
is。read（sink，size）
读取最多size个字节，存入字符数组sink中。返回is
返回上一个未格式化读取操作从is读取的字节数
os。write（source，size）
将字符数组source中的size个字节写入os。返回os

Page701
17。5IO库再探
续表
is。ignore（size，delim）
读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认
参数：size的默认值为1，delim的默认值为文件尾
get和getline函数接受相同的参数，它们的行为类似但不相同。在两个函数中，sink
都是一个char数组，用来保存数据。两个函数都一直读取数据，直至下面条件之一发生：
•已读取size-1个
•遇到了文件尾
•遇到了分隔符
两个函数的差别是处理分隔符的方式：get将分隔符留作istream中的下一个字符，而
getline则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在sink中。
一个常见的错误是本想从流中删除分隔符，但却忘了做。
WARNING
确定读取了多少个字符
某些操作从输入读取未知个数的字节。我们可以调用gcount来确定最后一个未格式
化输入操作读取了多少个字符。应该在任何后续未格式化输入操作之前调用gcount。特
别是，将字符退回流的单字符操作也属于未格式化输入操作。如果在调用gcount之前调
用了peek、unget或putback，则gcount的返回值为0。
小心：低层函数容易出错
一般情况下，我们主张使用标准库提供的高层抽象。返回int的IO操作很好地解
释了原因。
一个常见的编程错误是将get或peek的返回值赋予一个char而不是一个int。
这样做是错误的，但编译器却不能发现这个错误。最终会发生什么依赖于程序运行于哪
台机器以及输入数据是什么。例如，在一台char被实现为unsignedchar的机器上，
下面的循环永远不会停止：
charch；//此处使用char就是引入灾难!
//从cin。get返回的值被转换为char，然后与一个int比较
while（（ch=cin。get（））!=EOF）
cout。put（ch）；
问题出在当get返回EOF时，此值会被转换为一个unsignedchar。转换得到的值
与EOF的int值不再相等，因此循环永远也不会停止。这种错误很可能在调试时发现。
在一台char被实现为signedchar的机器上，我们不能确定循环的行为。当一
个越界的值被赋予一个signed变量时会发生什么完全取决于编译器。在很多机器上，
这个循环可以正常工作，除非输入序列中有一个字符与EOF值匹配。虽然在普通数据
中这种字符不太可能出现，但低层IO通常用于读取二进制值的场合，而这些二进制值
不能直接映射到普通字符和数值。例如，在我们的机器上，如果输入中包含有一个值
为'\377'的字符，则循环会提前终止。因为在我们的机器上，将-1转换为一个signed
char，就会得到377。如果输入中有这个值，则它会被（过早）当作文件尾指示符。
当我们读写有类型的值时，这种错误就不会发生。如果你可以使用标准库提供的类
型更加安全、更高层的操作，就应该使用它们。
675
763

Page702
676
765
17。5。2节练习
练习17。37：用未格式化版本的getline逐行读取一个文件。测试你的程序，给它一
个文件，既包含空行又包含长度超过你传递给getline的字符数组大小的行。
练习17。38：扩展上一题中你的程序，将读入的每个单词打印到它所在的行。
17。5。3流随机访问
各种流类型通常都支持对流中数据的随机访问。我们可以重定位流，使之跳过一些数
据，首先读取最后一行，然后读取第一行，依此类推｡标准库提供了一对函数，来定位（seek）
到流中给定的位置，以及告诉（tell）我们当前位置。
Note
第17章标准库特殊设施
随机IO本质上是依赖于系统的。为了理解如何使用这些特性，你必须查询系
统文档。
虽然标准库为所有流类型都定义了seek和tell函数，但它们是否会做有意义的事
情依赖于流绑定到哪个设备。在大多数系统中，绑定到cin、cout、cerr和clog的流
764不支持随机访问——毕竟，当我们向cout直接输出数据时，类似向回跳十个位置这种操
作是没有意义的。对这些流我们可以调用seek和tell函数，但在运行时会出错，将流
置于一个无效状态。
由于istream和ostream类型通常不支持随机访问，所以本节剩余内容只
WARNING适用于fstream和sstream类型。
seek和tell函数
为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。它
们还提供了两个函数：一个函数通过将标记seek到一个给定位置来重定位它；另一个函数
tell我们标记的当前位置标准库实际上定义了两对seek和tell函数，如表17。21所示。
一对用于输入流，另一对用于输出流｡输入和输出版本的差别在于名字的后缀是g还是p。
g版本表示我们正在“获得”（读取）数据，而p版本表示我们正在“放置”（写入）数据。
tellg（）
tellp（）
seekg（pos）
seekp（pos）
seekp（off，from）
seekg（off，from）
表17。21：seek和tell函数
返回一个输入流中（tellg）或输出流中（tellp）标记的当前
位置
在一个输入流或输出流中将标记重定位到给定的绝对地址。pos
通常是前一个tellg或tellp返回的值
在一个输入流或输出流中将标记定位到from之前或之后off个
字符，from可以是下列值之一
•beg，偏移量相对于流开始位置
•cur，偏移量相对于流当前位置
•end，偏移量相对于流结尾位置
从逻辑上讲，我们只能对istream和派生自istream的类型ifstream和
istringstream（参见8。1节，第278页）使用g版本，同样只能对ostream和派生
自ostream的类型ofstream和ostringstream使用p版本。一个iostream、

Page703
17。5IO库再探
fstream或stringstream既能读又能写关联的流，因此对这些类型的对象既能使用g
版本又能使用p版本。
只有一个标记
标准库区分seek和tell函数的“放置”和“获得”版本这一特性可能会导致误解。
即使标准库进行了区分，但它在一个流中只维护单一的标记——并不存在独立的读标记和
写标记。
当我们处理一个只读或只写的流时，两种版本的区别甚至是不明显的。我们可以对这
些流只使用g或只使用p版本。如果我们试图对一个ifstream流调用tellp，编译器
会报告错误。类似的，编译器也不允许我们对一个ostringstream调用seekg。
fstream和stringstream类型可以读写同一个流。在这些类型中，有单一的缓冲
区用于保存读写的数据，同样，标记也只有一个，表示缓冲区中的当前位置。标准库将g
和p版本的读写位置都映射到这个单一的标记。
Note
由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行seek操766
作来重定位标记。
重定位标记
seek函数有两个版本：一个移动到文件中的“绝对”地址；另一个移动到一个给定
位置的指定偏移量：
//将标记移动到一个固定位置
seekg（new_position）；//将读标记移动到指定的pos_type类型的位置
seekp（new_position）；//将写标记移动到指定的pos_type类型的位置
//移动到给定起始点之前或之后指定的偏移位置
seekg（offset，from）；//将读标记移动到距from偏移量为offset的位置
seekp（offset，from）；//将写标记移动到距from偏移量为offset的位置
from的可能值如表17。21所示。
参数new_position和offset的类型分别是pos_type和off_type，这两个类
型都是机器相关的，它们定义在头文件istream和ostream中。pos_type表示一个
文件位置，而off_type表示距当前位置的一个偏移量。一个off_type类型的值可以
是正的也可以是负的，即，我们可以在文件中向前移动或向后移动。
访问标记
函数tellg和tellp返回一个pos_type值，表示流的当前位置。tell函数通常
用来记住一个位置，以便稍后再定位回来：
//记住当前写位置
ostringstreamwriteStr；//输出stringstream
ostringstream：：pos_typemark=writeStr。tellp（）；
//
if（cancelEntry）
677
//回到刚才记住的位置
writeStr。seekp（mark）；

Page704
678
767
读写同一个文件
我们来考察一个编程实例。假定已经给定了一个要读取的文件，我们要在此文件的末
尾写入新的一行，这一行包含文件中每行的相对起始位置。例如，给定下面文件：
abcd
efg
hi
j
程序应该生成如下修改过的文件：
abcd
efg
hi
j
591214
注意，我们的程序不必输出第一行的偏移——它总是从位置0开始。还要注意，统计偏移
量时必须包含每行末尾不可见的换行符。最后，注意输出的最后一个数是我们的输出开始
那行的偏移量。在输出中包含了这些偏移量后，我们的输出就与文件的原始内容区分开来
了。我们可以读取结果文件中最后一个数，定位到对应偏移量，即可得到我们的输出的起
始地址。
我们的程序将逐行读取文件。对每一行，我们将递增计数器，将刚刚读取的一行的长
度加到计数器上，则此计数器即为下一行的起始地址：
intmain（）
{
//以读写方式打开文件，并定位到文件尾
//文件模式参数参见8。2。2节（第286页）
fstreaminOut（"copyOut"，
if（!inOut）{
第17章标准库特殊设施
}
fstream：：ate|fstream：：in|fstream：：out）；
cerr<<"Unabletoopenfile!"<<endl；
returnEXIT_FAILURE；//EXIT_FAILURE参见6。3。2节（第204页）
}
//inOut以ate模式打开，因此一开始就定义到其文件尾
autoend_mark=inOut。tellg（）；//记住原文件尾位置
inOut。seekg（0，fstream：：beg）；
sizetcnt=0；
stringline；
//继续读取的条件：还未遇到错误且还在读取原数据
while（inOut&&inOut。tellg（）!=end_mark
&&getline（inOut，line））{
cnt+=line。size（）+1；
automark=inOut。tellg（）；
inOut。seekp（0，fstream：：end）；
inOut<<cnt；
//如果不是最后一行，打印一个分隔符
if（mark!=end_mark）inOut<<
inOut。seekg（mark）；
inOut。seekp（0，fstream：：end）；
//重定位到文件开始
//字节数累加器
//保存输入中的每行
//且还可获取一行输入
//加1表示换行符
//记住读取位置
//将写标记移动到文件尾
//输出累计的长度
""；
//恢复读位置
//定位到文件尾

Page705
17。5IO库再探
inOut<<"\n"；
return0；
//在文件尾输出一个换行符
}
我们的程序用insout和ate模式（参见8。2。2节，第286页）打开fstream。前两个
模式指出我们想读写同一个文件。指定ate会将读写标记定位到文件尾。与往常一样，
我们检查文件是否成功打开，如果失败就退出（参见6。3。2节，第203页）。
由于我们的程序向输入文件写入数据，因此不能通过文件尾来判断是否停止读取，而
是应该在达到原数据的末尾时停止。因此，我们必须首先记住原文件尾的位置。由于我们
是以ate模式打开文件的，因此inOut已经定位到文件尾了。我们将当前位置（即，原
文件尾）保存在endmark中。记住文件尾位置之后，我们seek到距文件起始位置偏移
量为0的地方，即，将读标记重定位到文件起始位置。
while循环的条件由三部分组成：首先检查流是否合法；如果合法，通过比较当前读
位置（由tellg返回）和记录在endmark中的位置来检查是否读完了原数据；最后，
假定前两个检查都已成功，我们调用getline读取输入的下一行，如果getline成功，
则执行while循环体。
循环体首先将当前位置记录在mark中。我们保存当前位置是为了在输出下一个偏移
量后再退回来。接下来调用seekp将写标记重定位到文件尾。我们输出计数器的值，然
后调用seekg回到记录在mark中的位置。回退到原位置后，我们就准备好继续检查循
环条件了。
每步循环都会输出下一行的偏移量。因此，最后一步循环负责输出最后一行的偏移量。
但是，我们还需要在文件尾输出一个换行符。与其他写操作一样，在输出换行符之前我们
调用seekp来定位到文件尾。
17。5。3节练习
练习17。39：对本节给出的seek程序，编写你自己的版本。
679
768

Page706
680
769
小结
本章介绍了一些特殊IO操作和四个标准库类型：tuple、bitset、正则表达式和随
机数。
tuple是一个模板，允许我们将多个不同类型的成员捆绑成单一对象。每个tuple
包含指定数量的成员，但对一个给定的tuple类型，标准库并未限制我们可以定义的成
员数量上限。
bitset允许我们定义指定大小的二进制位集合。标准库不限制一个bitset的大小
必须与整型类型的大小匹配，bitset的大小可以更大。除了支持普通的位运算符（参见
4。8节，第136页）外，bitset还定义了一些命名的操作，允许我们操纵bitset中特
定位的状态。
第17章标准库特殊设施
正则表达式库提供了一组类和函数：regex类管理用某种正则表达式语言编写的正则
表达式。匹配类保存了某个特定匹配的相关信息。这些类被函数regex_search和
regex_match所用。这两个函数接受一个regex对象和一个字符序列，检查regex中
的正则表达式是否匹配给定的字符序列。regex迭代器类型是迭代器适配器，它们使用
regex_search遍历输入序列，返回每个匹配的子序列。标准库还定义了一个
regex_replace函数，允许我们用指定内容替换输入序列中与正则表达式匹配的部分。
随机数库由一组随机数引擎类和分布类组成。随机数引擎返回一个均匀分布的整型值
序列。标准库定义了多个引擎，它们具有不同的性能特点。default_random_engine
是适合于大多数普通情况的引擎。标准库还定义了20个分布类型。这些分布类型使用一
个引擎来生成指定类型的随机数，这些随机数的值都在给定范围内，且分布满足指定的概
率分布。
术语表
bitset标准库类，保存二进制位集合，大
小在编译时已知，并提供检测和设置集合
中二进制位的操作。
cmatchcsubmatch对象的容器，保存
一个regex与一个constchar*输入序
列匹配的相关信息。容器首元素描述了整
个匹配结果。后续元素描述了子表达式的
匹配结果。
cregex_iteratorsregex_iterator，
唯一的差别是此迭代器遍历一个char数组。
csub_match保存一个正则表达式与一个
constchar*匹配结果的类型。可以表示
整个匹配或子表达式的匹配。
默认随机数引擎（defaultrandomengine）
用于普通用途的随机数引擎的类型别名。
格式化IO（formattedIO）读写操作，利
用要读写的对象的类型来定义操作的行
770为。格式化输入操作执行适合要读取的类
型的转换操作，如将ASCII码字符串转换
为算术类型以及（默认地）忽略空白符。
格式化输出操作将类型转换为可打印的字
符表示形式、补白输出，还可能执行其他
与输出类型相关的转换。
get模板函数，返回给定tuple的指定成
员。例如，get<>（t）返回tuplet的第
一个成员。
高位（high-order）bitset中下标最大的
那些位。
低位（low-order）bitset中下标最小的
那些位。

Page707
术语表
操纵符（manipulator）“操纵”流的类函数
对象。操纵符可用作重载的IO运算符<<
和>>的右侧运算对象。大多数操纵符会改
变流对象的内部状态。这种操纵符通常是
成对的——一个改变状态，另一个恢复到
流的默认状态。
随机数分布（random-numberdistribution）
标准库类型，根据其名字所指出的概率分
布转换随机数引擎的输出值。例如，
uniform_int_distribution<T>生成
类型为T的均匀分布的整数，而
normal_distribution<T>生成正态分
布的值，依此类推。
随机数引擎（random-numberengine）标
准库类型，生成随机的无符号数。引擎的
设计意图是只用随机数分布的输入。
随机数发生器（random-number
generator）一个随机数引擎类型和一个
分布类型的组合。
regex管理正则表达式的类。
regex_error异常类型，当正则表达式中存
在语法错误时抛出此异常。
regex_match确定整个输入序列是否与
给定regex对象匹配的函数。
regex_replace使用一个regex对象来匹
配输入序列并用给定格式替换匹配的子表
达式的函数。
regex_search使用一个regex对象在给
定输入序列中查找匹配的子序列的函数。
正则表达式（regularexpression）一种描
述字符序列的方式。
种子（seed）提供给随机数引擎的值，使
引擎移动到生成的随机数序列中一个新的
点。
smatchssubmatch对象的容器，提供
一个regex与一个string输入序列匹配
的相关信息。容器首元素描述了整个匹配
结果。后续素描述了子表达式的匹配结
果。
sregex_iterator迭代器，使用给定的
regex对象遍历一个string来查找匹配
子串。其构造函数通过调用
regex_search将迭代器定位到第一个
匹配。递增迭代器的操作会调用
regex_search，从给定string中当前
匹配之后的位置开始查找匹配。解引用迭
代器返回一个描述当前匹配的smatch对
象。
ssub_match保存正则表达式与string
匹配结果的类型。可以描述整个匹配或子
表达式的匹配。
子表达式（subexpression）正则表达式
模式中用括号包围的组成部分。
tuple模板，生成的类型保存指定类型的未
命名成员。标准库没有限制一个tuple最
多可以包含多少个成员。
未格式化IO（unformattedIO）将流当作
无差别的字节流来处理的操作。未格式化
操作给用户增加了很多管理IO的负担。
681

Page708


Page709
第18章
用于大型程序的工具
内容
18。1异常处理
18。2命名空间。
18。3多重继承与虚继承
小结
术语表。。
684
695
710
722
722
C++语言能解决的问题规模千变万化，有的小到一个程序员几小时就能完成，有的则
是含有几千几万行代码的庞大系统，需要几百个程序员协同工作好几年。本书之前介绍的
内容对各种规模的编程问题都适用。
除此之外，C++语言还包含其他一些特征，当我们编写比较复杂的、小组和个人难以
管理的系统时，这些特征最为有用。本章的主题即是向读者介绍这些特征，它们包括异常
处理、命名空间和多重继承。
771

Page710
684
772
第18章用于大型程序的工具
与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更
高。大规模应用程序的特殊要求包括：
在独立开发的子系统之间协同处理错误的能力。
使用各种库（可能包含独立开发的库）进行协同开发的能力。
•对比较复杂的应用概念建模的能力。
本章介绍的三种C++语言特性正好能满足上述要求，它们是：异常处理、命名空间和
多重继承。
18。1异常处理
异常处理（exceptionhandling）机制允许程序中独立开发的部分能够在运行时就出现
的问题进行通信并做出相应的处理。异常使得我们能够将问题的检测与解决过程分离开
来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。
检测环节无须知道问题处理模块的所有细节，反之亦然。
在5。6节（第173页）我们曾介绍过一些有关异常处理的基本概念和机理，本节将继
续扩展这些知识。对于程序员来说，要想有效地使用异常处理，必须首先了解当抛出异常
时发生了什么，捕获异常时发生了什么，以及用来传递错误的对象的意义。
18。1。1抛出异常
在C++语言中，我们通过抛出（throwing）一条表达式来引发（raised）一个异常。被
抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码（handler）将被用来处理
该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，
根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么
错误。
当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权
从throw转移到与之匹配的catch模块｡该catch可能是同一个函数中的局部catch，
也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一
处，这有两个重要的含义：
沿着调用链的函数可能会提早退出。
一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。
因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return
语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。
773栈展开
当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的
catch子句。当throw出现在一个try语句块（tryblock）内时，检查与该try块关联
的catch子句。如果找到了匹配的catch，就使用该catch处理异常。如果这一步没找
到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的
catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外
层函数中继续寻找。
如果对抛出异常的函数的调用语句位于一个try语句块内，则检查与该try块关联

Page711
18。1异常处理
的catch子句。如果找到了匹配的catch，就使用该catch处理异常。否则，如果该
try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果仍然没
有找到匹配的catch，则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其
他函数中寻找，以此类推。
上述过程被称为栈展开（stackunwinding）过程。栈展开过程沿着嵌套函数的调用链
不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配的
catch，则退出主函数后查找过程终止。
假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行
完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里
继续执行。
如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常
执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch
时，程序将调用标准库函数terminate，顾名思义，terminate负责终止程序的执行
过程。
Note一个异常如果没有被捕获，则它将终止当前的程序。
栈展开过程中对象被自动销毁
在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些
块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也将随之销毁，这条规
则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这
个块中创建的对象能被正确地销毁。如果某个局部对象的类型是类类型，则该对象的析构
函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何事情。
如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始
化了，而另外一些成员在异常发生前也许还没有初始化。即使某个对象只构造了一部分，
我们也要确保已构造的成员能被正确地销毁。
类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如
果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。
析构函数与异常
析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，这一特点
对于我们如何组织程序结构有重要影响。如我们在12。1。4节（第415页）介绍过的，如果
一个块分配了资源，并且在负责释放这些资源的代码前面发生了异常，则释放资源的代码
将不会被执行。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我
们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确
地释放。
析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。在栈展
开的过程中，已经引发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获，
则系统将调用terminate函数。因此，出于栈展开可能使用析构函数的考虑，析构函数
不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异
常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到处理。
685
774

Page712
686
775
第18章用于大型程序的工具
在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所
有标准库类型都能确保它们的析构函数不会引发异常。
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是
自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数拋出
WARNING了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。
异常对象
异常对象（exceptionobject）是一种特殊的对象，编译器使用异常抛出表达式来对异
常对象进行拷贝初始化（参见13。1。1节，第441页）。因此，throw语句中的表达式必须
拥有完全类型（参见7。3。3节，第250页）。而且如果该表达式是类类型的话，则相应的类
必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数
组类型或函数类型，则表达式将被转换成与之对应的指针类型。
异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子
句都能访问该空间。当异常处理完毕后，异常对象被销毁。
如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配
的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个
指向局部对象的指针几乎肯定是一种错误的行为。出于同样的原因，从函数中返回指向局
部对象的指针也是错误的（参见6。3。2节，第202页）。如果指针所指的对象位于某个块中，
而该块在catch语句之前就已经退出了，则意味着在执行catch语句之前局部对象已经
被销毁了。
当我们抛出一条表达式时，该表达式的静态编译时类型（参见15。2。3节，第534页）
决定了异常对象的类型。读者必须牢记这一点，因为很多情况下程序拋出的表达式类型来
自于某个继承体系。如果一条throw表达式解引用一个基类指针，而该指针实际指向的
是派生类对象，则抛出的对象将被切掉一部分（参见15。2。3节，第535页），只有基类部
分被抛出。
抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。
WARNING
18。1。1节练习
练习18。1：在下列throw语句中异常对象的类型是什么?
（a）range_errorr（"error"）；
（b）exception*p&r；
throw*p；
throwr；
如果将（b）中的throw语句写成了throwp将发生什么情况?
练习18。2：当在指定的位置发生了异常时将出现什么情况?
voidexercise（int*b，int*e）
{
vector<int>v（b，e）；
int*p=newint[v。size（）]；
ifstreamin（"ints"）；
//此处发生异常

Page713
18。1异常处理
练习18。3：要想让上面的代码在发生异常时能正常工作，有两种解决方案。请描述这两
种方法并实现它们。
18。1。2捕获异常
catch子句（catchclause）中的异常声明（exceptiondeclaration）看起来像是只包含
一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的
话，则我们可以忽略捕获形参的名字。
声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型（参见
7。3。3节，第250页），它可以是左值引用，但不能是右值引用（参见13。6。1节，第471页）。
当进入一个catch语句后，通过异常对象初始化异常声明中的参数。和函数的参数
类似，如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本，在catch
语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类
型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异
常对象。
catch的参数还有一个特性也与函数的参数非常类似：如果catch的参数是基类类
型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果catch的参
数是非引用类型，则异常对象将被切掉一部分（参见15。2。3节，第535页），这与将派生776
类对象以值传递的方式传给一个普通函数差不多。另一方面，如果catch的参数是基类
的引用，则该参数将以常规方式绑定到异常对象上。
最后一点需要注意的是，异常声明的静态类型将决定catch语句所能执行的操作。
如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。
Practices
Best通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch
的参数定义成引用类型。
查找匹配的处理代码
在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配｡相反，
挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置
于整个catch列表的前端。
因为catch语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关
系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码
出现在基类异常的处理代码之前。
与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。
此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和
catch声明的类型是精确匹配的：
许从非常量向常量的类型转换，也就是说，一条非常量对象的throw语句可以
匹配一个接受常量引用的catch语句。
•允许从派生类向基类的类型转换。
●
数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。
除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配
687
●

Page714
688
catch的过程中使用。
Note
重新拋出
有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之
后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句
通过重新拋出（rethrowing）的操作将异常传递给另外一个catch语句。这里的重新拋出
仍然是一条throw语句，只不过不包含任何表达式：
throw；
如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最
底端的类（mostderivedtype）放在前面，而将继承链最顶端的类（leastderived
type）放在后面。
777空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如
果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。
一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上
传递。
很多时候，catch语句会改变其参数的内容。如果在改变了参数的内容后catch语
句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所做的改变才会被
保留并继续传播：
catch（my_error&eObj）{
}
}catch（other_erroreObj）{
第18章用于大型程序的工具
eObj。status=errCodes：：severeErr；
throw；
}
eObj。status=errCodes：：badErr；
throw；
voidmanip（）{
try{
//引用类型
//修改了异常对象
//异常对象的status成员是severeErr
//非引用类型
//只修改了异常对象的局部副本
捕获所有异常的处理代码
有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。要想捕获所有可
能的异常是比较有难度的，毕竟有些情况下我们也不知道异常的类型到底是什么。即使我
们知道所有的异常类型，也很难为所有类型提供唯一一个catch语句。为了一次性捕获
所有异常，我们使用省略号作为异常声明，这样的处理代码称为捕获所有异常（catch-all）
的处理代码，形如catch（。。。）。一条捕获所有异常的语句可以与任意类型的异常匹配。
//异常对象的status成员没有改变
catch（。。。）通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工
作，随后重新抛出异常：
}
catch（。。。）{
//这里的操作将引发并抛出一个异常
//处理异常的某些特殊操作
throw；

Page715
18。1异常处理
catch（。。。）既能单独出现，也能与其他几个catch语句一起出现。
如果catch（。。。）与其他几个catch语句一起出现，则catch（。。。）必须在
最后的位置。出现在捕获所有异常语句后面的catch语句将永远不会被匹配。
Note
18。1。2节练习
练习18。4：查看图18。1（第693页）所示的继承体系，说明下面的try块有何错误并
修改它。
try{
//使用C++标准库
}catch（exception）{
//
}catch（construntime_error&re）{
//。。
}catch（overflow_erroreobj）{/**/}
练习18。5：修改下面的main函数，使其能捕获图18。1（第693页）所示的任何异常类
型：
intmain（）{
//使用C++标准库
}
处理代码应该首先打印异常相关的错误信息，然后调用abort（定义在cstdlib头文
件中）终止main函数。
练习18。6：已知下面的异常类型和catch语句，书写一个throw表达式使其创建的异
常对象能被这些catch语句捕获：
（a）classexceptionType{}；
catch（exceptionType*pet）{}
（b）catch（。。。）{}
（c）typedefintEXCPTYPE；
catch（EXCPTYPE）{}
18。1。3函数try语句块与构造函数
通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在处理构造
函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值778
列表抛出异常时构造函数体内的try语句块还未生效，所以构造函数体内的catch语句
无法处理构造函数初始值列表抛出的异常。
要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数try语句块（也
称为函数测试块，functiontryblock）的形式。函数try语句块使得一组catch语句既能
处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构
过程）。举个例子，我们可以把Blob的构造函数（参见16。1。2节，第586页）置于一个
函数try语句块中：
689
template<typenameT>
Blob<T>：：Blob（std：：initializer_list<T>il）try：

Page716
690
779
780
data（std：：make_shared<std：：vector<T>>（il））{
/*空函数体*/
}catch（conststd：：bad_alloc&e）{handle_out_of_memory（e）；}
第18章用于大型程序的工具
注意：关键字try出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为
空）的花括号之前。与这个try关联的catch既能处理构造函数体抛出的异常，也能处
理成员初始化列表抛出的异常。
还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生异常，这样的异
常不属于函数try语句块的一部分。函数try语句块只能处理构造函数开始执行后发生
的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调
用表达式的一部分，并将在调用者所在的上下文中处理。
Note
处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。
18。1。3节练习
练习18。7：根据第16章的介绍定义你自己的Blob和BlobPtr，注意将构造函数写成
函数try语句块。
18。1。4noexcept异常说明
对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道
函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异
常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。
在C++11新标准中，我们可以通过提供noexcept说明（noexceptspecification）指
[C++]定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面，用
以标识该函数不会抛出异常：
11
voidrecoup（int）noexcept；
voidalloc（int）；
//不会抛出异常
//可能抛出异常
这两条声明语句指出recoup将不会抛出任何异常，而alloc可能抛出异常。我们说
recoup做了不抛出说明（nonthrowingspecification）。
对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句
中，要么一次也不出现。该说明应该在函数的尾置返回类型（参见6。3。3节，第206页）
之前。我们也可以在函数指针的声明和定义中指定noexcept。在typedef或类型别名
中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限
定符之后，而在final、override或虚函数的=0之前。
违反异常说明
读者需要清楚的一个事实是编译器并不会在编译时检查noexcept说明。实际上，
如果一个函数在说明了noexcept的同时又含有throw语句或者调用了可能抛出异常的
其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错（不排除
个别编译器会对这种用法提出警告）：
//尽管该函数明显违反了异常说明，但它仍然可以顺利编译通过
voidf（）noexcept
//承诺不会抛出异常
{

Page717
18。1异常处理
throwexception（）；
//违反了异常说明
}
因此可能出现这样一种情况：尽管函数声明了它不会抛出异常，但实际上还是抛出了。
一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时
抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此noexcept可以用在两种
情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常。
指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是
函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。
通常情况下，编译器不能也不必在编译时验证异常说明。
WARNING
向后兼容：异常说明
早期的C++版本设计了一套更加详细的异常说明方案，该方案使得我们可以指定某
个函数可能抛出的异常类型。函数可以指定一个关键字throw，在后面跟上括号括起来
的异常类型列表othrow说明符所在的位置与新版本C++中noexcept所在的位置相同。
上述使用throw的异常说明方案在C++11新版本中已经被取消了。然而尽管如此，
它还有一个重要的用处。如果函数被设计为是throw（）的，则意味着该函数将不会抛
出异常：
voidrecoup（int）noexcept；
voidrecoup（int）throw（）；
上面的两条声明语句是等价的，它们都承诺recoup不会抛出异常。
//recoup不会抛出异常
//等价的声明
异常说明的实参
noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参
是true，则函数不会抛出异常；如果实参是false，则函数可能抛出异常：
voidrecoup（int）noexcept（true）；
voidalloc（int）noexcept（false）；
//recoup不会抛出异常
//alloc可能抛出异常
noexcept运算符
noexcept说明符的实参常常与noexcept运算符（noexceptoperator）混合使用。
noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，
用于表示给定的表达式是否会抛出异常。和sizeof（参见4。9节，第139页）类似，
noexcept也不会求其运算对象的值。
例如，因为我们声明recoup时使用了noexcept说明符，所以下面的表达式的返
回值为true：
noexcept（recoup（i））//如果recoup不抛出异常则结果为true；否则结果为false
更普通的形式是：
noexcept（e）
当e调用的所有函数都做了不抛出说明且e本身不含有throw语句时，上述表达式为
true；否则noexcept（e）返回false。
691
C++
11
781

Page718
692
782
我们可以使用noexcept运算符得到如下的异常说明：
voidf（）noexcept（noexcept（g（）））；//f和g的异常说明一致
如果函数g承诺了不会抛出异常，则f也不会抛出异常；如果g没有异常说明符，或者g
虽然有异常说明符但是允许抛出异常，则f也可能抛出异常。
Note
noexcept有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作
为noexcept异常说明的bool实参出现时，它是一个运算符。
异常说明与指针、虚函数和拷贝控制
尽管noexcept说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响
函数的使用。
函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个
指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显
式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出
异常的函数也可以：
第18章用于大型程序的工具
//recoup和pf1都承诺不会抛出异常
void（*pfl）（int）noexcept=recoup；
//正确：recoup不会抛出异常，pf2可能抛出异常，二者之间互不干扰
void（*pf2）（int）=recoup；
pf1=alloc；
pf2
=alloc；
classBase{
public：
//错误：alloc可能抛出异常，但是pf1已经说明了它不会抛出异常
//正确：pf2和alloc都可能抛出异常
如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的
承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出
异常，也可以不允许抛出异常：
virtualdoublef1（double）noexcept；
virtualintf2（）noexcept（false）；
virtualvoidf3（）；
classDerived：publicBase{
public：
doublefl（double）；
intf2（）noexcept（false）；
voidf3（）noexcept；
//不会抛出异常
//可能抛出异常
//可能抛出异常
//错误：Base：：f1承诺不会抛出异常
//正确：与Base：：f2的异常说明一致
//正确：Derived的f3做了更严格的限定，
//这是允许的
}；
当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的
所有操作都承诺了不会抛出异常，则合成的成员是noexcept的。如果合成成员调用的
任意一个函数可能抛出异常，则合成的成员是noexcept（false）。而且，如果我们定义
了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与
假设由编译器为类合成析构函数时所得的异常说明一致。

Page719
18。1异常处理
18。1。4节练习
练习18。8：回顾你之前编写的各个类，为它们的构造函数和析构函数添加正确的异常说
明。如果你认为某个析构函数可能抛出异常，尝试修改代码使得该析构函数不会抛出异
常。
18。1。5异常类层次
标准库异常类（参见5。6。3节，第176页）构成了图18。1所示的继承体系（参见第15章）。
bad_cast
runtimeerror
overflowerror
underflow_error
exception
range_error
badalloc
logic_error
domainerror
invalid_argument
outofrange
length_error
图18。1：标准exception类层次
类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一
个名为what的虚成员。其中what函数返回一个constchar*，该指针指向一个以unll
结尾的字符数组，并且确保不会抛出任何异常。
类exception、bad_cast和bad_alloc定义了默认构造函数。类
runtime_error和logic_error没有默认构造函数，但是有一个可以接受C风格字
符串或者标准库string类型实参的构造函数，这些实参负责提供关于错误的更多信息。
在这些类中，what负责返回用于初始化异常对象的信息。因为what是虚函数，所以当
我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本。
书店应用程序的异常类
实际的应用程序通常会自定义exception（或者exception的标准库派生类）的
派生类以扩展其继承体系。这些面向应用的异常类表示了与应用相关的异常条件。
如果我们构建的是一个真实的书店应用程序，则其中的类将比本书之前所示的复杂得
多。复杂性的一个方面就是如何处理异常。实际上，我们很可能需要建立一个自己的异常
693
783

Page720
694
类体系，用它来表示与应用相关的各种问题。我们设计的异常类可能如下所示：
//为某个书店应用程序设定的异常类
classout_of_stock：publicstd：：runtime_error{
public：
}；
第18章用于大型程序的工具
}；
classisbn_mismatch：publicstd：：logic_error{
public：
explicitout_of_stock（conststd：：string&s）：
std：：runtime_error（s）{}
explicitisbn_mismatch（conststd：：string&s）：
std：：logic_error（s）{}
isbn_mismatch（conststd：：string&s，
conststd：：string&lhs，conststd：：string&rhs）：
std：：logic_error（s），left（lhs），right（rhs）{}
conststd：：stringleft，right；
784由上可知，我们的面向应用的异常类继承自标准异常类。和其他继承体系一样，异常类也
可以看作按照层次关系组织的。层次越低，表示的异常情况就越特殊。例如，在异常类继
承体系中位于最顶层的通常是exception，exception表示的含义是某处出错了，至
于错误的细节则未作描述。
继承体系的第二层将exception划分为两个大的类别：运行时错误和逻辑错误。运
行时错误表示的是只有在程序运行时才能检测到的错误；而逻辑错误一般指的是我们可以
在程序代码中发现的错误。
我们的书店应用程序进一步细分上述异常类别。名为out_of_stock的类表示在运
行时可能发生的错误，比如某些顺序无法满足；名为isbnmismatch的类表示
logic_error的一个特例，程序可以通过比较对象的isbn（）结果来阻止或处理这一
错误。
{
使用我们自己的异常类型
我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异
常类型的对象，在另外的地方捕获并处理这些出现的问题。举个例子，我们可以为
Salesdata类定义一个复合加法运算符，当检测到参与加法的两个ISBN编号不一致时
抛出名为isbn_mismatch的异常：
//如果参与加法的两个对象并非同一书籍，则抛出一个异常
Salesdata&
Sales_data：：operator+=（constSales_data&rhs）
if（isbn（）!=rhs。isbn（））
throwisbn_mismatch（"wrongisbns"，isbn（），rhs。isbn（））；
units_sold+=rhs。units_sold；
revenue+=rhs。revenue；
return*this；
}
使用了复合加法运算符的代码将能检测到这一错误，进而输出一条相应的错误信息并继续
完成其他任务：

Page721
18。2命名空间
//使用之前设定的书店程序异常类
Salesdataiteml，item2，sum；
while（cin>>item1>>item2）{
try{
sum=iteml+item2；
//此处使用sum
}catch（constisbnmismatch&e）{
cerr<<e。what（）<<"：leftisbn（"<<e。left
//读取两条交易信息
//计算它们的和
<<"）rightisbn（"<<e。right<<"）"<<endl；
18。1。5节练习
练习18。9：定义本节描述的书店程序异常类，然后为Sales_data类重新编写一个复
合赋值运算符并令其抛出一个异常。
练习18。10：编写程序令其对两个ISBN编号不相同的对象执行Salesdata的加法运
算。为该程序编写两个不同的版本：一个处理异常，另一个不处理异常。观察并比较这
两个程序的行为，用心体会当出现了一个未被捕获的异常时程序会发生什么情况。
练习18。11：为什么what函数不应该抛出异常?
18。2命名空间
大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函
数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲
突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染（namespace
pollution）。
传统上，程序员通过将其定义的全局实体名字设得很长来避免命名空间污染问题，这
样的名字中通常包含表示名字所属库的前缀部分：
classcplusplus_primer_Query{。。。}；
stringcplusplus_primer_make_plural（size_t，string&）；
这种解决方案显然不太理想：对于程序员来说，书写和阅读这么长的名字费时费力且过于
烦琐。
命名空间（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全
局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库
的作者（以及用户）可以避免全局名字固有的限制。
18。2。1命名空间定义
一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名
字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用
域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其
定义）、模板和其他命名空间：
namespacecplusplus_primer{
classSales_data{/*。。。*/}；
695
785

Page722
696
786
classQuery{/*。。。*/}；
classQuery_base{/*。。。*/}；
}//命名空间结束后无须分号，这一点与块类似
Sales_dataoperator+（constSales_data&，
constSalesdata&）；
上面的代码定义了一个名为cplusplus_primer的命名空间，该命名空间包含四个成
员：三个类和一个重载的运算符。
Note
第18章用于大型程序的工具
和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可
以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。
命名空间作用域后面无须分号。
每个命名空间都是一个作用域
和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不
同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。
定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这
些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的
名字属于哪个命名空间：
cplusplus_primer：：Queryq=
cplusplus_primer：：Query（"hello"）；
如果其他命名空间（比如说AddisonWesley）也提供了一个名为Query的类，并
且我们希望使用这个类替代cplusplus_primer中定义的同名类，则可以按照如下方式
修改代码：
AddisonWesley：：Queryq=AddisonWesley：：Query（"hello"）；
命名空间可以是不连续的
如我们在16。5节（第626页）介绍过的，命名空间可以定义在几个不同的部分，这一
点与其他作用域不太一样。编写如下的命名空间定义：
namespacensp{
//相关声明
}
可能是定义了一个名为nsp的新命名空间，也可能是为已经存在的命名空间添加一些新
成员。如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否
则，上述代码打开已经存在的命名空间定义并为其添加一些新成员的声明。
命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成
一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：
•命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这
些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。
•命名空间成员的定义部分则置于另外的源文件中。
787在程序中某些实体只能定义一次；如非内联函数、静态数据成员、变量等，命名空间中定
义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种
接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实

Page723
18。2命名空间
体的地方都能看到对于实体名字的声明。
Best
Practices
定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关
联类型构成的集合）。
定义本书的命名空间
通过使用上述接口与实现分离的机制，我们可以将cplusplus_primer库定义在几
个不同的文件中。Sales_data类的声明及其函数将置于Sales_data。h头文件中，第
15章介绍的Query类将置于Query。h头文件中，以此类推。对应的实现文件将分别是
Salesdata。ccllQuery。cc：
//----Salesdata。h
//#include应该出现在打开命名空间的操作之前
#include<string>
namespacecplusplus_primer{
classSales_data{/*。。。*/}；
Sales_dataoperator+（constSales_data&，
constSales_data&）；
//Sales_data的其他接口函数的声明
}
//
Salesdata。cc----
//确保#include出现在打开命名空间的操作之前
#include"Sales_data。h"
namespacecplusplus_primer{
//Sales_data成员及重载运算符的定义
}
程序如果想使用我们定义的库，必须包含必要的头文件，这些头文件中的名字定义在
命名空间cplusplus_primer内：
//
-user。CC-
//Sales_data。h头文件的名字位于命名空间cplusplus_primer中
#include"Salesdata。h"
intmain（）
{
usingcplusplus_primer：：Sales_data；
Salesdatatransl，trans2；
//。。。
return0；
这种程序的组织方式提供了开发者和库用户所需的模块性。每个类仍组织在自己的接口和
实现文件中，一个类的用户不必编译与其他类相关的名字。我们对用户隐藏了实现细节，
同时允许文件Salesdata。cc和user。cc被编译并链接成一个程序而不会产生任何编
译时错误或链接时错误。库的开发者可以分别实现每一个类，相互之间没有干扰。
有一点需要注意，在通常情况下，我们不把#include放在命名空间内部。如果我们
这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。例如，如果
Salesdata。h在包含string头文件前就已经打开了命名空间cplusplus_primer，
则程序将出错，因为这么做意味着我们试图将命名空间std嵌套在命名空间
cplusplus_primer中。
697
788

Page724
698
定义命名空间成员
假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义
的名字的简写形式：
#include"Salesdata。h"
namespacecplusplus_primer{
//命名空间中定义的成员可以直接使用名字，此时无须前缀
std：：istream&
operator>>（std：：istream&in，Sales_data&s）{/*。。。*/}
}
也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须
在作用域内，同时该名字的定义需要明确指出其所属的命名空间：
//命名空间之外定义的成员必须使用含有前缀的名字
cplusplus_primer：：Sales_data
{
cplusplus_primer：：operator+（constSales_data&lhs，
constSalesdata&rhs）。
//重新打开命名空间cplusplus_primer
第18章用于大型程序的工具
Salesdataret（lhs）；
//
}
和定义在类外部的类成员一样，一旦看到含有完整前缀的名字，我们就可以确定该名字位
于命名空间的作用域内。在命名空间cplusplus_primer内部，我们可以直接使用该命
名空间的其他成员，比如在上面的代码中，可以直接使用Salesdata定义函数的形参。
尽管命名空间的成员可以定义在命名空间外部，但是这样的定义必须出现在所属命名
空间的外层空间中。换句话说，我们可以在cplusplus_primer或全局作用域中定义
Sales_dataoperator+，但是不能在一个不相关的作用域中定义这个运算符。
模板特例化
模板特例化必须定义在原始模板所属的命名空间中（参见16。5节，第626页）。和其
789他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了：
//我们必须将模板特例化声明成std的成员
namespacestd{
{
}；
template<>structhash<Sales_data>；
}
//在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了
template<>structstd：：hash<Sales_data>
size_toperator（）（constSales_data&s）const
{returnhash<string>（）（s。bookNo）
//其他成员与之前的版本一致
A
hash<unsigned>（）（s。units_sold）
hash<double>（）（s。revenue）；}
全局命名空间
全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定
义在全局命名空间（globalnamespace）中。全局命名空间以隐式的方式声明，并且在所有

Page725
18。2命名空间
程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。
作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并
没有名字。下面的形式
：：membername。
表示全局命名空间中的一个成员。
嵌套的命名空间
嵌套的命名空间是指定义在其他命名空间中的命名空间：
namespacecplusplus_primer{
//第一个嵌套的命名空间：定义了库的Query部分
namespaceQueryLib{
classQuery{/**/}；
Queryoperator&（constQuery&，constQuery&）；
//
}
//第二个嵌套的命名空间：定义了库的Sales_data部分
namespaceBookstore{
上面的代码将命名空间cplusplus_primer分割为两个嵌套的命名空间，分别是
QueryLibllBookstore。
}
classQuote{/*。。。*/}；
classDisc_quote：publicQuote{/*
//。。。
嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套790
的命名空间中的名字遵循的规则与往常类似：内层命名空间声明的名字将隐藏外层命名空
间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名
空间中的代码要想访问它必须在名字前添加限定符。例如，在嵌套的命名空间QueryLib
中声明的类名是
cplusplus_primer：：QueryLib：：Query
}
内联命名空间
11
C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间（inlinenamespace）。C++
和普通的嵌套命名空间不同，內联命名空间中的名字可以被外层命名空间直接使用。也就
是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间
的名字就可以直接访问它。
定义内联命名空间的方式是在关键字namespace前添加关键字inline：
inlinenamespaceFifthEd{
//该命名空间表示本书第5版的代码
namespaceFifthEd{
699
classQuery_base{/*
//其他与Query有关的声明
//隐式内联
*/}；

Page726
700
关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以
写inline，也可以不写。
当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名
空间。例如，我们可以把本书当前版本的所有代码都放在一个内联命名空间中，而之前版
本的代码都放在一个非内联命名空间中：
namespaceFourthEd{
}
命名空间cplusplus_primer将同时使用这两个命名空间。例如，假定每个命名空间都
定义在同名的头文件中，则我们可以把命名空间cplusplus_primer定义成如下形式：
namespacecplusplus_primer{
#include"FifthEd。h"
#include"FourthEd。h"
}
classItem_base{/*。。。*/}；
classQuery_base{/*。。。*/}；
//本书第4版用到的其他代码
第18章用于大型程序的工具
791因为Fifthed是内联的，所以形如cplusplus_primer：：的代码可以直接获得
Fifthed的成员。如果我们想使用早期版本的代码，则必须像其他嵌套的命名空间一样
加上完整的外层命名空间名字，比如cplusplus_primer：：FourthEd：：Query_base。
未命名的命名空间
未命名的命名空间（unnamednamespace）是指关键字namespace后紧跟花括号括起
来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次
使用前创建，并且直到程序结束才销毁。
Note
一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每
个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个
空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的
是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在
每个包含了该头文件的文件中对应不同实体。
和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范
围不会横跨多个不同的文件。
定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名
字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。
}
未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命
名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域
中的名字有所区别：
inti；
namespace{
inti；
//i的全局声明

Page727
18。2命名空间
//二叉性：i的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中
i=10；
其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似，
一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员
可以通过外层命名空间的名字来访问：
namespacelocal{
namespace{
inti；
}
}
//正确：定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同
local：：j=42；
未命名的命名空间取代文件中的静态声明
在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其
对于整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言
中，声明为static的全局实体在其所在的文件外不可见。
在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命
WARNING名的命名空间。
18。2。1节练习
练习18。12：将你为之前各章练习编写的程序放置在各自的命名空间中。也就是说，命
名空间chapter15包含Query程序的代码，命名空间chapter10包含TextQuery
的代码；使用这种结构重新编译Query代码示例。
练习18。13：什么时候应该使用未命名的命名空间?
练习18。14：假设下面的operator*声明的是嵌套的命名空间mathLib：：MatrixLib
的一个成员：
namespacemathLib{
}
namespaceMatrixLib{
classmatrix{/*
matrixoperator*
//
。。。
*/}；
（constmatrix&，constmatrix&）；
请问你应该如何在全局作用域中声明该运算符?
18。2。2使用命名空间成员
像namespace_name：：member_name这样使用命名空间的成员显然非常烦琐，特
别是当命名空间的名字很长时尤其如此。幸运的是，我们可以通过一些其他更简便的方法
使用命名空间的成员。之前的程序已经使用过其中一种方法，即using声明（参见3。1
节，第74页）。本节还将介绍另外几种方法，如命名空间的别名以及using指示等。
701
792

Page728
702
793
第18章用于大型程序的工具
命名空间的别名
命名空间的别名（namespacealias）使得我们可以为命名空间的名字设定一个短得多
的同义词。例如，一个很长的命名空间的名字形如
namespacecplusplus_primer{/*。。。*/}；
我们可以为其设定一个短得多的同义词：
namespaceprimercplusplus_primer；
命名空间的别名声明以关键字namespace开始，后面是别名所用的名字、=符号、命名
空间原来的名字以及一个分号。不能在命名空间还没有定义前就声明别名，否则将产生
错误。
命名空间的别名也可以指向一个嵌套的命名空间：
namespaceQlibcplusplus_primer：：QueryLib；
Qlib：：Querygi
一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字
Note等价。
using声明：扼要概述
一条using声明（usingdeclaration）语句一次只引入命名空间的一个成员。它使得
我们可以清楚地知道程序中所用的到底是哪个名字。
using声明引入的名字遵守与过去一样的作用域规则：它的有效范围从using声明
的地方开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同
名实体将被隐藏。未加限定的名字只能在using声明所在的作用域以及其内层作用域中
使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。
一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类
的作用域中。在类的作用域中，这样的声明语句只能指向基类成员（参见15。5节，第546页）。
using指示
using指示（usingdirective）和using声明类似的地方是，我们可以使用命名空间
名字的简写形式；和using声明不同的地方是，我们无法控制哪些名字是可见的，因为
所有名字都是可见的。
using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。
如果这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误。using
指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用
域中。
using指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们
添加任何前缀限定符了。简写的名字从using指示开始，一直到using指示所在的作用
域结束都能使用。
WARNING
如果我们提供了一个对std等命名空间的using指示而未做任何特殊控制的
话，将重新引入由于使用了多个库而造成的名字冲突问题。

Page729
18。2命名空间
using指示与作用域
using指示引入的名字的作用域远比using声明引入的名字的作用域复杂。如我们
所知，using声明的名字的作用域与using声明语句本身的作用域一致，从效果上看就
好像using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。
using指示所做的绝非声明别名这么简单。相反，它具有将命名空间成员提升到包含
命名空间本身和using指示的最近作用域的能力。
using声明和using指示在作用域上的区别直接决定了它们工作方式的不同。对于
using声明来说，我们只是简单地令名字在局部作用域内有效。相反，using指示是令
整个命名空间的所有內容变得有效。通常情况下，命名空间中会含有一些不能出现在局部
作用域中的定义，因此，using指示一般被看作是出现在最近的外层作用域中。
在最简单的情况下，假定我们有一个命名空间A和一个函数f，它们都定义在全局作
用域中。如果f含有一个对A的using指示，则在f看来，A中的名字仿佛是出现在全
局作用域中f之前的位置一样：
//命名空间A和函数f定义在全局作用域中
namespaceA{
inti，j；
}
voidf（）
{
}
usingnamespaceA；
cout<<i*j<<endl；
//
using指示示例
让我们看一个简单的示例：
namespaceblip{
inti=16，j=15，k=23；
//其他声明
}
intj0；
voidmanip（）
{
//把A中的名字注入到全局作用域中
//使用命名空间A中的i和j
++blip：：j；
intk=97；
++k；
//正确：blip的j隐藏在命名空间中
//using指示，blip中的名字被“添加”到全局作用域中
usingnamespaceblip；//如果使用了j，则将在：：j和blip：：j之间产生冲突
++i；
//将blip：：i设定为17
++j；
//二叉性错误：是全局的j还是blip：：j?
++：：j；
//正确：将全局的j设定为1
//正确：将blip：：j设定为16
//当前局部的k隐藏了blip：：k
//将当前局部的k设定为98
}
manip的using指示使得程序可以直接访问blip的所有名字，也就是说，manip
的代码可以使用blip中名字的简写形式。
blip的成员看起来好像是定义在blip和manip所在的作用域一样。假定manip
703
794
795

Page730
704
796
定义在全局作用域中，则blip的成员也好像是定义在全局作用域中一样。
当命名空间被注入到它的外层作用域之后，很有可能该命名空间中定义的名字会与其
外层作用域中的成员冲突。例如在manip中，blip的成员j就与全局作用域中的j产
生了冲突。这种冲突是允许存在的，但是要想使用冲突的名字，我们就必须明确指出名字
的版本。manip中所有未加限定的j都会产生二义性错误。
第18章用于大型程序的工具
为了使用像j这样的名字，我们必须使用作用域运算符来明确指出所需的版本。我们
使用：：j来表示定义在全局作用域中的j，而使用blip：：j来表示定义在blip中的j。
因为manip的作用域和命名空间的作用域不同，所以manip内部的声明可以隐藏命
名空间中的某些成员名字。例如，局部变量k隐藏了命名空间的成员blip：：k。在manip
内使用k不存在二义性，它指的就是局部变量k。
头文件与using声明或指示
头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所
有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不
定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using指示
或using声明（参见3。1节，第75页）。
提示：避免using指示
using指示一次性注入某个命名空间的所有名字，这种用法看似简单实则充满了风
险：只使用一条语句就突然将命名空间中所有成员的名字变得可见了。如果应用程序使
用了多个不同的库，而这些库中的名字通过using指示变得可见，则全局命名空间污
染的问题将重新出现。
而且，当引入库的新版本后，正在工作的程序很可能会编译失败。如果新版本引入
了一个与应用程序正在使用的名字冲突的名字，就会出现这个问题。
另一个风险是由using指示引发的二义性错误只有在使用了冲突名字的地方才能
被发现。这种延后的检测意味着可能在特定库引入很久之后才爆发冲突。直到程序开始
使用该库的新部分后，之前一直未被检测到的错误才会出现。
相比于使用using指示，在程序中对命名空间的每个成员分别使用using声明效
果更好，这么做可以减少注入到命名空间中的名字数量。using声明引起的二义性问题
在声明处就能发现，无须等到使用名字的地方，这显然对检测并修改错误大有益处。
Te
using指示也并非一无是处，例如在命名空间本身的实现文件中就可以使用
using指示。
18。2。2节练习
练习18。15：说明using指示与using声明的区别。
练习18。16：假定在下面的代码中标记为“位置1”的地方是对于命名空间Exercise
中所有成员的using声明，请解释代码的含义。如果这些using声明出现在“位置2"
又会怎样呢?将using声明变为using指示，重新回答之前的问题。
namespaceExercise{
intivar=0；
doubledvar=0；

Page731
18。2命名空间
constintlimit=1000；
}
intivar=0；
//位置1
voidmanip（）{
//位置2
doubledvar=3。1416；
intiobj=limit+1；
++ivar；
++：：ivar；
}
练习18。17：实际编写代码检验你对上一题的回答是否正确。
18。2。3类、命名空间与作用域
对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个外层作用
域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过
程终止。只有位于开放的块中且在使用点之前声明的名字才被考虑：
namespaceA{
inti；
namespaceB{
inti；
intj；
intf1（）
{
intj；
returni；
returnj；
}
}//命名空间B结束，此后B中定义的名字不再可见
intf2（）{
//错误：j没有被定义
}
intj=i；
namespaceA{
inti；
intk；
classC1{
public：
//在B中隐藏了A：：i
private：
//j是f1的局部变量，隐藏了A：：B：：j
//返回B：：i
}
对于位于命名空间中的类来说，常规的查找规则仍然适用：当成员函数使用某个名字
时，首先在该成员中进行查找，然后在类中查找（包括基类），接着在外层作用域中查找，
这时一个或几个外层作用域可能就是命名空间：
inti；
//用A：：i进行初始化
Cl（）：i（0），j（0）{}
intfl（）{returnk；}
}
intf2（）{returnh；
intf3（）；
//正确：初始化Cl︰︰i和C1：：j
//返回A：：k
//错误：h未定义
//在C1中隐藏了A：：i
705
797

Page732
706
798
intj；
}；
inth=i；
}
//成员f3定义在C1和命名空间A的外部
intA：：C1：：f3（）{returnh；}
Tip
//正确：返回A：：h
除了类内部出现的成员函数定义之外（参见7。4。1节，第254页），总是向上查找作用
域。名字必须先声明后使用，因此f2的return语句无法通过编译。该语句试图使用命
名空间A的名字h，但此时h尚未定义。如果h在A中定义的位置位于C1的定义之前，
则上述语句将合法。类似的，因为f3的定义位于A：：h之后，所以f3对于h的使用是
合法的。
第18章用于大型程序的工具
//用A：：i进行初始化
可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反次序
指出被查找的作用域。
实参相关的查找与类类型形参
考虑下面这个简单的程序：
限定符A：：C1：：f3指出了查找类作用域和命名空间作用域的相反次序。首先查找函
数f3的作用域，然后查找外层类C1的作用域，最后检查命名空间A的作用域以及包含
着f3定义的作用域。
std：：strings；
std：：cin>>s；
如我们所知，该调用等价于（参见14。1节，第491页）：
operator>>（std：：cin，s）；
operator>>函数定义在标准库string中，string又定义在命名空间std中。但是我
们不用std：：限定符和using声明就可以调用operator>>。
对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输
出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查
找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样
有效。
在此例中，当编译器发现对operator>>的调用时，首先在当前作用域中寻找合适的
函数，接着查找输出语句的外层作用域。随后，因为>>表达式的形参是类类型的，所以编
译器还会查找cin和s的类所属的命名空间。也就是说，对于这个调用来说，编译器会
查找定义了istream和string的命名空间std。当在std中查找时，编译器找到了
string的输出运算符函数。
查找规则的这个例外允许概念上作为类接口一部分的非成员函数无须单独的using
声明就能被程序使用。假如该例外不存在，则我们将不得不为输出运算符专门提供一个
using声明：
usingstd：：operator>>；
或者使用函数调用的形式以把命名空间的信息包含进来：
std：：operator>>（std：：cin，s）；
//要想使用cin>>s就必须有该using声明
//正确：显式地使用std：：>>

Page733
18。2命名空间
在没有使用运算符语法的情况下，上述两种声明都显得比较笨拙且无形中增加了使用IO
标准库的难度。
查找与std：：move和std：：forward
很多甚至是绝大多数C++程序员从来都没有考虑过与实参相关的查找问题。通常情况
下，如果在应用程序中定义了一个标准库中已有的名字，则将出现以下两种情况中的一种：
要么根据一般的重载规则确定某次调用应该执行函数的哪个版本；要么应用程序根本就不
会执行函数的标准库版本。
接下来考虑标准库move和forward函数。这两个都是模板函数，在标准库的定义
中它们都接受一个右值引用的函数形参。如我们所知，在函数模板中，右值引用形参可以
匹配任何类型（参见16。2。6节，第611页）。如果我们的应用程序也定义了一个接受单一
形参的move函数，则不管该形参是什么类型，应用程序的move函数都将与标准库的版
本冲突。forward函数也是如此。
因此，move（以及forward）的名字冲突要比其他标准库函数的冲突频繁得多。而
且，因为move和forward执行的是非常特殊的类型操作，所以应用程序专门修改函数
原有行为的概率非常小。
对于move和forward来说，冲突很多但是大多数是无意的，这一特点解释了为什
么我们建议最好使用它们的带限定语的完整版本的原因（参见12。1。5节，第417页）。通
过书写std：：move而非move，我们就能明确地知道想要使用的是函数的标准库版本。
友元声明与实参相关的查找
回顾我们曾经讨论过的，当类声明了一个友元时，该友元声明并没有使得友元本身可
见（参见7。2。1节，第242页）。然而，一个另外的未声明的类或函数如果第一次出现在友
元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则
结合在一起将产生意想不到的效果：
namespaceA{
classC{
}；
//两个友元，在友元声明之外没有其他的声明
//这些函数隐式地成为命名空间A的成员
friendvoidf2（）；
//除非另有声明，否则不会被找到
friendvoidf（constC&）；//根据实参相关的查找规则可以被找到
}
此时，f和f2都是命名空间A的成员。即使f不存在其他声明，我们也能通过实参相关
的查找规则调用f：
intmain（）
{
A：：Ccobj；
f（cobj）；
f2（）；
//正确：通过在A：：C中的友元声明找到A：：f
//错误：A：：f2没有被声明
}
因为f接受一个类类型的实参，而且f在c所属的命名空间进行了隐式的声明，所以f
能被找到。相反，因为f2没有形参，所以它无法被找到。
707
799

Page734
708
800
18。2。3节练习
练习18。18：已知有下面的swap的典型定义（参见13。3节，第457页），当meml是
一个string时程序使用swap的哪个版本?如果meml是int呢?说明在这两种情况
下名字查找的过程。
voidswap（Tv1，Tv2）
{
}
usingstd：：swap；
swap（v1。meml，v2。meml）；
//交换类型T的其他成员
练习18。19：如果对swap的调用形如std：：swap（v1。meml，v2。meml）将发生什么情况?
第18章用于大型程序的工具
18。2。4重载与命名空间
命名空间对函数的匹配过程有两方面的影响（参见6。4节，第209页）。其中一个影响
非常明显：using声明或using指示能将某些函数添加到候选函数集。另外一个影响则
比较微妙。
与实参相关的查找与重载
在上一节中我们了解到，对于接受类类型实参的函数来说，其名字查找将在实参类所
属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们将在每
个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数。在这些命名空间中所有
与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可
见也是如此：
namespaceNS{
classQuote{/**/}；
voiddisplay（constQuote&）{/**/}
}
//Bulk_item的基类声明在命名空间NS中
classBulk_item：publicNS：：Quote{/*
intmain（）{
Bulkitembookl；
display（bookl）；
return0；
*/}；
}
我们传递给display的实参属于类类型Bulk_item，因此该调用语句的候选函数不仅
应该在调用语句所在的作用域中查找，而且也应该在Bulk_item及其基类Quote所属
的命名空间中查找。命名空间NS中声明的函数display（constQuote&）也将被添加
到候选函数集当中。
重载与using声明
要想理解using声明与重载之间的交互关系，必须首先明确一条：using声明语句
声明的是一个名字，而非一个特定的函数（参见15。6节，第551页）：
usingNS：：print（int）；//错误：不能指定形参列表
usingNS：：print；
//正确：using声明只声明一个名字

Page735
18。2命名空间
当我们为函数书写using声明时，该函数的所有版本都被引入到当前作用域中。
一个using声明囊括了重载函数的所有版本以确保不违反命名空间的接口。库的作
者为某项任务提供了好几个不同的函数，允许用户选择性地忽略重载函数中的一部分但不
是全部有可能导致意想不到的程序行为。
一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。
如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如
果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则
该using声明将引发错误。除此之外，using声明将为引入的名字添加额外的重载实例，
并最终扩充候选函数集的规模。
重载与using指示
using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命
名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中：
namespacelibs_R_us{
externvoidprint（int）；
externvoidprint（double）；
}
//普通的声明
voidprint（conststd：：string&）；
//这个using指示把名字添加到print调用的候选函数集
usingnamespacelibs_R_us；
//print调用此时的候选函数包括：
//libs_R_us的print（int）
//libs_R_us的print（double）
//显式声明的print（conststd：：string&）
voidfooBar（intival）
{
print（"Value："）；
print（ival）；
}
}
与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同
的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作
用域的版本即可。
跨越多个using指示的重载
如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分：
namespaceAW{
intprint（int）；
//调用全局函数print（conststring&）
//调用libsR_us：：print（int）
namespacePrimer{
doubleprint（double）；
}
//using指示从不同的命名空间中创建了一个重载函数集合
usingnamespaceAW；
usingnamespacePrimer；
longdoubleprint（longdouble）；
intmain（）{
709
801
802

Page736
710
print（1）；
print（3。1）；
return0；
//调用AW：：print（int）
//调用Primer：：print（double）
}
在全局作用域中，函数print的重载集合包括print（int）、print（double）和
print（longdouble），尽管它们的声明位于不同作用域中，但它们都属于main函数
中print调用的候选函数集。
第18章用于大型程序的工具
18。2。4节练习
练习18。20：在下面的代码中，确定哪个函数与compute调用匹配。列出所有候选函
数和可行函数，对于每个可行函数的实参与形参的匹配过程来说，发生了哪种类型转
换?
namespaceprimerLib{
voidcompute（）；
voidcompute（constvoid*）；
}
usingprimerLib：：compute；
voidcompute（int）；
voidcompute（double，double=3。4）；
voidcompute（char*，char*=0）；
voidf（）
{
compute（0）；
}
如果将using声明置于main函数中compute的调用点之前将发生什么情况?重新回
答之前的那些问题。
18。3多重继承与虚继承
多重继承（multipleinheritance）是指从多个直接基类（参见15。2。2节，第533页）中
产生派生类的能力。多重继承的派生类继承了所有父类的属性。尽管概念上非常简单，但
是多个基类相互交织产生的细节可能会带来错综复杂的设计问题与实现问题。
为了探讨有关多重继承的问题，我们将以动物园中动物的层次关系作为教学实例。动
物园中的动物存在于不同的抽象级别上。有个体的动物，如Ling-Ling、Mowgli和Balou
803等，它们以名字进行区分，每个动物属于一个物种，例如Ling-Ling是一只大熊猫；物种
又是科的成员，大熊猫是熊科的成员；每个科是动物界的成员，在这个例子中动物界是指
一个动物园中所有动物的总和。
我们将定义一个抽象类ZooAnimal，用它来保存动物园中动物共有的信息并提供公
共接口。类Bear将存放Bear科特有的信息，以此类推。
除了类ZooAnimal之外，我们的应用程序还包含其他一些辅助类，这些类负责封装
不同的抽象，如濒临灭绝的动物。以类Panda的实现为例，Panda是由Bear和
Endangered共同派生而来的。

Page737
18。3多重继承与虚继承
18。3。1多重继承
在派生类的派生列表中可以包含多个基类：
classBear：publicZooAnimal{
classPanda：publicBear，publicEndangered{/*
。。。*/}；
每个基类包含一个可选的访问说明符（参见15。5节，第543页）。一如往常，如果访问说
明符被忽略掉了，则关键字class对应的默认访问说明符是private，关键字struct
对应的是public（参见15。5节，第546页）。
和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而
且这些类不能是final的（参见15。2。2节，第533页）。对于派生类能够继承的基类个数，
C++没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。
多重继承的派生类从每个基类中继承状态
在多重继承关系中，派生类的对象包含有每个基类的子对象（参见15。2。2节，第530
页）。如图18。2所示，在Panda对象中含有一个Bear部分（其中又含有一个zooAnimal
部分）、一个Endangered部分以及在Panda中声明的非静态数据成员。
Panda
对象
Bear
子部分
Endangered
子部分
ZooAnimal
成员
Endangered
成员
Bear
成员
图18。2：Panda对象的概念结构
Panda
成员
派生类构造函数初始化所有基类
构造一个派生类的对象将同时构造并初始化它的所有基类子对象。与从一个基类进行
的派生一样（参见15。2。2节，第531页），多重继承的派生类的构造函数初始值也只能初
始化它的直接基类：
Endangered（Endangered：：critical）{}
//隐式地使用Bear的默认构造函数初始化Bear子对象
Panda：：Panda（）
：Endangered（Endangered：：critical）{}
//显式地初始化所有基类
Panda：：Panda（std：：stringname，boolonExhibit）
：Bear（name，onExhibit，"Panda"），
派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派
生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。
一个Panda对象按照如下次序进行初始化：
•ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类，
ZooAnimal是Bear的基类，所以首先初始化ZooAnimal。
•接下来初始化Panda的第一个直接基类Bear。
711
804

Page738
712
[C++
11
805
然后初始化Panda的第二个直接基类Endangered。
最后初始化Panda。
继承的构造函数与多重继承
在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数（参见15。7。4
节，第557页）。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），
则程序将产生错误：
structBasel{
Basel（）=default；
Basel（conststd：：string&）；
Basel（std：：shared_ptr<int>）；
}；
structBase2{
Base2（）=default；
Base2（conststd：：string&）；
Base2（int）；
}；
//错误：D1试图从两个基类中都继承D1：：D1（conststring&）
structD1：publicBasel，publicBase2{
第18章用于大型程序的工具
}；
usingBasel：：Basel；
usingBase2：：Base2；
//从Basel继承构造函数
//从Base2继承构造函数
}；
如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它
自己的版本：
structD2：publicBasel，publicBase2{
usingBasel：：Basel；
usingBase2：：Base2；
//D2必须自定义一个接受string的构造函数
//从Basel继承构造函数
//从Base2继承构造函数
D2（conststring&s）：Basel（s），Base2（s）{}
D2（）=default；
//一旦D2定义了它自己的构造函数，则必须出现
析构函数与多重继承
和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及
基类都是自动销毁的。合成的析构函数体为空。
析构函数的调用顺序正好与构造函数相反，在我们的例子中，析构函数的调用顺序是
~Panda、~Endangered、Bear和~ZooAnimal。
多重继承的派生类的拷贝与移动操作
与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数
和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作（参见15。7。2节，第553
页）。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部
分执行这些操作。在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完
成构造、赋值或销毁等工作。
例如，假设Panda使用了合成版本的成员ling_ling的初始化过程：
Pandaying_yang（"ying_yang"）；

Page739
18。3多重继承与虚继承
Pandaling_lingying_yang；
//使用拷贝构造函数
将调用Bear的拷贝构造函数，后者又在执行自己的拷贝任务之前先调用ZooAnimal的
拷贝构造函数。一旦ling_ling的Bear部分构造完成，接着就会调用Endangered
的拷贝构造函数来创建对象相应的部分。最后，执行Panda的拷贝构造函数。合成的移
动构造函数的工作机理与之类似。
合成的拷贝赋值运算符的行为与拷贝构造函数很相似。它首先赋值Bear部分（并且
通Bear赋值ZooAnimal部分），然后赋值Endangered部分，最后是Panda部分。
移动赋值运算符的工作机理与之类似。
18。3。1节练习
练习18。21：解释下列声明的含义，在它们当中存在错误吗?如果有，请指出来并说明
错误的原因。
（a）classCADVehicle：publicCAD，Vehicle{。。。}；
（b）classDblList：publicList，publicList{。。。}；
（c）classiostream：publicistream，publicostream{
}；
练习18。22：已知存在如下所示的类的继承体系，其中每个类都定义了一个默认构造函
数：
classA{。。。}；
classB：publicA{
classC：publicB{
classX{
classY{
}；
。。。}；
}；
}；
classZ：publicX，publicY{
classMI：publicC，publicZ{
对于下面的定义来说，构造函数的执行顺序是怎样的?
MImi；
}；
}；
18。3。2类型转换与多个基类
在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针
或引用（参见15。2。2节，第530页；参见15。5节，第544页）。多个基类的情况与之类似。
我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。例如，一个806
ZooAnimal、Bear或Endangered类型的指针或引用可以绑定到Panda对象上：
//接受Panda的基类引用的一系列操作
voidprint（constBear&）；
voidhighlight（constEndangered&）；
ostream&operator<<（ostream&，constZooAnimal&）；
Pandaying_yang（"ying_yang"）；
print（ying_yang）；
//把一个Panda对象传递给一个Bear的引用
//把一个Panda对象传递给一个Endangered的引用
highlight（ying_yang）；
cout<<ying_yang<<endl；//把一个Panda对象传递给一个ZooAnimal的引用
713
编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意
一种基类都一样好。例如，如果存在如下所示的print重载形式：

Page740
714
807
voidprint（constBear&）；
voidprint（constEndangered&）；
则通过Panda对象对不带前缀限定符的print函数进行调用将产生编译错误：
Pandaying_yang（"ying_yang"）；
print（ying_yang）；
基于指针类型或引用类型的查找
与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些
成员（参见15。6节，第547页）。如果我们使用一个ZooAnimal指针，则只有定义在
ZooAnimal中的操作是可以使用的，Panda接口中的Bear、Panda和Endangered
特有的部分都不可见。类似的，一个Bear类型的指针或引用只能访问Bear及
ZooAnimal的成员，一个Endangered的指针或引用只能访问Endangered的成员。
举个例子，已知我们的类已经定义了表18。1列出的虚函数，考虑下面的这些函数调用：
Bear*pb=newPanda（"ying_yang"）；
pb->print（）；
pb->cuddle（）；
pb->highlight（）；
deletepb；
pe->cuddle（）；
pe->highlight（）；
deletepe；
//二叉性错误
当我们通过Endangered的指针或引用访问一个Panda对象时，Panda接口中
Panda特有的部分以及属于Bear的部分都是不可见的：
Endangered*pe=newPanda（"ying_yang"）；
pe->print（）；
pe->toes（）；
第18章用于大型程序的工具
highlight
toes
//正确：Panda：：print（）
//错误：不属于Bear的接口
//错误：不属于Bear的接口
//正确：Panda：：Panda（）
cuddle
析构函数
表18。1：在ZooAnimal/Endangered中定义的虚函数
函数
含有自定义版本的类
print
ZooAnimal：：ZooAnimal
//正确：Panda：：print（）
//错误：不属于Endangered的接口
//错误：不属于Endangered的接口
//正确：Panda︰：highlight（）
//正确：Panda：：~Panda（）
Bear：：Bear
Endangered：：Endangered
Panda：：Panda
Endangered：：Endangered
Panda：：Panda
Bear：：Bear
Panda：：Panda
Panda：：Panda
ZooAnimal：：ZooAnimal
Endangered：：Endangered
18。3。2节练习
练习18。23：使用练习18。22的继承体系以及下面定义的类D，同时假定每个类都定义
了默认构造函数，请问下面的哪些类型转换是不被允许的?

Page741
18。3多重继承与虚继承
classD：publicX，publicC{
D*pd
newD；
（a）x*px=pd；
（c）B*pbpd；
练习18。24：在第714页，我们使用一个指向Panda对象的Bear指针进行了一系列调
用，假设我们使用的是一个指向Panda对象的ZooAnimal指针将发生什么情况，请
对这些调用语句逐一进行说明。
（a）pb1->print（）；
（d）deletepb2；
（b）A*pa
pd；
（d）C*pc=pd；
练习18。25：假设我们有两个基类Basel和Base2，它们各自定义了一个名为print
的虚成员和一个虚析构函数。从这两个基类中我们派生出下面的类，它们都重新定义了
print函数：
=
classD1：publicBasel{/*
classD2：publicBase2{/*。。。*/}；
classMI：publicD1，publicD2{/*
。。。*/}；
通过下面的指针，指出在每个调用中分别使用了哪个函数：
Basel*pblnewMI；
Base2*pb2newMI；
D1*pd1newMI；
D2*pd2
=newMI；
}；
WARNING
18。3。3多重继承下的类作用域
在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中
（参见15。6节，第547页）。查找过程沿着继承体系自底向上进行，直到找到所需的名字。
派生类的名字将隐藏基类的同名成员。
（b）pdl->print（）；
（e）deletepdl；
在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个
基类中都被找到，则对该名字的使用将具有二义性。
doubled
（c）pd2->print（）；
（f）deletepd2；
在我们的例子中，如果我们通过Panda的对象、指针或引用使用了某个名字，则程
序会并行地在Endangered和Bear/ZooAnimal这两棵子树中查找该名字。如果名字
在超过一棵子树中被找到，则该名字的使用具有二义性。对于一个派生类来说，从它的几
个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出
它的版本。
=
当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名
成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。
例如，如果ZooAnimal和Endangered都定义了名为max_weight的成员，并且
Panda没有定义该成员，则下面的调用是错误的：
715
ying_yang。max_weight（）；
Panda在派生的过程中拥有了两个名为max_weight的成员，这是完全合法的。派生仅
仅是产生了潜在的二义性，只要Panda对象不调用max_weight函数就能避免二义性错
误。另外，如果每次调用max_weight时都指出所调用的版本809
808

Page742
716
（ZooAnimal：：max_weight或者Endangered：：max_weight），也不会发生二义性。
只有当要调用哪个函数含糊不清时程序才会出错。
在上面的例子中，派生类继承的两个max_weight会产生二义性，这一点显而易见。
一种更复杂的情况是，有时即使派生类继承的两个函数形参列表不同也可能发生错误。此
外，即使max_weight在一个类中是私有的，而在另一个类中是公有的或受保护的同样
也可能发生错误。最后一种情况，假如max_weight定义在Bear中而非ZooAnimal
中，上面的程序仍然是错误的。
和往常一样，先查找名字后进行类型检查（参见6。4。1节，第210页）。当编译器在两
个作用域中同时发现了max_weight时，将直接报告一个调用二义性的错误。
要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。例如，
我们可以为Panda定义一个max_weight函数从而解决二义性问题：
doublePanda：：max_weight（）const
{
}
returnstd：：max（ZooAnimal：：max_weight（），
18。3。3节练习
structBasel{
voidprint（int）const；
protected：
intival；
doubledval；
charcval；
private：
int*id；
}；
structBase2{
voidprint（double）const；
protected：
doublefval；
private：
第18章用于大型程序的工具
doubledval；
Endangered：：max_weight（））；
std：：stringsval；
doubledval；
protected：
}；
structDerived：publicBasel{
voidprint（std：：string）const；//默认情况下是公有的
protected：
int*ival；
//默认情况下是公有的
}；
structMI：publicDerived，publicBase2{
voidprint（std：：vector<double>）；//默认情况下是公有的
std：：vector<double>dvec；
//默认情况下是公有的

Page743
18。3多重继承与虚继承
练习18。26：已知如上所示的继承体系，下面对print的调用为什么是错误的?适当修
改MI，令其对print的调用可以编译通过并正确执行。
MImi；
mi。print（42）；
练习18。27：已知如上所示的继承体系，同时假定为MI添加了一个名为foo的函数：
intival；
doubledval；
voidMI：：foo（doublecval）。
{
intdval；
//练习中的问题发生在此处
}
（a）列出在MI：：foo中可见的所有名字。
（b）是否存在某个可见的名字是继承自多个基类的?
（c）将Basel的dval成员与Derived的dval成员求和后赋给dval的局部实例。
（d）将MI：：dvec的最后一个元素的值赋给Base2：：fval。
（e）将从Basel继承的cval赋给从Derived继承的sval的第一个字符。
18。3。4虚继承
尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个
类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基
类，然后通过另一个基类再一次间接继承该类。
举个例子，IO标准库的istream和ostream分别继承了一个共同的名为base_ios
的抽象基类。该抽象基类负责保存流的缓冲内容并管理流的条件状态。iostream是另外
一个类，它从istream和ostream直接继承而来，可以同时读写流的内容｡因为istream
和ostream都继承自base_ios，所以iostream继承了base_ios两次，一次是通
过istream，另一次是通过ostream。
在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程
中出现了多次，则派生类中将包含该类的多个子对象。
在C++语言中我们通过虚继承（virtualinheritance）的机制解决上述问题。虚继承的
目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类
（virtualbaseclass）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中
都只包含唯一一个共享的虚基类子对象。
717
这种默认的情况对某些形如iostream的类显然是行不通的。一个iostream对象
肯定希望在同一个缓冲区中进行读写操作，也会要求条件状态能同时反映输入和输出操作811
的情况。假如在iostream对象中真的包含了base_ios的两份拷贝，则上述的共享行
为就无法实现了。
另一个Panda类
在过去，科学界对于大熊猫属于Raccoon科还是Bear科争论不休。为了如实地反映
这种争论，我们可以对Panda类进行修改，令其同时继承Bear和Raccoon。此时，为
了避免赋予Panda两份ZooAnimal的子对象，我们将Bear和Raccoon继承
810

Page744
718
812
ZooAnimal的方式定义为虚继承。图18。3描述了新的继承体系。
（虚继承）
Bear
ZooAnimal
（虚继承）
}；
Raccoon
第18章用于大型程序的工具
Panda
Endangered
图18。3：Panda的虚继承层次
观察这个新的继承体系，我们将发现虚继承的一个不太直观的特征：必须在虚派生的
真实需求出现前就已经完成虚派生的操作。例如在我们的类中，当我们定义Panda时才
出现了对虚派生的需求，但是如果Bear和Raccoon不是从ZooAnimal虚派生得到的，
那么Panda的设计者就显得不太幸运了。
在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么
问题。通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对
于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无
法改变已存在的类体系。
虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生
Note类本身。
使用虚基类
我们指定虚基类的方式是在派生列表中添加关键字virtual：
//关键字public和virtual的顺序随意
classRaccoon：publicvirtualZooAnimal{/*。。。*/}；
classBear：virtualpublicZooAnimal{/*。。。*/}；
通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。
virtual说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。
至于什么样的类能够作为虚基类并没有特殊规定。
如果某个类指定了虚基类，则该类的派生仍按常规方式进行：
classPanda：publicBear，
publicRaccoon，publicEndangered{
Panda通过Raccoon和Bear继承了ZooAnimal，因为Raccoon和Bear继承
ZooAnimal的方式都是虚继承，所以在Panda中只有一个ZooAnimal基类部分。

Page745
18。3多重继承与虚继承
支持向基类的常规类型转换
不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。例如，下
面这些从Panda向基类的类型转换都是合法的：
voiddance（constBear&）；
voidrummage（constRaccoon&）；
ostream&operator<<（ostream&，constZooAnimal&）；
Pandaying_yang；
dance（ying_yang）；
rummage（ying_yang）；
cout<<ying_yang；
虚基类成员的可见性
因为在每个共享的虛基类中只有唯一一个共享的子对象，所以该基类的成员可以被直
接访问，并且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们
仍然可以直接访问这个被覆盖的成员。但是如果成员被多余一个基类覆盖，则一般情况下
派生类必须为该成员自定义一个新的版本。
例如，假定类B定义了一个名为x的成员，D1和D2都是从B虚继承得到的，继
承了D1和D2，则在D的作用域中，x通过D的两个基类都是可见的。如果我们通过D
的对象使用x，有三种可能性：
•如果在D1和D2中都没有x的定义，则x将被解析为B的成员，此时不存在二义
性，一个D的对象只含有x的一个实例。
•如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生
类的x比共享虚基类B的x优先级更高。
•如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题。
与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义
新的实例。
18。3。4节练习
练习18。28：已知存在如下的继承体系，在VMI类的内部哪些继承而来的成员无须前缀
限定符就能直接访问?哪些必须有限定符才能访问?说明你的原因。
structBase{
voidbar（int）；
protected：
intival；
//正确：把一个Panda对象当成Bear传递
//正确：把一个Panda对象当成Raccoon传递
//正确：把一个Panda对象当成ZooAnimal传递
voidbar（char）；
voidfoo（char）；
}；
structDerivedl：virtualpublicBase{
protected：
charcval；
voidfoo（int）；
protected：
//默认情况下是公有的
structDerived2：virtualpublicBase{
intival；
//默认情况下是公有的
//默认情况下是公有的
719
813

Page746
720
charcval；
第18章用于大型程序的工具
}；
classVMI：publicDerivedl，publicDerived2{}；
18。3。5构造函数与虚继承
在虚派生中，虛基类是由最低层的派生类初始化的。以我们的程序为例，当创建Panda
对象时，由Panda的构造函数独自控制ZooAnimal的初始化过程。
为了理解这一规则，我们不妨假设当以普通规则处理初始化任务时会发生什么情况。
在此例中，虚基类将会在多条继承路径上被重复初始化。以ZooAnimal为例，如果应用
普通规则，则Raccoon和Bear都会试图初始化Panda对象的ZooAnimal部分。
当然，继承体系中的每个类都可能在某个时刻成为“最低层的派生类”。只要我们能
814创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。例如在我们的
继承体系中，当创建一个Bear（或Raccoon）的对象时，它已经位于派生的最低层，因
此Bear（或Raccoon）的构造函数将直接初始化其ZooAnimal基类部分：
Bear：：Bear（std：：stringname，boolonExhibit）：
ZooAnimal（name，onExhibit，"Bear"）{}
Raccoon：：Raccoon（std：：stringname，boolonExhibit）
：ZooAnimal（name，onExhibit，"Raccoon"）{}
而当创建一个Panda对象时，Panda位于派生的最低层并由它负责初始化共享的
ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda的构造函数
也可以初始化ZooAnimal：
Panda：：Panda（std：：stringname，boolonExhibit）
：ZooAnimal（name，onExhibit，"Panda"），
Bear（name，onExhibit），
Raccoon（name，onExhibit），
Endangered（Endangered：：critical），
sleeping_flag（false）{}
虚继承的对象的构造方式
含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类
构造函数的初始值初始化该对象的虛基类子部分，接下来按照直接基类在派生列表中出现
的次序依次对其进行初始化。
例如，当我们创建一个Panda对象时：
•首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal
部分。
•接下来构造Bear部分。
•然后构造Raccoon部分。
●然后构造第三个直接基类Endangered。
最后构造Panda部分。
如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被
调用。如果ZooAnimal没有默认构造函数，则代码将发生错误。

Page747
18。3多重继承与虚继承
Note
虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。
构造函数与析构函数的次序
一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序
从左向右依次构造｡例如，在下面这个稍显杂乱的TeddyBear派生关系中有两个虚基类：815
ToyAnimal是直接虚基类，ZooAnimal是Bear的虛基类：
classCharacter{/*。。。*/}；
classBookCharacter：publicCharacter{/*。。。*/}；
classToyAnimal{/*。。。*/}；
classTeddyBear：publicBookCharacter，
编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如
果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虛基类。因此，要想创建一
个TeddyBear对象，需要按照如下次序调用这些构造函数：
ZooAnimal（）；
ToyAnimal（）；
Character（）；
BookCharacter（）；
publicBear，publicvirtualToyAnimal
{/*。。。*/}；
Bear（）；
TeddyBear（）；
合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也
按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反，首先销毁
TeddyBear部分，最后销毁ZooAnimal部分。
//Bear的虛基类
//直接虛基类
//第一个非虛基类的间接基类
//第一个直接非虛基类
//第二个直接非虚基类
//最低层的派生类
18。3。5节练习
练习18。29：已知有如下所示的类继承关系：
classClass{。。。}；
classBase：publicClass{。。。}；
classD1：virtualpublicBase{
classD2：virtualpublicBase{
classMI：publicD1，publicD2{
}；
classFinal：publicMI，publicClass{
Base*pb；
（a）pbnewClass；
（c）pmi
pb；
=
}；
（a）当作用于一个Final对象时，构造函数和析构函数的执行次序分别是什么?
（b）在一个Final对象中有几个Base部分?几个Class部分?
（c）下面的哪些赋值运算将造成编译错误?
Class*pc；
}；
}；
MI*pmi；
（b）pc=newFinal；
（d）pd2=pmi；
D2*pd2；
721
练习18。30：在Base中定义一个默认构造函数、一个拷贝构造函数和一个接受int形
参的构造函数。在每个派生类中分别定义这三种构造函数，每个构造函数应该使用它的
实参初始化其Base部分。

Page748
722
816
小结
C++语言可以用于解决各种类型的问题，既有几个小时就可以解决的小问题，也有一
个大团队工作数年才能解决的超大规模问题。C++的某些特性特别适合于处理超大规模问
题，这些特性包括：异常处理､命名空间以及多重继承或虚继承。
异常处理使得我们可以将程序的错误检测部分与错误处理部分分隔开来。当程序抛出
一个异常时，当前正在执行的函数暂时中止，开始查找最邻近的与异常匹配的catch语
句。作为异常处理的一部分，如果查找catch语句的过程中退出了某些函数，则函数中
定义的局部变量也随之销毁。
命名空间是一种管理大规模复杂应用程序的机制，这些应用可能是由多个独立的供应
商分别编写的代码组合而成的。一个命名空间是一个作用域，我们可以在其中定义对象、
类型、函数、模板以及其他命名空间。标准库定义在名为std的命名空间中。
第18章用于大型程序的工具
从概念上来说，多重继承非常简单：一个派生类可以从多个直接基类继承而来。在派
生类对象中既包含派生类部分，也包含与每个基类对应的基类部分。虽然看起来很简单，
但实际上多重继承的细节非常复杂。特别是对多个基类的继承可能会引入新的名字冲突，
并造成来自于基类部分的名字的二义性问题。
如果一个类是从多个基类直接继承而来的，那么有可能这些基类本身又共享了另一个
基类。在这种情况下，中间类可以选择使用虚继承，从而声明愿意与层次中虚继承同一基
类的其他类共享虚基类。用这种方法，后代派生类中将只有一个共享虚基类的副本。
术语表
捕获所有异常（catch-all）异常声明形如（。。。）
的catch子句。一条捕获所有异常的子句
可以捕获任意类型的异常。常用于捕获局
部检测的异常，该异常将重新拋出到程序
的其他部分并最终解决问题。
catch子句（catchclause）程序中负责处
理异常的部分。catch子句包含关键字
catch，后面是异常声明以及一个语句块。
catch子句的代码负责处理异常声明中定
义的异常。
1817
构造函数顺序（constructororder）在非虛
继承中，基类的构造顺序与其在派生列表
中出现的顺序一致。在虚继承中，首先构
造虚基类。虚基类的构造顺序与其在派生
类的派生列表中出现的顺序一致。只有最
低层的派生类才能初始化虛基类。虚基类
的初始值如果出现在中间基类中，则这些
初始值将被忽略。
异常声明（exceptiondeclaration）catch
子句中指定其能够处理的异常类型的部
分。异常声明的行为与形参列表类似，其
中的唯一一个形参通过异常对象进行初始
化。如果异常说明符是非引用类型，则异
常对象将被拷贝给catch。
异常处理（exceptionhandling）管理运行
时异常的语言级支持。代码中一个独立开
发的部分可以检测并引发异常，由程序的
另一个独立开发的部分处理该异常。也就
是说，程序的错误检测部分负责抛出异常，
而错误处理部分在try语句块的catch
子句中处理异常。
异常对象（exceptionobject）用于在异常
的throw和catch之间进行通信的对象。
在抛出点创建该对象，该对象是被抛出的
表达式的副本。在该异常的最后一段处理
代码完成之前异常对象都一直存在。异常
对象的类型是被拋出的表达式的静态类型。

Page749
术语表
文件中的静态声明（filestatic）使用关键
字static声明的仅对当前文件有效的名
字。在C语言和之前的C++版本中，文件
中的静态声明用于声明只能在当前文件中
使用的名字。该特性在当前的C++版本中
已经被未命名的命名空间替换了。
函数try语句块（functiontryblock）用于
捕获构造函数初始化过程发生的异常。关
键字try出现在表示构造函数初始值列表
开始的冒号之前（或者当初始值列表为空
时出现在函数体的左侧花括号之前），并以
函数体右侧花括号之后的一个或几个
catch子句作为结束。
全局命名空间（globalnamespace）是每
个程序的隐式命名空间，用于存放全局定
义。
处理代码（handler）是“catch子句”
的同义词。
内联的命名空间（inlinenamespace）内
联命名空间中的名字可以看成是外层命名
空间的成员。
多重继承（multipleinheritance）有多个直
接基类的类。派生类继承所有基类的成员。
可以为每个基类分别设定访问说明符。
命名空间（namespace）将库或者其他程
序集定义的名字放在同一个作用域中的机
制。和C++的其他作用域不同，命名空间
作用域可以定义成几个部分。我们可以打
开并关闭命名空间，然后在程序的另一个
地方重新打开并关闭该命名空间。
命名空间的别名（namespacealias）为某
个给定的命名空间定义同义词的机制：
namespaceN1=N；
将N1定义成命名空间N的另一个名字。
命名空间可以含有多个别名，命名空间的
原名和別名是等价的。
命名空间污染（namespacepollution）当
所有类和函数的名字都放置于全局命名空
间时将造成命名空间污染。如果来自于多
个独立供应商的代码都含有全局名字，则
使用这些代码的大型程序很可能会面临命
名空间污染的问题。
noexcept运算符（noexceptoperator）该
运算符返回一个bool值，用于表示给定
的表达式是否会抛出异常。该表达式不会
被求值，运算的结果是一个常量表达式。
当提供的表达式不含throw并且只调用了
做出不抛出说明的函数时，结果为true；
否则结果为false。
noexcept说明（noexceptspecification）表
示函数是否会抛出异常的关键字。当
noexcept跟在函数的形参列表之后时，
它可以连接一个括号括起来的常量表达
式，前提是该表达式可以转换成bool值。
如果忽略了该表达式，或者表达式的值为
true，则函数不会抛出异常。如果表达式
的值是false或者函数没有异常声明，则
其可能抛出异常。
不抛出说明（nonthrowingspecification）该
异常说明用于承诺某个函数不会抛出异
常。如果一个做了不抛出说明的函数实际
抛出了异常，将调用terminate。不抛出
说明符是不含实参或者含有一个值为
true的实参的noexcept。
引发（raise）常常作为抛出的同义词。C++
程序员认为抛出异常和引发异常基本上是
等价的。
重新拋出（rethrow）不指定表达式的
throw。重新抛出只有在catch子句内部
或者被catch直接或间接调用了的函数内
时才有效。它的效果是将其接受的异常重
新抛出。
栈展开（stackunwinding）在搜寻catch
时依次退出函数的过程。异常发生前构造
的局部对象将在进入相应的catch前被销
毁。
terminate是一个标准库函数，当异常未被
捕获或者在处理异常的过程中发生了另一
个异常时，terminate负责结束程序的执
行。
throwe该表达式将中断当前的执行路径，
throw语句将控制权传递给最近的能够处
723
818

Page750
724
理该异常的catch子句。表达式e将被拷
贝给异常对象。
try语句块（tryblock）含有关键字try以
及一个或多个catch子句的语句块。如果
try语句块中的代码引发了一个异常，并
且某个catch可以匹配该异常，则异常将
被这个catch处理。否则，异常被传递到
try语句块之外并继续沿着调用链寻找与
之匹配的catch。
未命名的命名空间（unnamednamespace）
定义时未指定名字的命名空间。对于定义
在未命名的命名空间中的名字，我们可以
不用作用域运算符就直接访问它们。每个
文件有一个独有的未命名的命名空间，其
中的名字在文件外不可见。
using声明（usingdeclaration）是一种将
命名空间中的某个名字注入当前作用域的
机制：
usingstd：：cout；
上述语句使得命名空间std中的名字
cout在当前作用域可见。之后，我们就可
以直接使用cout而无须前缀std：：了。
第18章用于大型程序的工具
using指示（usingdirective）是具有如下
形式的声明：
usingNS；
上述语句使得命名空间NS的所有名字在
using指示所在的作用域以及NS所在的
作用域都变得可见。
虚基类（virtualbaseclass）在派生列表中
使用了关键字virtual的基类｡在派生类
对象中，虚基类部分只有一份，即使该虚
基类在继承体系中出现了多次也是如此。
对于非虚继承而言，构造函数只能初始化
它的直接基类。但是对于虚继承来说，虚
基类将被最低层的派生类初始化，因此最
低层的派生类应该含有它的所有虚基类的
初始值。
虚继承（virtualinheritance）是多重继承
的一种形式，基类被继承了多次，但是派
生类共享该基类的唯一一份副本。
作用域运算符（：：operator）用于访问命
名空间或类中的名字。

Page751
第19章
特殊工具与技术
内容
19。1控制内存分配。。
19。2运行时类型识别
19。3
枚举类型。。
19。4
类成员指针。
19。5
嵌套类
19。6union：一种节省空间的类。。
19。7局部类
19。8固有的不可移植的特性。
小结
术语表。。
726
730
736
739
746
749
754
755
762
762
本书的前三部分讨论了C++语言的基本要素，这些要素绝大多数程序员都会用到。此
外，C++还定义了一些非常特殊的性质，对于很多程序员来说，他们一般很少会用到本章
介绍的内容。
819

Page752
726
820
821
C++语言的设计者希望它能处理各种各样的问题。因此，C++的某些特征可能对于一
些特殊的应用非常重要，而在另外一些情况下没什么作用。本章将介绍C++语言的几种未
被广泛使用的特征。
19。1控制内存分配
某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用
于这些程序。它们常常需要自定义存分配的细节，比如使用关键字new将对象放置在
特定的内存空间中。为了实现这一目的，应用程序需要重载new运算符和delete运算
符以控制内存分配的过程。
第19章特殊工具与技术
19。1。1重载new和delete
尽管我们说能够“重载new和delete”，但是实际上重载这两个运算符与重载其他
运算符的过程大不相同。要想真正掌握重载new和delete的方法，首先要对new表达
式和delete表达式的工作机理有更多了解。
当我们使用一条new表达式时：
//new表达式
string*sp=newstring（"avalue"）；
string*arr=newstring[10]；
实际执行了三步操作｡第一步，new表达式调用一个名为operatornew（或者operator
new[]）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储
特定类型的对象（或者对象的数组）。第二步，编译器运行相应的构造函数以构造这些对
象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的
指针。
deletesp；
delete[]arr；
//分配并初始化一个string对象
//分配10个默认初始化的string对象
当我们使用一条delete表达式删除一个动态分配的对象时：
//销毁*sp，然后释放sp指向的内存空间
//销毁数组中的元素，然后释放对应的内存空间
实际执行了两步操作。第一步，对sp所指的对象或者arr所指的数组中的元素执行对应
的析构函数。第二步，编译器调用名为operatordelete（或者operatordelete[]）
的标准库函数释放内存空间。
如果应用程序希望控制内存分配的过程，则它们需要定义自己的operatornew函
数和operatordelete函数。即使在标准库中已经存在这两个函数的定义，我们仍旧
可以定义自己的版本。编译器不会对这种重复的定义提出异议，相反，编译器将使用我们
自定义的版本替换标准库定义的版本。
WARNING程序整个处理过程中至关重要的一部分。
当自定义了全局的operatornew函数和operatordelete函数后，我们
就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是
应用程序可以在全局作用域中定义operatornew函数和operatordelete函数，
也可以将它们定义为成员函数。当编译器发现一条new表达式或delete表达式后，将

Page753
19。1控制内存分配
在程序中查找可供调用的operator函数。如果被分配（释放）的对象是类类型，则编
译器首先在类及其基类的作用域中查找。此时如果该类含有operatornew成员或
operatordelete成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域
查找匹配的函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行new表
达式或delete表达式；如果没找到，则使用标准库定义的版本。
我们可以使用作用域运算符令new表达式或delete表达式忽略定义在类中的函数，
直接执行全局作用域中的版本。例如，：：new只在全局作用域中查找匹配的operator
new函数，：：delete与之类似。
operatornew
operatordelete
标准库定义了operatornew函数和operatordelete函数的8个重载版本。其
中前4个版本可能拋出bad_alloc异常，后4个版本则不会抛出异常：
//这些版本可能抛出异常
void*operatornew（size_t）；
void*operatornew[]（size_t）；
void*operatordelete（void*）noexcept；
void*operatordelete[]（void*）noexcept；
//分配一个对象
//分配一个数组
//释放一个对象
//释放一个数组
//这些版本承诺不会抛出异常，参见12。1。2节（第409页）
void*operatornew（size_t，nothrow_t&）noexcept；
void*operatornew[]（size_t，nothrow_t&）noexcept；
void*operatordelete（void*，nothrow_t&）noexcept；
void*operatordelete[]（void*，nothrow_t&）noexcept；
类型nothrow_t是定义在new头文件中的一个struct，在这个类型中不包含任何成员。
new头文件还定义了一个名为nothrow的const对象，用户可以通过这个对象请求new
的非拋出版本（参见12。1。2节，第408页）。与析构函数类似，operatordelete也不
允许抛出异常（参见18。1。1节，第685页）。当我们重载这些运算符时，必须使用noexcept
异常说明符（参见18。1。4节，第690页）指定其不抛出异常。
应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局
作用域或者类作用域中。当我们将上述运算符函数定义成类的成员时，它们是隐式静态的
（参见7。6节，第270页）。我们无须显式地声明static，当然这么做也不会引发错误。
因为operatornew用在对象构造之前而operatordelete用在对象销毁之后，所以
这两个成员（new和delete）必须是静态的，而且它们不能操纵类的任何数据成员。
对于operatornew函数或者operatornew[]函数来说，它的返回类型必须是
void*，第一个形参的类型必须是size_t且该形参不能含有默认实参。当我们为一个对
象分配空间时使用operatornew；为一个数组分配空间时使用operatornew[]。当
编译器调用operatornew时，把存储指定类型对象所需的字节数传给size_t形参；
当调用operatornew[]时，传入函数的则是存储数组中所有元素所需的空间。
如果我们想要自定义operatornew函数，则可以为它提供额外的形参。此时，用
到这些自定义函数的new表达式必须使用new的定位形式（参见12。1。2节，第409页）
将实参传给新增的形参。尽管在一般情况下我们可以自定义具有任何形参的operator
new，但是下面这个函数却无论如何不能被用户重载：
void*operatornew（size_t，void*）；
//不允许重新定义这个版本
727
822

Page754
728
823
这种形式只供标准库使用，不能被用户重新定义。
对于operatordelete函数或者operatordelete[]函数来说，它们的返回类
型必须是void，第一个形参的类型必须是void*。执行一条delete表达式将调用相应
的operator函数，并用指向待释放内存的指针来初始化void*形参。
当我们将operatordelete或operatordelete[]定义成类的成员时，该函数
可以包含另外一个类型为size_t的形参。此时，该形参的初始值是第一个形参所指对象
的字节数。size_t形参可用于删除继承体系中的对象。如果基类有一个虚析构函数（参
见15。7。1节，第552页），则传递给operatordelete的字节数将因待删除指针所指对
象的动态类型不同而有所区别。而且，实际运行的operatordelete函数版本也由对象
的动态类型决定。
第19章特殊工具与技术
术语：new表达式与operatornew函数
标准库函数operatornew和operatordelete的名字容易让人误解。和其他
operator函数不同（比如operator=），这两个函数并没有重载new表达式或delete
表达式。实际上，我们根本无法自定义new表达式或delete表达式的行为。
一条new表达式的执行过程总是先调用operatornew函数以获取内存空间，然
后在得到的内存空间中构造对象。与之相反，一条delete表达式的执行过程总是先销
毁对象，然后调用operatordelete函数释放对象所占的空间。
我们提供新的operatornew函数和operatordelete函数的目的在于改变内
存分配的方式，但是不管怎样，我们都不能改变new运算符和delete运算符的基本
含义。
malloc函数与free函数
当你定义了自己的全局operatornew和operatordelete后，这两个函数必须
以某种方式执行分配内存与释放内存的操作。也许你的初衷仅仅是使用一个特殊定制的内
存分配器，但是这两个函数还应该同时满足某些测试的目的，即检验其分配内存的方式是
否与常规方式类似。
为此，我们可以使用名为malloc和free的函数，C++从C语言中继承了这些函数，
并将其定义在cstdlib头文件中。
malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者
返回0以表示分配失败。free函数接受一个void*，它是malloc返回的指针的副本，
free将相关内存返回给系统。调用free（0）没有任何意义。
如下所示是编写operatornew和operatordelete的一种简单方式，其他版本
与之类似：
void*operatornew（size_tsize）{
if（void*mem=malloc（size））
returnmem；
else
throwbadalloc（）；
}
voidoperatordelete（void*mem）noexcept{free（mem）；}

Page755
19。1控制内存分配
19。1。1节练习
练习19。1：使用malloc编写你自己的operatornew（size_t）函数，使用free编
写operatordelete（void*）函数。
练习19。2：默认情况下，allocator类使用operatornew获取存储空间，然后使用
operatordelete释放它。利用上一题中的两个函数重新编译并运行你的StrVec程
序（参见13。5节，第465页）。
19。1。2定位new表达式
尽管operatornew函数和operatordelete函数一般用于new表达式，然而它
们毕竟是标准库的两个普通函数，因此普通的代码也可以直接调用它们。
在C++的早期版本中，allocator类（参见12。2。2节，第427页）还不是标准库的
一部分。应用程序如果想把内存分配与初始化分离开来的话，需要调用operatornew
和operatordelete。这两个函数的行为与allocator的allocate成员和
deallocate成员非常类似，它们负责分配或释放内存空间，但是不会构造或销毁对象。
与allocator不同的是，对于operatornew分配的内存空间来说我们无法使用824
construct函数构造对象。相反，我们应该使用new的定位new（placementnew）形式
（参见12。1。2节，第409页）构造对象。如我们所知，new的这种形式为分配函数提供了
额外的信息。我们可以使用定位new传递一个地址，此时定位new的形式如下所示：
new（place_address）type
new（place_address）type（initializers）
new（place_address）type[size]
new（place_address）type[size]{bracedinitializerlist}
其中place_address必须是一个指针，同时在initializers中提供一个（可能为空的）以逗号
分隔的初始值列表，该初始值列表将用于构造新分配的对象。
当仅通过一个地址值调用时，定位new使用operatornew（size_t，void*）“分
配”它的内存。这是一个我们无法自定义的operatornew版本（参见19。1。1节，第727
页）。该函数不分配任何内存，它只是简单地返回指针实参；然后由new表达式负责在指
定的地址初始化对象以完成整个工作。事实上，定位new允许我们在一个特定的、预先
分配的内存地址上构造对象。
当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。
Note
尽管在很多时候使用定位new与allocator的construct成员非常相似，但在它
们之间也有一个重要的区别。我们传给construct的指针必须指向同一个allocator
对象分配的空间，但是传给定位new的指针无须指向operatornew分配的内存。实际
上如我们将在19。6节（第753页）介绍的，传给定位new表达式的指针甚至不需要指向
动态内存。
729
显式的析构函数调用
就像定位new与使用allocate类似一样，对析构函数的显式调用也与使用
destroy很类似。我们既可以通过对象调用析构函数，也可以通过对象的指针或引用调

Page756
730
825
用析构函数，这与调用其他成员函数没什么区别：
string*sp=newstring（"avalue"）；//分配并初始化一个string对象
sp->~string（）；
在这里我们直接调用了一个析构函数。箭头运算符解引用指针sp以获得sp所指的对象，
然后我们调用析构函数，析构函数的形式是波浪线（~）加上类型的名字。
和调用destroy类似，调用析构函数可以清除给定的对象但是不会释放该对象所在
的空间。如果需要的话，我们可以重新使用该空间。
调用析构函数会销毁对象，但是不会释放内存。
Note
第19章特殊工具与技术
19。2运行时类型识别
运行时类型识别（run-timetypeidentification，RTTI）的功能由两个运算符实现：
•typeid运算符，用于返回表达式的类型。
•dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或
引用。
当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将
使用指针或引用所绑定对象的动态类型（参见15。2。3节，第534页）。
这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生
类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作
被定义成虚函数时，编译器将根据对象的动态类型自动地选择正确的函数版本。
然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一
个RTTI运算符。另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风
险：程序员必须清楚地知道转换的目标类型并且必须检查类型转换是否被成功执行。
WARNING
使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管
类型管理的重任。
19。2。1dynamic_cast运算符
dynamic_cast运算符（dynamic_castoperator）的使用形式如下所示：
dynamic_cast<type*>（e）
dynamic_cast<type&>（e）
dynamic_cast<type&&>（e）
其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，
e必须是一个有效的指针（参见2。3。2节，第47页）；在第二种形式中，e必须是一个左值；
在第三种形式中，e不能是左值。
在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：e的类型是目
标type的公有派生类、e的类型是目标type的公有基类或者e的类型就是目标type的类
型。如果符合，则类型转换可以成功。否则，转换失败。如果一条dynamic_cast语句
的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，

Page757
19。2运行时类型识别
则dynamic_cast运算符将抛出一个bad_cast异常。
指针类型的dynamic_cast
举个简单的例子，假定Base类至少含有一个虚函数，Derived是Base的公有派生
类。如果有一个指向Base的指针bp，则我们可以在运行时将它转换成指向Derived的
指针，具体代码如下：
if（Derived*dp
{
=
dynamic_cast<Derived*>（bp））
//使用dp指向的Derived对象
}else{//bp指向一个Base对象
//使用bp指向的Base对象
Note
}
如果bp指向Derived对象，则上述的类型转换初始化dp并令其指向bp所指的Derived
对象。此时，if语句内部使用Derived操作的代码是安全的。否则，类型转换的结果为
0，dp为0意味着if语句的条件失败，此时else子句执行相应的Base操作。
我们可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。
值得注意的一点是，我们在条件部分定义了dp，这样做的好处是可以在一个操作中
同时完成类型转换和条件检查两项任务。而且，指针dp在if语句外部是不可访问的。
一旦转换失败，即使后续的代码忘了做相应判断，也不会接触到这个未绑定的指针，从而
确保程序是安全的。
Practices
Best在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条
表达式中完成。
引用类型的dynamic_cast
引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式
上略有不同。因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全
相同的错误报告策略。当对引用的类型转换失败时，程序拋出一个名为std：：bad_cast
的异常，该异常定义在typeinfo标准库头文件中。
我们可以按照如下的形式改写之前的程序，令其使用引用类型：
voidf（constBase&b）。
{
try{
constDerived&d=dynamic_cast<constDerived&>（b）；
//使用b引用的Derived对象
}catch（badcast）{
//处理类型转换失败的情况
19。2。1节练习
练习19。3：已知存在如下的类继承体系，其中每个类分别定义了一个公有的默认构造函
731
826

Page758
732
827
828
数和一个虚析构函数：
classA{/*。。。*/}；
classB：publicA{/*。。。*/}；
classC：
publicB{/*。。。*/}；
classD：publicB，publicA{/*。。。*/}；
下面的哪个dynamic_cast将失败?
（a）A*pa=newC；
B*pb
（b）B*pb
dynamic_cast<B*>（pa）；
=newB；
=
}else{
c*pc
（c）A*pa
B*pbdynamic_cast<B*>（pa）；
练习19。4：使用上一个练习定义的类改写下面的代码，将表达式*pa转换成类型C&；
if（C*pc=dynamic_cast<C*>（pa））
}
=
//使用c的成员
dynamic_cast<C*>（pb）；
newD；
//使用A的成员
第19章特殊工具与技术
}
练习19。5：在什么情况下你应该使用dynamic_cast替代虚函数?
19。2。2typeid运算符
为RTTI提供的第二个运算符是typeid运算符（typeidoperator），它允许程序向表
达式提问：你的对象是什么类型?
typeid表达式的形式是typeid（e），其中e可以是任意表达式或类型的名字。
typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或
者type_info的公有派生类型。type_info类定义在typeinfo头文件中，19。2。4节
（第735页）将介绍更多关于type_info的细节。
typeid运算符可以作用于任意类型的表达式。和往常一样，顶层const（参见2。4。3
节，第57页）被忽略，如果表达式是一个引用，则typeid返回该引用所引对象的类型。
不过当typeid作用于数组或函数时，并不会执行向指针的标准类型转换（参见4。11。2节，
第143页）。也就是说，如果我们对数组a执行typeid（a），则所得的结果是数组类型而
非指针类型。
当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示
的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid
的结果直到运行时才会求得。
使用typeid运算符
通常情况下，我们使用typeid比较两条表达式的类型是否相同，或者比较一条表达
式的类型是否与指定类型相同：
Derived*dp=newDerived；
Base*bp
dp；
//在运行时比较两个对象的类型
=
//两个指针都指向Derived对象

Page759
19。2运行时类型识别
if（typeid（*bp）
//bp和dp指向同一类型的对象
typeid（*dp））{
}
//检查运行时类型是否是某种指定的类型

if（typeid（*bp）
==

typeid（Derived））{
//bp实际指向Derived对象
}
在第一个if语句中，我们比较bp和dp所指的对象的动态类型是否相同。如果相同，
则条件成功。类似的，当bp当前所指的是一个Derived对象时，第二个if语句的条件
满足。
注意，typeid应该作用于对象，因此我们使用*bp而非bp：
//下面的检查永远是失败的：bp的类型是指向Base的指针
if（typeid（bp）==typeid（Derived））{
//此处的代码永远不会执行
}
这个条件比较的是类型Base*和Derived。尽管指针所指的对象类型是一个含有虚函数
的类，但是指针本身并不是一个类类型的对象。类型Base*将在编译时求值，显然它与
Derived不同，因此不论bp所指的对象到底是什么类型，上面的条件都不会满足。
当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静
WARNING态编译时类型。
typeid是否需要运行时检查决定了表达式是否会被求值｡只有当类型含有虚函数时，
编译器才会对表达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态
类型；编译器无须对表达式求值也能知道表达式的静态类型。
如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返
回的类型。这条规则适用于typeid（*p）的情况。如果指针p所指的类型不含有虚函数，
则p不必非得是一个有效的指针。否则，*p将在运行时求值，此时p必须是一个有效的
指针。如果p是一个空指针，则typeid（*p）将抛出一个名为bad_typeid的异常。
19。2。2节练习
练习19。6：编写一条表达式将Query_base指针动态转换为AndQuery指针（参见
15。9。1节，第564页）。分别使用AndQuery的对象以及其他类型的对象测试转换是否
有效。打印一条表示类型转换是否成功的信息，确保实际输出的结果与期望的一致。
练习19。7：编写与上一个练习类似的转换，这一次将Query_base对象转换为
AndQuery的引用。重复上面的测试过程，确保转换能正常工作。
练习19。8：编写一条typeid表达式检查两个Query_base对象是否指向同一种类型。
再检查该类型是否是AndQuery。
19。2。3使用RTTI
在某些情况下RTTI非常有用，比如当我们想为具有继承关系的类实现相等运算符时
（参见14。3。1节，第497页）。对于两个对象来说，如果它们的类型相同并且对应的数据成
733

Page760
734
829
830
员取值相同，则我们说这两个对象是相等的。在类的继承体系中，每个派生类负责添加自
己的数据成员，因此派生类的相等运算符必须把派生类的新成员考虑进来。
一种容易想到的解决方案是定义一套虚函数，令其在继承体系的各个层次上分别执行
相等性判断。此时，我们可以为基类的引用定义一个相等运算符，该运算符将它的工作委
托给虚函数equal，由equal负责实际的操作。
遗憾的是，上述方案很难奏效。虚函数的基类版本和派生类版本必须具有相同的形参
类型（参见15。3节，第537页）。如果我们想定义一个虚函数equal，则该函数的形参必
须是基类的引用。此时，equal函数将只能使用基类的成员，而不能比较派生类独有的成员。
要想实现真正有效的相等比较操作，我们需要首先清楚一个事实：即如果参与比较的
两个对象类型不同，则比较结果为false。例如，如果我们试图比较一个基类对象和一个
派生类对象，则==运算符应该返回false。
基于上述推论，我们就可以使用RTTI解决问题了。我们定义的相等运算符的形参是
基类的引用，然后使用typeid检查两个运算对象的类型是否一致。如果运算对象的类型
不一致，则==返回false；类型一致才调用equal函数。每个类定义的equal函数负
责比较类型自己的成员。这些运算符接受Bases形参，但是在进行比较操作前先把运算对
象转换成运算符所属的类类型。
类的层次关系
为了更好地解释上述概念，我们定义两个示例类：
classBase{
friendbooloperator==（constBase&，constBase&）；
public：
//Base的接口成员
protected：
第19章特殊工具与技术
virtualboolequal（constBase&）const；
//Base的数据成员和其他用于实现的成员
}；
classDerived：publicBase{
public：
}；
//Derived的其他接口成员
protected：
boolequal（constBase&）const；
//Derived的数据成员和其他用于实现的成员
类型敏感的相等运算符
接下来介绍我们是如何定义整体的相等运算符的：
booloperator==（constBase&lhs，constBase&rhs）
（
//如果typeid不相同，返回false；否则虚调用equal

returntypeid（lhs）typeid（rhs）&&lhs。equal（rhs）；
==

}
在这个运算符中，如果运算对象的类型不同则返回false。否则，如果运算对象的类型相
同，则运算符将其工作委托给虚函数equal。当运算对象是Base的对象时，调用
Base：：equal；当运算对象是Derived的对象时，调用Derived：：equal。

Page761
19。2运行时类型识别
虚equal函数
继承体系中的每个类必须定义自己的equal函数。派生类的所有函数要做的第一件
事都是相同的，那就是将实参的类型转换为派生类类型：
boolDerived：：equal（constBase&rhs）const
{
//我们清楚这两个类型是相等的，所以转换过程不会抛出异常
autor=dynamic_cast<constDerived&>（rhs）；
//执行比较两个Derived对象的操作并返回结果
}
上面的类型转换永远不会失败，因为毕竟我们只有在验证了运算对象的类型相同之后才会
调用该函数。然而这样的类型转换是必不可少的，执行了类型转换后，当前函数才能访问
右侧运算对象的派生类成员。
基类equal函数
下面这个操作比其他的稍微简单一点：
boolBase：：equal（constBase&rhs）const
{
//执行比较Base对象的操作
}
无须事先转换形参的类型。*this和形参都是Base对象，因此当前对象可用的操作对于
形参类型同样有效。
t1
19。2。4type_info类
type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定
type_info类必须定义在typeinfo头文件中，并且至少提供表19。1所列的操作。
==t2
t1!=t2
t。name（）
t1。before（t2）
表19。1：type_info的操作
如果type_info对象t1和t2表示同一种类型，返回true；否则返
回false
如果type_info对象t1和t2表示不同的类型，返回true；否则返
回false
返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成
方式因系统而异
返回一个bool值，表示t1是否位于t2之前。before所采用的顺序
关系是依赖于编译器的
除此之外，因为type_info类一般是作为一个基类出现，所以它还应该提供一个公有
的虚析构函数。当编译器希望提供额外的类型信息时，通常在type_info的派生类中完成。
type_info类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都
被定义成删除的（参见13。1。6节，第450页）。因此，我们无法定义或拷贝type_info
类型的对象，也不能为type_info类型的对象赋值。创建type_info对象的唯一途径
是使用typeid运算符。
type_info类的name成员函数返回一个C风格字符串，表示对象的类型名字。对
735
831

Page762
736
832
于某种给定的类型来说，name的返回值因编译器而异并且不一定与在程序中使用的名字
一致。对于name返回值的唯一要求是，类型不同则返回的字符串必须有所区别。例如：
intarr[10]；
Derivedd；
Base*p=&d；
cout<<typeid（42）。name（）<<"，
<<typeid（arr）。name（）<<"
<<typeid（Sales_data）。name（）<<"，
<<typeid（std：：string）。name（）
<<typeid（p）。name（）<<
<<typeid（*p）。name（）<<endl；
在作者的计算机上运行该程序，输出结果如下：
i，A10_i，10Sales_data，Ss，P4Base，7Derived
Note
11
"1
type_info类在不同的编译器上有所区别。有的编译器提供了额外的成员函
数以提供程序中所用类型的额外信息。读者应该仔细阅读你所用编译器的使用
手册，从而获取关于type_info的更多细节。
classA{/*。。。*/}；
classB：publicA{/*。。。*/}；
classC：publicB{/*。。。*/}；
（a）A*pa=newC；
"
19。2。4节练习
练习19。9：编写与本节最后一个程序类似的代码，令其打印你的编译器为一些常见类型
所起的名字。如果你得到的输出结果与本书类似，尝试编写一个函数将这些字符串翻译
成人们更容易读懂的形式。
练习19。10：已知存在如下的类继承体系，其中每个类定义了一个默认公有的构造函数
和一个虚析构函数。下面的语句将打印哪些类型名字?
（b）Ccobj；
A&ra=
第19章特殊工具与技术
cout<<typeid（pa）。name（）<<endl；
cobj；
cout<<typeid（&ra）。name（）<<endl；
（c）B*px=newB；
A&ra=
*px；
cout<<typeid（ra）。name（）<<endl；
19。3枚举类型
枚举类型（enumeration）使我们可以将一组整型常量组织在一起。和类一样，每个枚
举类型定义了一种新的类型。枚举属于字面值常量类型（参见7。5。6节，第267页）。
C++包含两种枚举：限定作用域的和不限定作用域的。C++11新标准引入了限定作用
域的枚举类型（scopedenumeration）。定义限定作用域的枚举类型的一般形式是：首先是
11关键字enumclass（或者等价地使用enumstruct），随后是枚举类型名字以及用花括
C++

Page763
19。3枚举类型
号括起来的以逗号分隔的枚举成员（enumerator）列表，最后是一个分号：
enumclassopen_modes{input，output，append}；
我们定义了一个名为open_modes的枚举类型，它包含三个枚举成员：input、output
和append。
定义不限定作用域的枚举类型（unscopedenumeration）时省略掉关键字class（或
struct），枚举类型的名字是可选的：
enumcolor{red，yellow，green}；
//未命名的、不限定作用域的枚举类型
enum{floatPrec=6，doublePrec=10，double_doublePrec10}；
//不限定作用域的枚举类型
如果enum是未命名的，则我们只能在定义该enum时定义它的对象。和类的定义类似，
我们需要在enum定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表（参见
2。6。1节，第64页）。
枚举成员
在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类
型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用
域与枚举类型本身的作用域相同：
enumcolor{red，yellow，green}；
//不限定作用域的枚举类型
//错误：重复定义了枚举成员
enumstoplight{red，yellow，green}；
enumclasspeppers{red，yellow，green}；//正确：枚举成员被隐藏了
coloreyes
green；//正确：不限定作用域的枚举类型的枚举成员位于有效的作用域中
peppersp=green；//错误：peppers的枚举成员不在有效的作用域中
//color：：green在有效的作用域中，但是类型错误
colorhair=color：：red；
peppersp2=peppers：：red；
默认情况下，枚举值从0开始，依次加1。不过我们也能为一个或几个枚举成员指定
专门的值：
enumclassintTypes{
charTyp8，shortTyp==16，intTyp
longTyp=32，long_longTyp=64
=
//正确：允许显式地访问枚举成员
//正确：使用pappers的red
16，
}；
由枚举成员intTyp和shortTyp可知，枚举值不一定唯一。如果我们没有显式地提供
初始值，则当前枚举成员的值等于之前枚举成员的值加1。
枚举成员是const，因此在初始化枚举成员时提供的初始值必须是常量表达式（参见
2。4。4节，第58页）。也就是说，每个枚举成员本身就是一条常量表达式，我们可以在任何
需要常量表达式的地方使用枚举成员。例如，我们可以定义枚举类型的constexpr变量：
constexprintTypescharbits=intTypes：：charTyp；
类似的，我们也可以将一个enum作为switch语句的表达式，而将枚举值作为case标
签（参见5。3。2节，第160页）。出于同样的原因，我们还能将枚举类型作为一个非类型模
板形参使用（参见16。1。1节，第580页）；或者在类的定义中初始化枚举类型的静态数据
成员（参见7。6节，第270页）。
737
833

Page764
738
834
C++
11
和类一样，枚举也定义新的类型
只要enum有名字，我们就能定义并初始化该类型的成员。要想初始化enum对象或
者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象：
open_modesom=2；
om=open_modes：：input；
//错误：2不属于类型open_modes
//正确：input是open_modes的一个枚举成员
一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。因此，我们可以
在任何需要整型值的地方使用它们：
第19章特殊工具与技术
inti=color：：red；//正确：不限定作用域的枚举类型的枚举成员隐式地转换成int
intj=peppers：：red；//错误：限定作用域的枚举类型不会进行隐式转换
指定enum的大小
尽管每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的。在
[C++C++11新标准中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类
11
型：
enumintValues：unsignedlonglong{
charTyp255，shortTyp
longTyp
==4294967295UL，
long_longTyp=18446744073709551615ULL
=
65535，intTyp
=65535，
如果我们没有指定enum的潜在类型，则默认情况下限定作用域的enum成员类型是int。
对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在
类型足够大，肯定能够容纳枚举值。如果我们指定了枚举成员的潜在类型（包括对限定作
用域的enum的隐式指定），则一旦某个枚举成员的值超出了该类型所能容纳的范围，将
引发程序错误。
指定enum潜在类型的能力使得我们可以控制不同实现环境中使用的类型，我们将可
以确保在一种实现环境中编译通过的程序所生成的代码与其他实现环境中生成的代码一
致。
枚举类型的前置声明
在C++11新标准中，我们可以提前声明enum。enum的前置声明（无论隐式地还是
显示地）必须指定其成员的大小：
//不限定作用域的枚举类型intValues的前置声明
enumintValues：unsignedlonglong；//不限定作用域的，必须指定成员类型
enumclassopen_modes；//限定作用域的枚举类型可以使用默认成员类型int
因为不限定作用域的enum未指定成员的默认大小，因此每个声明必须指定成员的大小。
对于限定作用域的enum来说，我们可以不指定其成员的大小，这个值被隐式地定义成int。
和其他声明语句一样，enum的声明和定义必须匹配，这意味着在该enum的所有声
明和定义中成员的大小必须一致。而且，我们不能在同一个上下文中先声明一个不限定作
用域的enum名字，然后再声明一个同名的限定作用域的enum：
//错误：所有的声明和定义必须对该enum是限定作用域的还是不限定作用域的保持一致
enumclassintValues；
enumintValues；
enumintValues：long；
//错误：intValues已经被声明成限定作用域的enum
//错误：intValues已经被声明成int

Page765
19。4类成员指针
形参匹配与枚举类型
要想初始化一个enum对象，必须使用该enum类型的另一个对象或者它的一个枚举
成员（参见19。3节，第737页）。因此，即使某个整型值恰好与枚举成员的值相等，它也
不能作为函数的enum实参使用：
//不限定作用域的枚举类型，潜在类型因机器而异
enumTokens{INLINE=128，VIRTUAL=129}；
voidff（Tokens）；
voidff（int）；
intmain（）{
TokenscurTok=INLINE；
ff（128）；
ff（INLINE）；
ff（curTok）；
return0；
}
尽管我们不能直接将整型值传给enum形参，但是可以将一个不限定作用域的枚举类
型的对象或枚举成员传给整型形参。此时，enum的值提升成int或更大的整型，实际提
升的结果由枚举类型的潜在类型决定：
voidnewf（unsignedchar）；
voidnewf（int）；
unsignedcharuc=VIRTUAL；
newf（VIRTUAL）；
newf（uc）；
//精确匹配ff（int）
//精确匹配ff（Tokens）
//精确匹配ff（Tokens）
//调用newf（int）
//调用newf（unsignedchar）
枚举类型Tokens只有两个枚举成员，其中较大的那个值是129。该枚举类型可以用
unsignedchar来表示，因此很多编译器使用unsignedchar作为Tokens的潜在类
型。不管Tokens的潜在类型到底是什么，它的对象和枚举成员都提升成int。尤其是，
枚举成员永远不会提升成unsignedchar，即使枚举值可以用unsignedchar存储也
是如此。
19。4类成员指针
成员指针（pointertomember）是指可以指向类的非静态成员的指针。一般情况下，
指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。类的静态成员不属
于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有
什么区别。
classScreen{
public：
成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们
令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成
员所属的对象。
为了解释成员指针的原理，不妨使用7。3。1节（第243页）的Screen类：
typedefstd：：string：：size_typepos；
charget_cursor（）const{returncontents[cursor]；}
charget（）const；
739
835
836

Page766
740
837
charget（posht，poswd）const；
private：
}；
std：：stringcontents；
poscursor；
posheight，width；
第19章特殊工具与技术
19。4。1数据成员指针
和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。
与普通指针不同的是，成员指针还必须包含成员所属的类。因此，我们必须在*之前添加
classname：：以表示当前定义的指针可以指向classname的成员。例如：
//pdata可以指向一个常量（非常量）Screen对象的string成员
conststringScreen：：*pdata；
上述语句将pdata声明成“一个指向Screen类的conststring成员的指针”。常量
对象的数据成员本身也是常量，因此将我们的指针声明成指向conststring成员的指
针意味着pdata可以指向任何Screen对象的一个成员，而不管该Screen对象是否是
常量。作为交换条件，我们只能使用pdata读取它所指的成员，而不能向它写入内容。
当我们初始化一个成员指针（或者向它赋值）时，需指定它所指的成员。例如，我们
可以令pdata指向某个非特定Screen对象的contents成员：
pdata&Screen：：contents；
其中，我们将取地址运算符作用于Screen类的成员而非内存中的一个该类对象。
当然，在C++11新标准中声明成员指针最简单的方法是使用auto或decltype：
autopdata=&Screen：：contents；
使用数据成员指针
读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并
没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针
时我们才提供对象的信息。
与成员访问运算符。和->类似，也有两种成员指针访问运算符：。*和->*，这两个运
算符使得我们可以解引用指针并获得该对象的成员：
ScreenmyScreen，*pScreen=&myScreen；
//。*解引用pdata以获得myScreen对象的contents成员
autos=myScreen。*pdata；
//->*解引用pdata以获得pScreen所指对象的contents成员
s=pScreen->*pdata；
从概念上来说，这些运算符执行两步操作：它们首先解引用成员指针以得到所需的成员；
然后像成员访问运算符一样，通过对象（。*）或指针（->*）获取成员。
返回数据成员指针的函数
常规的访问控制规则对成员指针同样有效。例如，Screen的contents成员是私有
的，因此之前对于pdata的使用必须位于Screen类的成员或友元内部，否则程序将发
生错误。

Page767
19。4类成员指针
因为数据成员一般情况下是私有的，所以我们通常不能直接获得数据成员的指针。如
果一个像Screen这样的类希望我们可以访问它的contents成员，最好定义一个函数，
令其返回值是指向该成员的指针：
classScreen{
public：
//data是一个静态成员，返回一个成员指针
staticconststd：：stringScreen：：*data（）
{return&Screen：：contents；}
//其他成员与之前的版本一致
}；
我们为Screen类添加了一个静态成员，令其返回指向contents成员的指针。显然该
函数的返回类型与最初的pdata指针类型一致｡从右向左阅读函数的返回类型，可知data
返回的是一个指向Screen类的conststring成员的指针。函数体对contents成员
使用了取地址运算符，因此函数将返回指向Screen类contents成员的指针。
当我们调用data函数时，将得到一个成员指针：
//data（）返回一个指向Screen类的contents成员的指针
conststringScreen：：*pdata=Screen：：data（）；
一如往常，pdata指向Screen类的成员而非实际数据。要想使用pdata，必须把它绑
定到Screen类型的对象上：
//获得myScreen对象的contents成员
autos=myScreen。*pdata；
19。4。1节练习
练习19。11：普通的数据指针与指向数据成员的指针有何区别?
练习19。12：定义一个成员指针，令其可以指向Screen类的cursor成员。通过该指
针获得Screen：：cursor的值。
练习19。13：定义一个类型，使其可以表示指向Salesdata类的bookNo成员的指针。
19。4。2成员函数指针
我们也可以定义指向类的成员函数的指针。与指向数据成员的指针类似，对于我们来
说要想创建一个指向成员函数的指针，最简单的方法是使用auto来推断类型：
//pmf是一个指针，它可以指向Screen的某个常量成员函数
//前提是该函数不接受任何实参，并且返回一个char
autopmf=&Screen：：get_cursor；
和指向数据成员的指针一样，我们使用classname：：*的形式声明一个指向成员函数的
指针。类似于任何其他函数指针（参见6。7节，第221页），指向成员函数的指针也需要指
定目标函数的返回类型和形参列表。如果成员函数是const成员（参见7。1。2节，第231
页）或者引用成员（参见13。6。3节，第483页），则我们必须将const限定符或引用限定
符包含进来。
和普通的函数指针类似，如果成员存在重载的问题，则我们必须显式地声明函数类型
以明确指出我们想要使用的是哪个函数（参见6。7节，第211页）。例如，我们可以声明一
741
838

Page768
742
839
个指针，令其指向含有两个形参的get：
char（Screen：：*pmf2）（Screen：：pos，Screen：：pos）const；
pmf2=&Screen：：get；
出于优先级的考虑，上述声明中Screen：：*两端的括号必不可少。如果没有这对括号的
话，编译器将认为该声明是一个（无效的）函数声明：
//错误：非成员函数p不能使用const限定符
charScreen：：*p（Screen：：pos，Screen：：pos）const；
第19章特殊工具与技术
这个声明试图定义一个名为p的普通函数，并且返回Screen类的一个char成员。因为
它声明的是一个普通函数，所以不能使用const限定符。
和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：
//pmf指向一个Screen成员，该成员不接受任何实参且返回类型是char
bpmf
&Screen：：get；
//必须显式地使用取地址运算符
pmf=Screen：：get；
//错误：在成员函数和指针之间不存在自动转换规则
使用成员函数指针
和使用指向数据成员的指针一样，我们使用。*或者->*运算符作用于指向成员函数的
指针，以调用类的成员函数：
ScreenmyScreen，*pScreen
&myScreen；
//通过pScreen所指的对象调用pmf所指的函数
=
charcl=（pScreen->*pmf）（）；
//通过myScreen对象将实参0，0传给含有两个形参的get函数
charc2=（myScreen。*pmf2）（0，0）；
myScreen。*pmf（）
其含义将等同于下面的式子：
之所以（myScreen->*pmf）（）和（pScreen。*pmf2）（0，0）的括号必不可少，原因
是调用运算符的优先级要高于指针指向成员运算符的优先级。
假设去掉括号的话，
Note
myScreen。*（pmf（））
这行代码的意思是调用一个名为pmf的函数，然后使用该函数的返回值作为指针指向成
员运算符（。*）的运算对象。然而pmf并不是一个函数，因此代码将发生错误。
因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这
样的指针进行函数调用时，括号必不可少：（C：：*p）（parms）和
（obj。*p）（args）。
使用成员指针的类型别名
使用类型别名或typedef（参见2。5。1节，第60页）可以让成员指针更容易理解。
例如，下面的类型别名将Action定义为两参数get函数的同义词：
//Action是一种可以指向Screen成员函数的指针，它接受两个pos实参，返回一个char
usingAction=
char（Screen：：*）（Screen：：pos，Screen：：pos）const；

Page769
19。4类成员指针
Action是某类型的另外一个名字，该类型是“指向Screen类的常量成员函数的指针，
其中这个成员函数接受两个pos形参，返回一个char”。通过使用Action，我们可以
简化指向get的指针定义：
Actionget=&Screen：：get；
//get指向Screen的get成员
和其他函数指针类似，我们可以将指向成员函数的指针作为某个函数的返回类型或形
参类型。其中，指向成员的指针形参也可以拥有默认实参：
//action接受一个Screen的引用，和一个指向Screen成员函数的指针
Screen&action（Screen&，Action=&Screen：：get）；
action是包含两个形参的函数，其中一个形参是Screen对象的引用，另一个形参是指
向Screen成员函数的指针，成员函数必须接受两个pos形参并返回一个char。当我们
调用action时，只需将Screen的一个符合要求的函数的指针或地址传入即可：、
ScreenmyScreen；
//等价的调用：
action（myScreen）；
action（myScreen，get）；
action（myScreen，&Screen：：get）；
通过使用类型别名，可以令含有成员指针的代码更易读写。
Note
成员指针函数表
对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数
表当中（参见14。8。3节，第511页）。如果一个类含有几个相同类型的成员，则这样一张
表可以帮助我们从这些成员中选择一个。假定Screen类含有几个成员函数，每个函数负
责将光标向指定的方向移动：
classScreen{
public：
//使用默认实参
//使用我们之前定义的变量get
//显式地传入地址
//其他接口和实现成员与之前一致
Screen&home（）；
Screen&forward（）；
Screen&back（）；
Screen&up（）；
Screen&down（）；
//光标移动函数
}；
这几个新函数有一个共同点：它们都不接受任何参数，并且返回值是发生光标移动的
Screen的引用。
classScreen{
public：
我们希望定义一个move函数，使其可以调用上面的任意一个函数并执行对应的操作。
为了支持这个新函数，我们将在Screen中添加一个静态成员，该成员是指向光标移动函
数的指针的数组：
//其他接口和实现成员与之前一致
//Action是一个指针，可以用任意一个光标移动函数对其赋值
usingAction=Screen&（Screen：：*）（）；
//指定具体要移动的方向，其中enum参见19。3节（第736页）
743
840

Page770
744
841
842
private：
enumDirections{HOME，FORWARD，BACK，UP，DOWN}；
Screen&move（Directions）；
}
staticActionMenu[]；
第19章特殊工具与技术
//函数表
}；
数组Menu依次保存每个光标移动函数的指针，这些函数将按照Directions中枚举成
员对应的偏移量存储。move函数接受一个枚举成员并调用相应的函数：
Screen&Screen：：move（Directionscm）。
{
//运行this对象中索引值为cm的元素
return（this->*Menu[cm]）（）；//Menu[cm]指向一个成员函数
move中的函数调用的原理是：首先获取索引值为cm的Menu元素，该元素是指向Screen
成员函数的指针。我们根据this所指的对象调用该元素所指的成员函数。
当我们调用move函数时，给它传入一个表示光标移动方向的枚举成员：
ScreenmyScreen；
}；
myScreen。move（Screen：：HOME）；//调用myScreen。home
myScreen。move（Screen：：DOWN）；//调用myScreen。down
剩下的工作就是定义并初始化函数表本身了：
Screen：：ActionScreen：：Menu[]={&Screen：：home，
&Screen：：forward，
&Screen：：back，
&Screen：：up，
&Screen：：down，
19。4。2节练习
练习19。14：下面的代码合法吗?如果合法，代码的含义是什么?如果不合法，解释原
因。
autopmf=&Screen：：get_cursor；
pmf=&Screen：：get；
练习19。15：普通函数指针和指向成员函数的指针有何区别?
练习19。16：声明一个类型别名，令其作为指向Sales_data的avg_price成员的指
针的同义词。
练习19。17：为Screen的所有成员函数类型各定义一个类型别名。
19。4。3将成员函数用作可调用对象
如我们所知，要想通过一个指向成员函数的指针进行函数调用，必须首先利用。*运算
符或->*运算符将该指针绑定到特定的对象上。因此与普通的函数指针不同，成员指针不
是一个可调用对象，这样的指针不支持函数调用运算符（参见10。3。2节，第346页）。
因为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给
算法。举个例子，如果我们想在一个string的vector中找到第一个空string，显然

Page771
19。4类成员指针
不能使用下面的语句：
autofp=&string：：empty；//fp指向string的empty函数
//错误，必须使用。*或->*调用成员指针
find_if（svec。begin（），svec。end（），fp）；
find_if算法需要一个可调用对象，但我们提供给它的是一个指向成员函数的指针fp。
因此在findif的內部将执行如下形式的代码，从而导致无法通过编译：
//检查对当前元素的断言是否为真
if（fp（*it））
显然该语句试图调用的是传入的对象，而非函数。
//错误：要想通过成员指针调用函数，必须使用->*运算符
使用function生成一个可调用对象
从指向成员函数的指针获取可调用对象的一种方法是使用标准库模板function（参
见14。8。3节，第511页）：
function<bool（conststring&）>fen=&string：：empty；
find_if（svec。begin（），svec。end（），fcn）；
我们告诉function一个事实：即empty是一个接受string参数并返回bool值的函
数。通常情况下，执行成员函数的对象将被传给隐式的this形参。当我们想要使用
function为成员函数生成一个可调用对象时，必须首先“翻译”该代码，使得隐式的形
参变成显式的。
当一个function对象包含有一个指向成员函数的指针时，function类知道它必
须使用正确的指向成员的指针运算符来执行函数调用。也就是说，我们可以认为在
find_if当中含有类似于如下形式的代码：
//假设it是find_if內部的迭代器，则*it是给定范围内的一个对象
if（fen（*it））
//假设fcn是find_if内部的一个可调用对象的名字
其中，function将使用正确的指向成员的指针运算符。从本质上来看，function类将
函数调用转换成了如下形式：
//假设it是find_if内部的迭代器，则*it是给定范围内的一个对象
if（（（*it）。*p）（））
//假设p是fcn内部的一个指向成员函数的指针
当我们定义一个function对象时，必须指定该对象所能表示的函数类型，即可调
用对象的形式。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个
（一般是隐式的）对象上执行的。同时，我们提供给function的形式中还必须指明对象
是否是以指针或引用的形式传入的。
以定义fcn为例，我们想在string对象的序列上调用find_if，因此我们要求
function生成一个接受string对象的可调用对象。又因为我们的vector保存的是
string的指针，所以必须指定function接受指针：
vector<string*>pvec；
function<bool（conststring*）>fp=&string：：empty；
//fp接受一个指向string的指针，然后使用->*调用empty
find_if（pvec。begin（），pvec。end（），fp）；
使用mem_fn生成一个可调用对象
通过上面的介绍可知，要想使用function，我们必须提供成员的调用形式。我们也
745
843

Page772
746
C++
11
844
第19章特殊工具与技术
可以采取另外一种方法，通过使用标准库功能mem_fn来让编译器负责推断成员的类型。
和function一样，memfn也定义在functional头文件中，并且可以从成员指针生
成一个可调用对象；和function不同的是，memfn可以根据成员指针的类型推断可调
用对象的类型，而无须用户显式地指定：
findif（svec。begin（），svec。end（），mem_fn（&string：：empty））；
我们使用mem_fn（&string：：empty）生成一个可调用对象，该对象接受一个string
实参，返回一个bool值。
mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用：
autof=mem_fn（&string：：empty）；//f接受一个string或者一个string*
f（*svec。begin（））；
//正确：传入一个string对象，f使用。*调用empty
//正确：传入一个string的指针，f使用->*调用empty
f（&svec[0]）；
实际上，我们可以认为mem_fn生成的可调用对象含有一对重载的函数调用运算符：一个
接受string*，另一个接受string&。
使用bind生成一个可调用对象
出于完整性的考虑，我们还可以使用bind（参见10。3。4节，第354页）从成员函数
生成一个可调用对象：
//选择范围中的每个string，并将其bind到empty的第一个隐式实参上
autoit=find_if（svec。begin（），svec。end（），
bind（&string：：empty，_1））；
和function类似的地方是，当我们使用bind时，必须将函数中用于表示执行对象的隐
式形参转换成显式的。和memfn类似的地方是，bind生成的可调用对象的第一个实参
既可以是string的指针，也可以是string的引用：
autof=bind（&string：：empty，1）；
f（*svec。begin（））；//正确：实参是一个string，f使用。*调用empty
f（&svec[0]）；
//正确：实参是一个string的指针，f使用->*调用empty
19。4。3节练习
练习19。18：编写一个函数，使用countif统计在给定的vector中有多少个空
string。
练习19。19：编写一个函数，令其接受vector<Sales_data>并查找平均价格高于某
个值的第一个元素。
19。5嵌套类
一个类可以定义在另一个类的内部，前者称为嵌套类（nestedclass）或嵌套类型（nested
type）。嵌套类常用于定义作为实现部分的类，比如我们在文本查询示例中使用的
QueryResult类（参见12。3节，第430页）。
嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套类
的对象是相互独立的。在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层
类的对象中也不包含任何嵌套类定义的成员。

Page773
19。5嵌套类
嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。和其他嵌套
的名字一样，嵌套类的名字不会和别的作用域中的同一个名字冲突。
嵌套类中成员的种类与非嵌套类是一样的。和其他类类似，嵌套类也使用访问限定符
来控制外界对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌
套类对外层类的成员也没有特殊的访问权限。
嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外
层类决定。位于外层类public部分的嵌套类实际上定义了一种可以随处访问的类型；位
于外层类protected部分的嵌套类定义的类型只能被外层类及其友元和派生类访问；位
于外层类private部分的嵌套类定义的类型只能被外层类的成员和友元访问。
声明一个嵌套类
我们为12。3。2节（第432页）的TextQuery类定义了一个名为QueryResult的配
套类，这两个类密切相关｡QueryResult类的主要作用是表示TextQuery对象上query
操作的结果，显然将QueryResult用作其他目的没有任何意义。为了充分体现这种紧密
的相关性，我们可以把QueryResult定义成TextQuery的成员。
classTextQuery{
public：
classQueryResult；
//其他成员与12。3。2节（第432页）一致
}；
我们只需对原来的TextQuery类做一处改动，即将QueryResult声明成嵌套类。因为
QueryResult是一个类型成员（参见7。4。1节，第254页），所以我们必须对它先声明后
使用，尤其是必须先声明QueryResult，再将它作为query成员的返回类型。类的其
他成员没有任何变化。
//嵌套类稍后定义
在外层类之外定义一个嵌套类
我们在TextQuery内声明了QueryResult，但是没有给出它的定义。和成员函数
一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。
当我们在外层类之外定义一个嵌套类时，必须以外层类的名字限定嵌套类的名字：
//QueryResult是TextQuery的成员，下面的代码负责定义QueryResult
classTextQuery：：QueryResult{
//位于类的作用域内，因此我们不必对QueryResult形参进行限定
friendstd：：ostream&
public：
print（std：：ostream&，constQueryResult&）；
//无须定义QueryResult：：line_no
//嵌套类可以直接使用外层类的成员，无须对该成员的名字进行限定
QueryResult（std：：string，
std：：shared_ptr<std：：set<line_no>>，
std：：shared_ptr<std：：vector<std：：string>>）；
//其他成员与12。3。2节（第432页）一致
}；
和原来的类相比唯一的改动是，我们无须在QueryResult内定义line_no成员了。因
为该成员属于TextQuery，所以QueryResult可以直接访问它而不必再定义一次。
747
845

Page774
748
WARNING
第19章特殊工具与技术
在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型（参见
7。3。3节，第250页）。
定义嵌套类的成员
在这个版本的QueryResult类中，我们并没有在类的内部定义其构造函数。要想为
其定义构造函数，必须指明QueryResult是嵌套在TextQuery的作用域之内的。具体
做法是使用外层类的名字限定嵌套类的名字：
//QueryResult类嵌套在TextQuery类中
//下面的代码为QueryResult类定义名为QueryResult的成员
TextQuery：：QueryResult：：QueryResult（stringsr
shared_ptr<set<line_no>>pr
shared_ptr<vector<string>>f）：
sought（s），lines（p），file（f）{}
从右向左阅读函数的名字可知我们定义的是QueryResult类的构造函数，而
QueryResult类是嵌套在TextQuery类中的。该构造函数除了把实参值赋给对应的数
据成员之外，没有做其他工作。
嵌套类的静态成员定义
如果QueryResult声明了一个静态成员，则该成员的定义将位于TextQuery的作
846用域之外。例如，假设QueryResult有一个静态成员，则该成员的定义将形如：
//QueryResult类嵌套在TextQuery类中，
//下面的代码为QueryResult定义一个静态成员
intTextQuery：：QueryResult：：static_mem=1024；
嵌套类作用域中的名字查找
名字查找的一般规则（参见7。4。1节，第254页）在嵌套类中同样适用。当然，因为
嵌套类本身是一个嵌套作用域，所以还必须查找嵌套类的外层作用域。这种作用域嵌套的
性质正好可以说明为什么我们不在QueryResult的嵌套版本中定义line_no。原来的
QueryResult类定义了该成员，从而使其成员可以避免使用TextQuery：：line_no的
形式。然而QueryResult的嵌套类版本本身就是定义在TextQuery中的，所以我们不
需要再使用typedef。嵌套的QueryResult无须说明line_no属于TextQuery就可
以直接使用它。
如我们所知，嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何
其他类型成员一样使用嵌套类的名字。因为QueryResult嵌套在TextQuery中，所以
TextQueryquery
QueryResult：
//返回类型必须指明QueryResult是一个嵌套类
TextQuery：：QueryResult
TextQuery：：query（conststring&sought）const
{
//如果我们没有找到sought，则返回set的指针
staticshared_ptr<set<line_no>>nodata（newset<line_no>）；
//使用find而非下标以避免向wm中添加单词
autoloc=wm。find（sought）；
if（loc==wm。end（））

Page775
19。6union：一种节省空间的类
else
returnQueryResult（sought，nodata，file）；
returnQueryResult（sought，loc->second，file）；
//没有找到
和过去一样，返回类型不在类的作用域中（参见7。4节，第253页），因此我们必须指明函
数的返回值是TextQuery：：QueryResult类型。不过在函数体内部我们可以直接访问
QueryResult，比如上面的return语句就是这样。
嵌套类和外层类是相互独立的
尽管嵌套类定义在其外层类的作用域中，但是读者必须谨记外层类的对象和嵌套类的
对象没有任何关系。嵌套类的对象只包含嵌套类定义的成员；同样，外层类的对象只包含
外层类定义的成员，在外层类对象中不会有任何嵌套类的成员。
说得再具体一些，TextQuery：：query的第二条return语句
returnQueryResult（sought，loc->second，file）；
使用了TextQuery对象的数据成员，而query正是用它们来初始化QueryResult对847
象的。因为在一个QueryResult对象中不包含其外层类的成员，所以我们必须使用上述
成员构造我们返回的QueryResult对象。
19。5节练习
练习19。20：将你的QueryResult类嵌套在TextQuery中，然后重新运行12。3。2节
（第435页）中使用了TextQuery的程序。
19。6union：一种节省空间的类
联合（union）是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻
只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成
员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的
数据成员。和其他类一样，一个union定义了一种新类型。
类的某些特性对union同样适用，但并非所有特性都如此。union不能含有引用类
型的成员，除此之外，它的成员可以是绝大多数类型。在C++11新标准中，含有构造函数
或析构函数的类类型也可以作为union的成员类型。union可以为其成员指定public、
protected和private等保护标记。默认情况下，union的成员都是公有的，这一点
与struct相同。
union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能
继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。
定义union
union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值。举个
例子，假设我们需要处理一些不同种类的数字数据和字符数据，则在此过程中可以定义一
个union来保存这些值：
749
//Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种
unionToken{

Page776
750
848
//默认情况下成员是公有的
char
cval；
int
ival；
doubledval；
}；
在定义一个union时，首先是关键字union，随后是该union的（可选的）名字以及花
括号内的一组成员声明。上面的代码定义了一个名为Token的union，它可以保存一个
值，这个值的类型可能是char、int或double中的一种。
使用union类型
union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化
的。我们可以像显式地初始化聚合类（参见7。5。5节，第266页）一样使用一对花括号内
的初始值显式地初始化一个union：
Tokenfirst_token={'a'}；
Tokenlasttoken；
Token*pt=newToken；
第19章特殊工具与技术
如果提供了初始值，则该初始值被用于初始化第一个成员。因此，first_token的初始
化过程实际上是给cval成员赋了一个初值。
我们使用通用的成员访问运算符访问一个union对象的成员：
lasttoken。cval='z'；
pt->ival42；
为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用
union时，必须清楚地知道当前存储在union中的值到底是什么类型。如果我们使用错
误的数据成员或者为错误的数据成员赋值，则程序可能崩溃或出现异常行为，具体的情况
根据成员的类型而有所不同。
union{
匿名union
匿名union（anonymousunion）是一个未命名的union，并且在右花括号和分号之
间没有任何声明（参见2。6。1节，第65页）。一旦我们定义了一个匿名union，编译器就
自动地为该union创建一个未命名的对象：
//匿名union
//初始化cval成员
//未初始化的Token对象
//指向一个未初始化的Token对象的指针
charcval；
intival；
doubledval；
}；//定义一个未命名的对象，我们可以直接访问它的成员
cval='c'；
ival=42；
Note
//为刚刚定义的未命名的匿名union对象赋一个新值
//该对象当前保存的值是42
在匿名union的定义所在的作用域内该union的成员都是可以直接访问的。
匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。
含有类类型成员的union
C++的早期版本规定，在union中不能含有定义了构造函数或拷贝控制成员的类类型

Page777
19。6union：一种节省空间的类
成员。C++11新标准取消了这一限制。不过，如果union的成员类型定义了自己的构造
函数和/或拷贝控制成员，则该union的用法要比只含有内置类型成员的union复杂得多。
当union包含的是内置类型的成员时，我们可以使用普通的赋值语句改变union保
存的值。但是对于含有特殊类类型成员的union就没这么简单了。如果我们想将union
的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须分别构造
或析构该类类型的成员：当我们将union的值改为类类型成员对应的值时，必须运行该
类型的构造函数；反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的
析构函数。
当union包含的是內置类型的成员时，编译器将按照成员的次序依次合成默认构造
函数或拷贝控制成员。但是如果union含有类类型的成员，并且该类型自定义了默认构
造函数或拷贝控制成员，则编译器将为union合成对应的版本并将其声明为删除的（参
见13。1。6节，第450页）。
例如，string类定义了五个拷贝控制成员以及一个默认构造函数。如果union含
有string类型的成员，并且没有自定义默认构造函数或某个拷贝控制成员，则编译器将
合成缺少的成员并将其声明成删除的。如果在某个类中含有一个union成员，而且该
union含有删除的拷贝控制成员，则该类与之对应的拷贝控制操作也将是删除的。
使用类管理union成员
对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我
们通常把含有类类型成员的union内嵌在另一个类当中。这个类可以管理并控制与
union的类类型成员有关的状态转换。举个例子，我们为union添加一个string成员，
并将我们的union定义成匿名union，最后将它作为Token类的一个成员。此时，Token
类将可以管理union的成员。
为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该
对象称为union的判别式（discriminant）。我们可以使用判别式辨认union存储的值。
为了保持union与其判别式同步，我们将判别式也作为Token的成员。我们的类将定义
一个枚举类型（参见19。3节，第736页）的成员来追踪其union成员的状态。
在我们的类中定义的函数包括默认构造函数、拷贝控制成员以及一组赋值运算符，这
些赋值运算符可以将union的某种类型的值赋给union成员：
classToken{
public：
//因为union含有一个string成员，所以Token必须定义拷贝控制成员
//定义移动构造函数和移动赋值运算符的任务留待本节练习完成
Token（）：tok（INT），ival{0}{}
Token（constToken&t）：tok（t。tok）{copyUnion（t）；}
Token&operator=（constToken&）；
//如果union含有一个string成员，则我们必须销毁它，参见19。1。2节（第729页）
~Token（）{if（tok==STR）sval。~string（）；}
//下面的赋值运算符负责设置union的不同成员
Token&operator=（conststd：：string&）；
Token&operator=（char）；
Token&operator=（int）；
Token&operator=（double）；
private：
751
849
C++
11
850

Page778
752
851
enum{INT，CHAR，DBL，STR}tok；//判别式
union{//
匿名union
char
cval；
int
ival；
doubledval；
第19章特殊工具与技术
std：：stringsval；
}；//每个Token对象含有一个该未命名union类型的未命名成员
//检查判别式，然后酌情拷贝union成员
voidcopyUnion（constToken&）；
}；
我们的类定义了一个嵌套的、未命名的、不限定作用域的枚举类型（参见19。3节，第736
页），并将其作为tok成员的类型。其中，tok的声明位于枚举类型定义的右侧花括号之
后，以及表示该枚举类型定义结束的分号之前，因此，tok的类型就是当前这个未命名的
enum类型（参见2。6。1节，第65页）。
我们使用tok作为判别式。当union存储的是一个int值时，tok的值是INT；当
union存储的是一个string值时，tok的值是STR；以此类推。
类的默认构造函数初始化判别式以及union成员，令其保存int值0。
因为我们的union含有一个定义了析构函数的成员，所以必须为union也定义一个
析构函数以销毁string成员。和普通的类类型成员不一样，作为union组成部分的类
成员无法自动销毁。因为析构函数不清楚union存储的值是什么类型，所以它无法确定
应该销毁哪个成员。
我们的析构函数检查被销毁的对象中是否存储着string值。如果有，则类的析构函
数显式地调用string的析构函数（参见19。1。2节，第729页）释放该string使用的內
存；反之，如果union存储的值是内置类型，则类的析构函数什么也不做。
管理判别式并销毁string
类的赋值运算符将负责设置tok并为union的相应成员赋值。和析构函数一样，这
些运算符在为union赋新值前必须首先销毁string：
Token&Token：：operator=（inti）
{
if（tok==STR）sval。~string（）；
ival=i；
tok=INT；
return*this；
//如果当前存储的是string，释放它
//为成员赋值
//更新判别式
}
如果union的当前值是string，则我们必须先调用string的析构函数销毁这个
string，然后再为union赋新值。清除了string成员之后，我们将给定的值赋给与运
算符形参类型相匹配的成员。在此例中，形参类型是int，所以我们赋值给ival。随后
更新判别式并返回结果。
double和char版本的赋值运算符与int赋值运算符非常相似，读者可以在本节的
练习中尝试使用这两个运算符。string版本与其他几个有所区别，原因是string版本
必须管理与string类型有关的转换：
Token&Token：：operator=（conststd：：string&s）
{

Page779
19。6union：一种节省空间的类
if（tok==STR）
sval=S；
else
new（&sval）string（s）；
tok=STR；
return*this；
在此例中，如果union当前存储的是string，则我们可以使用普通的string赋值运
算符直接为其赋值。如果union当前存储的不是string，则我们找不到一个已存在的
string对象供我们调用赋值运算符｡此时，我们必须先利用定位new表达式（参见19。1。2
节，第729页）在内存中为sval构造一个string，然后将该string初始化为string
形参的副本，最后更新判别式并返回结果。
}
//如果当前存储的是string，可以直接赋值
管理需要拷贝控制的联合成员
和依赖于类型的赋值运算符一样，拷贝构造函数和赋值运算符也需要先检验判别式以
明确拷贝所采用的方式。为了完成这一任务，我们定义一个名为copyUnion的成员。
当我们在拷贝构造函数中调用copyUnion时，union成员将被默认初始化，这意味
着编译器会初始化union的第一个成员。因为string不是第一个成员，所以显然union
成员保存的不是string。在赋值运算符中情况有些不一样，有可能union已经存储了
一个string。我们将在赋值运算符中直接处理这种情况。copyUnion假设如果它的形
参存储了string，则它一定会构造自己的string：
voidToken：：copyUnion（constToken&t）
{
//否则需要先构造一个string
//更新判别式
switch（t。tok）{
caseToken：：INT：ival=t。ival；break；
caseToken：：CHAR：cval=t。cval；break；
caseToken：：DBL：dval=t。dval；break；
//要想拷贝一个string可以使用定位new表达式构造它，参见19。1。2节（第729页）
caseToken：：STR：new（&sval）string（t。sval）；break；
}
该函数使用一个switch语句（参见5。3。2节，第159页）检验判别式。对于内置类型来852
说，我们把值直接赋给对应的成员；如果拷贝的是一个string，则需要构造它。
赋值运算符必须处理string成员的三种可能情况：左侧运算对象和右侧运算对象都
是string、两个运算对象都不是string、只有一个运算对象是string：
Token&Token：：operator=（constToken&t）
{
else
//如果此对象的值是string而t的值不是，则我们必须释放原来的string
if（tok==STR&&t。tok!=STR）sval。string（）；
if（tok==STR&&t。tok==STR）
sval=t。sval；//无须构造一个新string
753
copyUnion（t）；//如果t。tok是STR，则需要构造一个string
tok=t。tok；
return*this；

Page780
754
853
如果作为左侧运算对象的union的值是string但右侧运算对象的值不是，则我们必须
先释放原来的string再给union成员赋一新值。如果两侧运算对象的值都是string，
则我们可以使用普通的string赋值运算符完成拷贝。否则，我们调用copyUnion进行
赋值。在copyUnion内部，如果右侧运算对象是string，则我们在左侧运算对象的
union成员内构造一个新string；如果两端都不是string，则直接执行普通的赋值操
作就可以了。
19。6节练习
练习19。21：编写你自己的Token类。
练习19。22：为你的Token类添加一个Salesdata类型的成员。
练习19。23：为你的Token类添加移动构造函数和移动赋值运算符。
练习19。24：如果我们将一个Token对象赋给它自己将发生什么情况?
练习19。25：编写一系列赋值运算符，令其分别接受union中各种类型的值。
19。7局部类
类可以定义在某个函数的内部，我们称这样的类为局部类（localclass）。局部类定义
的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。
Note
局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部
类的作用与嵌套类相比相差很远。
在实际编程的过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的
复杂性不可能太高。局部类的成员函数一般只有几行代码，否则我们就很难读懂它了。
类似的，在局部类中也不允许声明静态数据成员，因为我们没法定义这样的成员。
第19章特殊工具与技术
局部类不能使用函数作用域中的变量
局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域
定义的类型名、静态变量（参见6。1。1节，第185页）以及枚举成员。如果局部类定义在
某个函数内部，则该函数的普通局部变量不能被该局部类使用：
inta，val；
voidfoo（intval）
{
staticintsi；
enumLoc{a=1024，b}；
//Bar是foo的局部类
structBar{
LoclocVal；
intbarVal；
voidfooBar（Locl=a）
{
barVal=val；
//正确：使用一个局部类型名
//正确：默认实参是Loc：：a
//错误：val是foo的局部变量

Page781
19。8固有的不可移植的特性
}；
//
barVal=：：val；
barVal=si；
locVal=b；
常规的访问保护规则对局部类同样适用
外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明
为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的
代码非常有限。局部类已经封装在函数作用域中，通过信息隐藏进一步封装就显得没什么
必要了。
voidfoo（）
{
局部类中的名字查找
局部类内部的名字查找次序与其他类相似。在声明类的成员时，必须先确保用到的名
字位于作用域中，然后再使用该名字。定义成员时用到的名字可以出现在类的任意位置。
如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则854
在外层函数所在的作用域中查找。
嵌套的局部类
可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不
过，嵌套类必须定义在与局部类相同的作用域中。
classBar{
public：
//正确：使用一个全局对象
//正确：使用一个静态局部对象
//正确：使用一个枚举成员
}；
//
classNested；//声明Nested类
}；
//定义Nested类
classBar：：Nested{
//
}
和往常一样，当我们在类的外部定义成员时，必须指明该成员所属的作用域。因此在上面
的例子中，Bar：：Nested的意思是Nested是定义在Bar的作用域内的一个类。
局部类內的嵌套类也是一个局部类，必须遵循局部类的各种规定。嵌套类的所有成员
都必须定义在嵌套类内部。
755
19。8固有的不可移植的特性
为了支持低层编程，C++定义了一些固有的不可移植（nonportable）的特性。所谓不
可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移
到另一台机器上时，通常需要重新编写该程序。算术类型的大小在不同机器上不一样（参
见2。1。1节，第30页），这是我们使用过的不可移植特性的一个典型示例。

Page782
756
855
本节将介绍C++从C语言继承而来的另外两种不可移植的特性：位域和volatile
限定符。此外，我们还将介绍链接指示，它是C++新增的一种不可移植的特性。
19。8。1位域
类可以将其（非静态）数据成员定义成位域（bit-field），在一个位域中含有一定数量
的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。
Note
位域在内存中的布局是与机器相关的。
位域的类型必须是整型或枚举类型（参见19。3节，第736页）。因为带符号位域的行
为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。位域的声
明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占
的二进制位数：
typedefunsignedintBit；
classFile{
}；
public：
第19章特殊工具与技术
Bitmode：2；
Bitmodified：1；
Bitprot_owner：3；
Bitprot_group：3；
Bitprot_world：3；
//File的操作和数据成员
WARNING
//mode占2位
//modified占1位
//prot_owner占3位
//prot_group占3位
//prot_world占3位
//文件类型以八进制的形式表示，参见2。1。3节（第35页）
enummodes{READ=01，WRITE=02，EXECUTE=03}；
File&open（modes）；
voidclose（）；
voidwrite（）；
boolisRead（）const；
voidsetWrite（）；
mode位域占2个二进制位，modified只占1个，其他成员则各占3个。如果可能的话，
在类的内部连续定义的位域压缩在同一整数的相邻位，从而提供存储压缩。例如在之前的
声明中，五个位域可能会存储在同一个unsignedint中。这些二进制位是否能压缩到
一个整数中以及如何压缩是与机器相关的。
取地址运算符（&）不能作用于位域，因此任何指针都无法指向类的位域。
通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将
因具体实现而定。
modified=1；
使用位域
访问位域的方式与访问类的其他数据成员的方式非常相似：
voidFile：：write（）
{

Page783
19。8固有的不可移植的特性
//。。。
}
voidFile：：close（）
{
if（modified）
//
保存內容
}
通常使用內置的位运算符（参见4。8节，第136页）操作超过1位的位域：
File&File：：open（File：：modesm）
{
WARNING
mode|=READ；
//其他处理
if（m&WRITE）
//按照读/写方式打开文件
return*this；
}
如果一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的
值：
19。8。2volatile限定符
//按默认方式设置READ
inlineboolFile：：isRead（）const{returnmode&READ；}
inlinevoidFile：：setWrite（）{mode|=WRITE；}
//如果打开了READ和WRITE
volatile的确切含义与机器有关，只能通过阅读编译器文档来理解。要想让
使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要
对该程序进行某些改变。
直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程
控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控
制或检测之外被改变时，应该将该对象声明为volatile。关键字volatile告诉编译
器不应对这样的对象进行优化。
volatileTask*currtask；
volatileintiax[max_size]；
volatileScreenbitmapBuf；
volatile限定符的用法和const很相似，它起到对类型额外修饰的作用：
volatileintdisplay_register；//该int值可能发生改变
//curr_task指向一个volatile对象
//iax的每个元素都是volatile
//bitmapBuf的每个成员都是volatile
const和volatile限定符互相没什么影响，某种类型可能既是const的也是
volatile的，此时它同时具有二者的属性。
就像一个类可以定义const成员函数一样，它也可以将成员函数定义成volatile
的。只有volatile的成员函数才能被volatile的对象调用。
2。4。2节（第56页）描述了const限定符和指针的相互作用，在volatile限定符
和指针之间也存在类似的关系。我们可以声明volatile指针、指向volatile对象的
指针以及指向volatile对象的volatile指针：
volatileintv；
//v是一个volatileint
757
856
857

Page784
758
int*volatilevip；//vip是一个volatile指针，它指向int
volatileint*ivp；//ivp是一个指针，它指向一个volatileint
//vivp是一个volatile指针，它指向一个volatileint
volatileint*volatilevivp；
int*ip
ivp&V；
vivp&V；
=&V；
第19章特殊工具与技术
和const一样，我们只能将一个volatile对象的地址（或者拷贝一个指向
volatile类型的指针）赋给一个指向volatile的指针。同时，只有当某个引用是
volatile的时，我们才能使用一个volatile对象初始化该引用。
//错误：必须使用指向volatile的指针
//正确：ivp是一个指向volatile的指针
//正确：vivp是一个指向volatile的volatile指针
合成的拷贝对volatile对象无效
const和volatile的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋
值运算符初始化volatile对象或从volatile对象赋值。合成的成员接受的形参类型
是（非volatile）常量引用，显然我们不能把一个非volatile引用绑定到一个
volatile对象上。
classFoo{
public：
如果一个类希望拷贝、移动或赋值它的volatile对象，则该类必须自定义拷贝或
移动操作。例如，我们可以将形参类型指定为constvolatile引用，这样我们就能利
用任意类型的Foo进行拷贝或赋值操作了：
Note
Foo（constvolatileFoo&）；//从一个volatile对象进行拷贝
//将一个volatile对象赋值给一个非volatile对象
Foo&operator=（volatileconstFoo&）；
//将一个volatile对象赋值给一个volatile对象
Foofoperator=（volatileconstFoo&）volatile；
//Foo类的剩余部分
尽管我们可以为volatile对象定义拷贝和赋值操作，但是一个更深层次的问题是拷贝
volatile对象是否有意义呢?不同程序使用volatile的目的各不相同，对上述问题
的回答与具体的使用目的密切相关。
19。8。3链接指示：extern"C"
C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。像
所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，并且该声明必须指
定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用的方式与处理
858普通C++函数的方式相同，但是生成的代码有所区别｡C++使用链接指示（linkagedirective）
指出任意非C++函数所用的语言。
要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我
们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼
容的。

Page785
19。8固有的不可移植的特性
声明一个非C++的函数
链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义
的内部。同样的链接指示必须在函数的每个声明中都出现。
举个例子，接下来的声明显示了cstring头文件的某些C函数是如何声明的：
//可能出现在C++头文件<cstring>中的链接指示
//单语句链接指示
extern"C"sizetstrlen（constchar*）；
//复合语句链接指示
extern"C"{
intstrcmp（constchar*，constchar*）；
char*strcat（char*，constchar*）；
}
链接指示的第一种形式包含一个关键字extern，后面是一个字符串字面值常量以及一个
“普通的”函数声明。
其中的字符串字面值常量指出了编写函数所用的语言｡编译器应该支持对C语言的链
接指示。此外，编译器也可能会支持其他语言的链接指示，如extern"Ada"、extern
"FORTRAN"等。
链接指示与头文件
我们可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个
链接。花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽
略，花括号中声明的函数名字就是可见的，就好像在花括号之外声明的一样。
多重声明的形式可以应用于整个头文件。例如，C++的cstring头文件可能形如：
//复合语句链接指示
extern"C"{
#include<string。h>
Note
//操作C风格字符串的C函数
}
当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声
明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带
链接指示的函数，则该函数的链接不受影响。
C++从C语言继承的标准库函数可以定义成C函数，但并非必须：决定使用C
还是C++实现C标准库，是每个C++实现的事情。
指向extern"C"函数的指针
编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，
它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与
函数本身使用相同的链接指示：
//pf指向一个C函数，该函数接受一个int返回void
extern"C"void（*pf）（int）；
当我们使用pf调用函数时，编译器认定当前调用的是一个C函数。
指向C函数的指针与指向C++函数的指针是不一样的类型。一个指向C函数的指针
759
859

Page786
760
860
不能用在执行初始化或赋值操作后指向C++函数，反之亦然。就像其他类型不匹配的问题
一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误：
void（*pfl）（int）；
extern"C"void（*pf2）（int）；
pf1
pf2；
WARNING
=
//指向一个C++函数
//指向一个C函数
//错误：pf1和pf2的类型不同
第19章特殊工具与技术
有的C++编译器会接受之前的这种赋值操作并将其作为对语言的扩展，尽管从
严格意义上来看它是非法的。
链接指示对整个声明都有效
当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数
指针也有效：
//f1是一个C函数，它的形参是一个指向C函数的指针
extern"C"voidfl（void（*）（int））；
这条声明语句指出f1是一个不返回任何值的C函数。它有一个类型是函数指针的形参，
其中的函数接受一个int形参返回为空。这个链接指示不仅对f1有效，对函数指针同样
有效。当我们调用f1时，必须传给它一个C函数的名字或者指向C函数的指针。
因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入
一个指向C函数的指针，则必须使用类型别名（参见2。5。1节，第60页）：
//FC是一个指向C函数的指针
extern"C"typedefvoidFC（int）；
//f2是一个C++函数，该函数的形参是指向C函数的指针
voidf2（FC*）；
导出C++函数到其他语言
通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序
中可用：
//calc函数可以被C程序调用
extern"C"doublecalc（doubledparm）{/*。。。*/}
编译器将为该函数生成适合于指定语言的代码。
值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，
我们不太可能把一个C++类的对象传给C程序，因为C程序根本无法理解构造函数、析
构函数以及其他类特有的操作。
对链接到C的预处理器的支持
有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C++版本的
程序时预处理器定义__cplusplus（两个下画线）。利用这个变量，我们可以在编译
C++程序的时候有条件地包含进来一些代码：
#ifdefcplusplus
//正确：我们正在编译C++程序
extern"C"
#endif
intstrcmp（constchar*，constchar*）；

Page787
19。8固有的不可移植的特性
重载函数与链接指示
链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为
该语言实现链接指示的编译器很可能也支持重载这些C++的函数。
C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组
重载函数中的某一个了：
//错误：两个extern"C"函数的名字相同
extern"C"voidprint（constchar*）；
extern"C"voidprint（int）；
如果在一组重载函数中有一个是C函数，则其余的必定都是C++函数：
classSmallInt{/*。。。*/}；
classBigNum{/*。。。*/}；
//C函数可以在C或C++程序中调用
//C++函数重载了该函数，可以在C++程序中调用
extern"C"doublecalc（double）；
externSmallIntcalc（constSmallInt&）；
externBigNumcalc（constBigNum&）；
C版本的calc函数可以在C或C++程序中调用，而使用了类类型形参的C++函数只能在
C++程序中调用。上述性质与声明的顺序无关。
19。8。3节练习
练习19。26：说明下列声明语句的含义并判断它们是否合法：
extern"C"intcompute（int*，int）；
extern"C"doublecompute（double*，double）；
761
861

Page788
762
862小结
C++为解决某些特殊问题设置了一系列特殊的处理机制。
有的程序需要精确控制内存分配过程，它们可以通过在类的内部或在全局作用域中自
定义operatornew和operatordelete来实现这一目的。如果应用程序为这两个操
作定义了自己的版本，则new和delete表达式将优先使用应用程序定义的版本。
有的程序需要在运行时直接获取对象的动态类型，运行时类型识别（RTTI）为这种程
序提供了语言级别的支持。RTTI只对定义了虚函数的类有效；对没有定义虚函数的类，
虽然也可以得到其类型信息，但只是静态类型。
当我们定义指向类成员的指针时，在指针类型中包含了该指针所指成员所属类的类型
信息。成员指针可以绑定到该类当中任意一个具有指定类型的成员上。当我们解引用成员
指针时，必须提供获取成员所需的对象。
C++定义了另外几种聚集类型：
嵌套类，定义在其他类的作用域中，嵌套类通常作为外层类的实现类。
•union，是一种特殊的类，它可以定义几个数据成员但是在任意时刻只有一个成员
有值，union通常嵌套在其他类的内部。
•局部类，定义在函数的内部，局部类的所有成员都必须定义在类内，局部类不能含
有静态数据成员。
C++支持几种固有的不可移植的特性，其中位域和volatile使得程序更容易访问硬
件；链接指示使得程序更容易访问用其他语言编写的代码。
术语表
匿名union（anonymousunion）未命名的
union，不能用于定义对象。匿名union
的成员也是外层作用域的成员。匿名union
不能包含成员函数，也不能包含私有成员
或受保护的成员。
第19章特殊工具与技术
位域（bit-field）特殊的类成员，该成员含
有一个整型值以指定为其分配的二进制位
数。如果可能的话，在类中连续定义的位
域将被压缩在一个普通的整数值当中。
判别式（discriminant）是一种使用一个对
象判断union的当前值类型的编程技术。
dynamic_cast是一个运算符，执行从基类
向派生类的带检查的强制类型转换。当基
类中至少含有一个虚函数时，该运算符负
863责检查指针或引用所绑定的对象的动态类
型。如果对象类型与目标类型（或其派生
类）一致，则类型转换完成。否则，指针
转换将返回一个值为0的指针；引用转换
将抛出一个异常。
枚举类型（enumeration）将一组整型常量
命名后聚合在一起形成的类型。
枚举成员（enumerator）是枚举类型的成
员。枚举成员是常量，可以用在任何需要
整型常量的地方。
free是定义在cstdlib中的低层函数，
负责释放内存。free只能释放由malloc
分配的内存。
链接指示（linkagedirective）支持C++程
序调用其他语言编写的函数的一种机制。
所有编译器都应支持调用C++和C函数，
至于是否支持其他语言则由编译器决定。
局部类（localclass）定义在函数中的类。
局部类只有在其外层函数内可见。局部类