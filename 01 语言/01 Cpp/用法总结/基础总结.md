# 变量

## 声明和定义的关系

为了支持分离式编译，C++语言将声明和定义区分开来：

-   声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
-   定义(definition)负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：

```
extern int i; //声明i而非定义i
int j; //声明并定义j
```

任何包含了显式初始化的声明即成为定义。给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了:

```
extern double pi = 3.1416; //定义
```


在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

**变量能且只能被定义一次，但是可以被多次声明。**如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

## 复合类型

### 引用

1.   引用必须被初始化
2.   引用不是一个对象，所以不能定义引用的引用

### 指针

#### 指针基础

指针是一个变量，其存储的是值的地址，而不是值本身。

对变量应用地址运算符(&)，就可以获得它的位置：

```cpp
int val = 100;
cout << "value of val = " << val << endl;
cout << "address of val = " << &val << endl;
```

```
value of val = 100
address of val = 0x7ffee26979f8//前面的0省略了
```

指针用于存储值的地址。指针名表示的是地址。`*`运算符被称为间接值(indirect velue )或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址处存储的值。例如，假设manly是一个指针，则manly表示的是一个地址，而`*`manly表示存储在该地址处的值。`*`manly与常规int变量等效。

```cpp
int val = 100;
int *ptr_val;
ptr_val = &val;
cout << val << endl;
cout << &val << endl;
cout << ptr_val << endl;
cout << *ptr_val << endl;
```

```
100
0x7ffee7eb59f8
0x7ffee7eb59f8
100
```

这里引用《C++ Primer Plus》的话，`*`和`&`用在变量val上，就像硬币的正反面，`*val`和`val`表示值，`val`和`&val`表示地址。看上面的小例子会更好理解。

#### 指针的危险

在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。

```cpp
int *p1;
*p1 = 1200;
cout << p1 << endl;
cout << *p1 << endl;
```

```
0x7ffeeb5e6a18
1200
```

p1是一个指针，但它没有被初始化。1200不知道会存放在哪。由于p1没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储1200的地址。如果p1的值碰巧为100，计算机将把数据放在地址100上，即使这恰巧是程序代码的地址。p1指向的地方很可能并不是所要存储1200的地方，这种错误可能会导致一些最隐匿、最难以跟踪的bug。

**警告：一定要在对指针应用解除引用运算符`*`之前，将指针初始化为一个确定的的地址。**

#### 指针和数组

```cpp
void test_array_fun() {
    int arr[4] = {1, 2, 3, 4};//数组
    int *ptr_arr = arr;//数组指针
    cout << "size of int = " << sizeof(int) << endl;
    cout << "size of arr = " << sizeof(arr) << endl;
    cout << "address of arr = " << &arr << endl;
    cout << "size of ptr_arr's address = " << sizeof(ptr_arr) << endl;
    cout << "address of ptr_arr = " << ptr_arr << endl;
}
```

```
size of int = 4
size of arr = 16
address of arr = 0x7ffee6394a40
size of ptr_arr's address = 8
address of ptr_arr = 0x7ffee6394a40
```

一般情况下，指针可以代替数组，但是还是有一点区别，区别如上。

对数组名sizeof可以得到数组的长度（以字节为单位，下同），而对指针名sizeof只能得到指针地址的长度，这个长度对于同一台机器是死的。

#### 动态分配内存

##### new分配内存

指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在C语言中，可以用库函数malloc()来分配内存；在C++中仍然可以这样做，但C++还有更好的方法：new运算符。

```cpp
int *pt = new int;
*pt = 100;
cout << pt << endl;
cout << *pt << endl;
```

```
0x7fe81dc017a0
100
```

##### 使用delete释放内存

delete运算符，它使得在使用完内存后，能够将其归还给内存池，

```cpp
int *pt = new int;
*pt = 100;
cout << pt << endl;
cout << *pt << endl;

delete pt;
```

这将释放pt指向的内存，但不会删除指针pt本身。例如，可以将pt重新指向另一个新分配的内存块。

**一定要配对地使用new和delete；否则将发生内存泄漏**。

**不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。**

**不能使用delete来释放声明变量所获得的内存**

**只能用delete来释放使用new分配的内存。对空指针使用delete是安全的。**

##### 使用new来创建动态数组

在编译时给数组分配内存被称为**静态联编**，意味着数组是在编译时加入到程序中的。
使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。这被称为**动态联编**，意味着数组是在程序运行时创建的。这种数组叫作动态数组。

使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。

创建动态数组很容易：只要将数组的元素类型和元素数目告诉new即可。

```cpp
int n = 10;
int *p_array = new int[n];
int array[n];
```

new运算符返回第一个元素的地址。

>   这里发现，静态数组也可以用变量声明长度。

使用另一种格式的delete来释放：

```cpp
delete[] p_array;
```

方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。

总之，使用new和delete时，应遵守以下规则：

-   不要使用delete来释放不是new分配的内存。
-   不要使用delete释放同一个内存块两次。
-   如果使用new[]为数组分配内存，则应使用delete[]来释放。
-   如果使用new[]为一个实体分配内存，则应使用delete(没有方括号)来释放。
-   对空指针应用delete是安全的。

#### 指针和const

见const关键字总结

### 引用、指针的声明

```
// i是一个int型的数，p是一个int型指针，r是一个int型引用
inti=1024，*p=&i，&r=i;
```

```
int* p1, p2;	//p1是指向int的指针，p2是int
```

# vector

初始化

```
vector<int> v1 (10) ;	// v1有10个元素，每个的值都是0
vector<int> v2{10} ;	// v2有1个元素，该元素的值是10
vector<int> v3(10，1) ;	// v3有10个元素，每个的值都是1
vector<int> v4{10，1};	//v4有2个元素，值分别是10和1
```

>   开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。
>
>   特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。
