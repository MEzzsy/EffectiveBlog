# 动态内存与智能指针

智能指针定义在memory头文件中。

## shared_ptr类

默认初始化的智能指针中保存着一个空指针。

智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。

![30](assets/30.jpg)

### shared_ptr的拷贝和赋值

当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。

我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。

无论何时我们拷贝一个shared_ptr，计数器都会递增。当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。
当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。

## 直接管理内存

```cpp
class D {
 public:
  D(int v) : val(v) {}
  int val;
};

void testNewAndDelete() {
  D d1(1);

  auto p = new auto(d1);
  NDK_LOG("p val=%d", p->val);
  d1.val = 2;
  NDK_LOG("p val=%d", p->val);

  delete p;
}
```

如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto。

### 动态分配的const对象

用new分配const对象是合法的：

```
const int *p2 = new int(123);
const int *p3 = new const int(123);
```

### 内存耗尽

默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：

![31](assets/31.jpg)

我们称这种形式的new为定位new（placement new）。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在**头文件new**中。

## shared_ptr和new结合使用

接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式。

### 不要混合使用普通指针和智能指针

![32](assets/32.jpg)

在上面的调用中，我们将一个临时shared_ptr传递给process。当这个调用所在的表达式结束时，这个临时对象就被销毁了。销毁这个临时变量会递减引用计数，此时引用计数就变为0了。因此，当临时对象被销毁时，它所指向的内存会被释放。但x继续指向（已经释放的）内存，从而变成一个空悬指针。如果试图使用x的值，其行为是未定义的。

## unique_ptr

一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。

与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。

由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。

![33](assets/33.jpg)

虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique。

![34](assets/34.jpg)


### 传递unique_ptr参数和返回unique_ptr

不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr：

```c++
unique_ptr<int>clone(int p){
    //正确：从int*创建一个unique_ptr<int>
    return unique_ptr<int>(new int(p));
}
```

还可以返回一个局部对象的拷贝：

```c++
unique_ptr<int>clone(int p){
    unique_ptr<int> ret(new int(p));
    // ...
    return ret;
}
```

对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”。

## weak_ptr

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点。

由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。

# 动态数组

C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。

>
>   大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。

## new和数组

为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。

### 分配一个数组会得到一个元素类型的指针

虽然我们通常称`new T[]`分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。我们正在分配一个数组的事实甚至都是不可见的——连[num]都没有。new返回的是一个元素类型的指针。

```c++
const int num = 5;
  // 测试静态数组
  {
    NDK_LOG("测试静态数组");
    int array[num];
    for (auto it = std::begin(array); it != std::end(array); ++it) {
      *it = 1;
    }
    for (int i = 0; i < num; i++) {
      NDK_LOG("array[%d]=%d", i, array[i]);
    }
  }
  // 测试动态数组
  {
    NDK_LOG("测试动态数组");
    int *array = new int[num];
    // 无法编译
    // for (auto it = std::begin(array); it != std::end(array); ++it) {
    //   *it = 1;
    // }
    for (int i = 0; i < num; i++) {
      NDK_LOG("array[%d]=%d", i, array[i]);
    }
  }
```

由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。这些函数使用数组维度来返回指向首元素和尾后元素的指针。

>   要记住我们所说的动态数组并不是数组类型，这是很重要的。

### 初始化动态分配对象的数组

```c++
void testDynamicArray2() {
  NDK_LOG("结构体动态数组初始化");
  struct S {
    int val = 2;
  };
  S *array = new S[2];
  for (int i = 0; i < 2; i++) {
    NDK_LOG("S.val=%d", array[i].val);
  }

  NDK_LOG("int动态数组初始化");
  int *intArray = new int[5]();
  for (int i = 0; i < 5; i++) {
    NDK_LOG("intArray[%d]=%d", i, intArray[i]);
  }
}
```

虽然我们用空括号对数组中元素进行值初始化，但不能在括号中给出初始化器，这意味着不能用auto分配数组。

### 动态分配一个空数组是合法的

虽然我们不能创建一个大小为0的静态数组对象，但当n等于0时，调用new[n]是合法的。

### 释放动态数组

为了释放动态数组，我们使用一种特殊形式的delete--在指针前加上一个空方括号对。

```
delete p;		//p必须指向一个动态分配的对象或为空
delete [] pa;	//pa必须指向一个动态分配的数组或为空
```

第二条语句销毁pa指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。

当我们释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。

### 智能指针和动态数组

![35](assets/35.jpg)

与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器。

如果未提供删除器，这段代码将是未定义的。默认情况下，shared_ptr使用delete销毁它指向的对象。如果此对象是一个动态数组，对其使用delete所产生的问题与释放一个动态数组指针时忘记[]产生的问题一样

shared_ptr不直接支持动态数组管理这一特性会影响我们如何访问数组中的元素，shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。

## allocator类

new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。

当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。

一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。更重要的是，那些没有默认构造函数的类就不能动态分配数组了。

### allocator类

标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。

![36](assets/36.jpg)

### 拷贝和填充未初始化内存的算法

标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。它们都定义在头文件memory中。

![37](assets/37.jpg)

