# 动态内存与智能指针

智能指针定义在memory头文件中。

## shared_ptr类

默认初始化的智能指针中保存着一个空指针。

智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。

![30](assets/30.jpg)

### shared_ptr的拷贝和赋值

当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。

我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。

无论何时我们拷贝一个shared_ptr，计数器都会递增。当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。
当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。

## 直接管理内存

```cpp
class D {
 public:
  D(int v) : val(v) {}
  int val;
};

void testNewAndDelete() {
  D d1(1);

  auto p = new auto(d1);
  NDK_LOG("p val=%d", p->val);
  d1.val = 2;
  NDK_LOG("p val=%d", p->val);

  delete p;
}
```

如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto。

### 动态分配的const对象

用new分配const对象是合法的：

```
const int *p2 = new int(123);
const int *p3 = new const int(123);
```

### 内存耗尽

默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：

![31](assets/31.jpg)

我们称这种形式的new为定位new（placement new）。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在**头文件new**中。

# 释放动态内存

为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete
表达式（deleteexpression）来将动态内存归还给系统。delete表达式接受一个指针，指
向我们想要释放的对象：
deletep；//p必须指向一个动态分配的对象或是一个空指针
与new类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对
应的内存。
指针值和delete
我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针（参见2。3。2
节，第48页）。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为
是未定的：
inti，*pil
double*pd
deletei；
deletepil；
deletepd；//正确
deletepd2；//未定义：pd2指向的内存已经被释放了
deletepi2；//正确：释放一个空指针总是没有错误的
&i，*pi2=nullptr；
newdouble（33），*pd2pd；
//错误：i不是一个指针
//未定义：pil指向一个局部变量
=
对于deletei的请求，编译器会生成一个错误信息，因为它知道i不是一个指针。执
行deletepil和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一
个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的
内存是否已经被释放了。对于这delete5式，大多数编译器会编译通过，尽管它们
是错误的。
虽然一个const对象的值不能被改变，但它本身是可以被销毁的。如同任何其他动
态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可：
constint*pci=newconstint（1024）；
deletepci；//正确：释放一个const对象
动态对象的生存期直到被释放时为止
如12。1。1节（第402页）所述，由shared_ptr管理的内存在最后一个shared_ptr
销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个
由内置指针管理的动态对象，直到被显式释放之前它都是存在的。
返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担
调用者必须记得释放内存：
//factory返回一个指针，指向一个动态分配的对象
Foo*factory（Targ）
409
461

Page436
410
462
{
//视情况处理arg
returnnewFoo（arg）；//调用者负责释放此內存
}
类似我们之前定义的factory函数（参见12。1。1节，第403页），这个版本的factory
分配一个对象，但并不delete它。factory的调用者负责在不需要此对象时释放它。
不幸的是，调用者经常忘记释放对象：
voiduse_factory（Targ）
{
Foo*p=factory（arg）；
//使用p但不delete它
}//p离开了它的作用域，但它所指向的内存没有被释放!
此处，use_factory函数调用factory，后者分配一个类型为Foo的新对象。当
use_factory返回时，局部变量p被销毁。此变量是一个内置指针，而不是一个智能指针。
与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开
其作用域时，它所指向的对象什么也不会发生。如果这个指针指向的是动态内存，那么内
存将不会被自动释放。
由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在。
WARNING
在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，
程序就没有办法释放这块内存了。根据整个程序的逻辑，修正这个错误的正确方法是在
use_factory中记得释放内存：
voiduse_factory（Targ）
{
第12章动态内存
Foo*p=factory（arg）；
//使用p
deletep；//现在记得释放内存，我们已经不需要它了
}
}
还有一种可能，我们的系统中的其他代码要使用use_factory所分配的对象，我们就应
该修改此函数，让它返回一个指针，指向它分配的内存：
Foo*use_factory（Targ）
{
Foo*p=factory（arg）；
//使用p
returnp；//调用者必须释放内存
小心：动态内存的管理非常容易出错
使用new和delete管理动态内存存在三个常见问题：
1。忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，
因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为
通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。
2。使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这

Page437
12。1动态内存与智能指针
种错误。
201502
3。同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这
种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。
如果我们随后又delete第二个指针，自由空间就可能被破坏。
相对于查找和修正这些错误来说，制造出这些错误要简单得多。
Practices
Best坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没
有任何智能指针指向它的情况下，智能指针才会自动释放它。
delete之后重置指针值……
当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机
器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了
人们所说的空悬指针（danglingpointer），即，指向一块曾经保存数据对象但现在已经无效
的内存的指针。
未初始化指针（参见2。3。2节，第49页）的所有缺点空悬指针也都有。有一种方法可
以避免空悬指针的问题：在指针即将要离开其作用域之前释放掉它所关联的内存。这样，
在指针关联的内存被释放掉之后，就没有机会继续使用指针了。如果我们需要保留指针，
可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。
…这只是提供了有限的保护
动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重
置指针的方法只对这个指针有效，对其他任何仍指向（已释放的）内存的指针是没有作用
的。例如：
int*p（newint（42））；//p指向动态内存
autoq=p；
deletepi
p=nullptr；
//p和q指向相同的內存
//p和q均变为无效
//指出p不再绑定到任何对象
本例中p和q指向相同的动态分配的对象｡我们delete此内存，然后将p置为nullptr，
指出它不再指向任何对象。但是，重置p对q没有任何作用，在我们释放p所指向的（同
时也是q所指向的!）内存时，q也变为无效了。在实际系统中，查找指向相同内存的所
有指针是异常困难的。
12。1。2节练习
练习12。6：编写函数，返回一个动态分配的int的vector。将此vector传递给另
一个函数，这个函数读取标准输入，将读入的值保存在vector元素中。再将vector
传递给另一个函数，打印读入的值。记得在恰当的时刻deletevector。
练习12。7：重做上一题，这次使用shared_ptr而不是内置指针。
练习12。8：下面的函数是否有错误?如果有，解释错误原因。
boolb（）{
int*p=newint；
//
411
463

Page438
412
464
returnp；
}
练习12。9：解释下面代码执行的结果：
int*q=newint（42），*r=newint（100）；
r=qi
autoq2
r2=q2；
make_shared<int>（42），r2=make_shared<int>（100）；
12。1。3shared_ptr和new结合使用
如前所述，如果我们不初始化一个智能指针，它就会被初始化为一个空指针。如表12。3
所示，我们还可以用new返回的指针来初始化智能指针：
shared_ptr<double>p1；//shared_ptr可以指向一个double
shared_ptr<int>p2（newint（42））；//p2指向一个值为42的int
接受指针参数的智能指针构造函数是explicit的（参见7。5。4节，第265页）。因此，
我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式（参见3。2。1
节，第76页）来初始化一个智能指针：
shared_ptr<int>p1newint（1024）；//错误：必须使用直接初始化形式
shared_ptr<int>p2（newint（1024））；//正确：使用了直接初始化形式
第12章动态内存
=
p1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于
我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。出于相
同的原因，一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：
shared_ptr<int>clone（intp）{
returnnewint（p）；//错误：隐式转换为shared_ptr<int>
}
我们必须将shared_ptr显式绑定到一个想要返回的指针上：
shared_ptr<int>clone（intp）{
//正确：显式地用int*创建shared_ptr<int>
returnshared_ptr<int>（newint（p））；
shared_ptr<T>p（q）
}
默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针
默认使用delete释放它所关联的对象。我们可以将智能指针绑定到一个指向其他类型的
资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。我们将在12。1。4
节（第415页）介绍如何定义自己的释放操作。
表12。3：定义和改变shared_ptr的其他方法
shared_ptr<T>p（u）
shared_ptr<T>p（q，d）
p管理内置指针q所指向的对象；q必须指向new分配的内存，
且能够转换为T*类型
p从unique_ptru那里接管了对象的所有权；将u置为空
p接管了内置指针q所指向的对象的所有权。q必须能转换为
T*类型（参见4。11。2节，第143页）。p将使用可调用对象d（参
见10。3。2节，第346页）来代替delete

Page439
12。1动态内存与智能指针
shared_ptr<T>p（p2，d）
p。reset（）
p。reset（q）
p。reset（q，d）
续表
如表12。2所示，p是shared_ptrp2的拷贝，唯一的区别是
p将用可调用对象d来代替delete
若p是唯一指向其对象的shared_ptr，reset会释放此对
象。若传递了可选的参数内置指针q，会令p指向q，否则会
将p置为空。若还传递了参数d，将会调用d而不是delete
来释放q
不要混合使用普通指针和智能指针……
shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）
之间。这也是为什么我们推荐使用makeshared而不是new的原因。这样，我们就能
在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到
多个独立创建的shared_ptr上。
考虑下面对shared_ptr进行操作的函数：
//在函数被调用时ptr被创建并初始化
voidprocess（shared_ptr<int>ptr）
{
//使用ptr
}//ptr离开作用域，被销毁
process的参数是传值方式传递的，因此实参会被拷贝到ptr中。拷贝一个shared_ptr465
会递增其引用计数，因此，在process运行过程中，引用计数值至少为2。当process
结束时，ptr的引用计数会递减，但不会变为0。因此，当局部变量ptr被销毁时，ptr
指向的内存不会被释放。
使用此函数的正确方法是传递给它一个shared_ptr：
shared_ptr<int>p（newint（42））；//引用计数为1
process（p）；//拷贝p会递增它的引用计数；在process中引用计数值为2
inti=*p；//正确：引用计数值为1
虽然不能传递给process一个内置指针，但可以传递给它一个（临时的）
shared_ptr，这个shared_ptr是用一个内置指针显式构造的。但是，这样做很可能
会导致错误：
int*x（newint（1024））；
process（x）；//错误：不能将int*转换为一个shared_ptr<int>
process（shared_ptr<int>（x））；//合法的，但内存会被释放!
intj=*x；//未定义的：x是一个空悬指针!
//危险：x是一个普通指针，不是一个智能指针
在上面的调用中，我们将一个临时shared_ptr传递给process。当这个调用所在的表
达式结束时，这个临时对象就被销毁了。销毁这个临时变量会递减引用计数，此时引用计
数就变为0了。因此，当临时对象被销毁时，它所指向的内存会被释放。
但x继续指向（已经释放的）内存，从而变成一个空悬指针。如果试图使用x的值，
其行为是未定义的。
413
当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这
个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所
指向的内存了。

Page440
414
466
467
WARNING
使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无
法知道对象何时会被销毁。
第12章动态内存
…也不要使用get初始化另一个智能指针或为智能指针赋值
智能指针类型定义了一个名为get的函数（参见表12。1），它返回一个内置指针，
指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智
能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。
虽然编译器不会给出错误信息，但将另一个智能指针也绑定到get返回的指针上是
错误的：
shared_ptr<int>p（newint（42））；//引用计数为1
int*q=p。get（）；//正确：但使用q时要注意，不要让它管理的指针被释放
{//新程序块
//未定义：两个独立的shared_ptr指向相同的內存
shared_ptr<int>（q）；
}//程序块结束，q被销毁，它指向的内存被释放
intfoo=*p；//未定义：p指向的内存已经被释放了
在本例中，p和q指向相同的内存。由于它们是相互独立创建的，因此各自的引用计数都
是1。当q所在的程序块结束时，q被销毁，这会导致q指向的内存被释放。从而p变成
一个空悬指针，意味着当我们试图使用p时，将发生未定义的行为。而且，当p被销毁时，
这块内存会被第二次delete。
get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针
的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针
WARNING或者为另一个智能指针赋值。
其他shared_ptr操作
shared_ptr还定义了其他一些操作，参见表12。2和表12。3所示。我们可以用reset
来将一个新的指针赋予一个shared_ptr：
p=newint（1024）；
//错误：不能将一个指针赋予shared_ptr
p。reset（newint（1024））；//正确：p指向一个新对象
与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成
员经常与unique一起使用，来控制多个shared_ptr共享的对象。在改变底层对象之
前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的
拷贝：
if（!p。unique（））
p。reset（newstring（*p））；//我们不是唯一用户；分配新的拷贝
*p+=newVal；//现在我们知道自己是唯一的用户，可以改变对象的值
12。1。3节练习
练习12。10：下面的代码调用了第413页中定义的process函数，解释此调用是否正
确。如果不正确，应如何修改?
shared_ptr<int>p（newint（42））；

Page441
12。1动态内存与智能指针
process（shared_ptr<int>（p））；
练习12。11：如果我们像下面这样调用process，会发生什么?
process（shared_ptr<int>（p。get（）））；
练习12。12：p和q的定义如下，对于接下来的对process的每个调用，如果合法，
解释它做了什么，如果不合法，解释错误原因：
autoP=newint（）；
autosp=
（a）process（sp）；
（b）process（newint（））；
（c）process（p）；
（d）process（shared_ptr<int>（p））；
练习12。13：如果执行下面的代码，会发生什么?
make_shared<int>（）；
make_shared<int>（）；
autosp=
autop=sp。get（）；
deletep；
12。1。4智能指针和异常
5。6。2节（第175页）中介绍了使用异常处理的程序能在异常发生后令程序流程继续，
我们注意到，这种程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源
被释放的方法是使用智能指针。
如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将
其释放，：
voidf（）
{
shared_ptr<int>sp（newint（42））；//分配一个新对象
//这段代码抛出一个异常，且在f中未被捕获
}//在函数结束时shared_ptr自动释放内存
函数的退出有两种可能，正常处理结束或者发生了异常，无论哪种情况，局部对象都会被
销毁。在上面的程序中，sp是一个shared_ptr，因此sp销毁时会检查引用计数。在
此例中，sp是指向这块内存的唯一指针，因此内存会被释放掉。
与之相对的，当发生异常时，我们直接管理的内存是不会自动释放的。如果使用内置
指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：
voidf（）
{
int*ipnewint（42）；//动态分配一个新对象
//这段代码抛出一个异常，且在f中未被捕获
deleteip；
//在退出之前释放内存
}
如果在new和delete之间发生异常，且异常未在f中被捕获，则内存就永远不会被释
放了。在函数f之外没有指针指向这块内存，因此就无法释放它了。
415
468

Page442
416
469
智能指针和哑类
包括所有标准库类在内的很多C++类都定义了析构函数（参见12。1。1节，第402页），
负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为C和
C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。
那些分配了资源，而又没有定义析构函数来释放这些资源的类，可能会遇到与使用动
态内存相同的错误——程序员非常容易忘记释放资源。类似的，如果在资源分配和释放之
间发生了异常，程序也会发生资源泄漏。
与管理动态内存类似，我们通常可以使用类似的技术来管理不具有良好定义的析构函
数的类。例如，假定我们正在使用一个C和C++都使用的网络库，使用这个库的代码可能
是这样的：
structdestination；
structconnection；
connectionconnect（destination*）；
第12章动态内存
voiddisconnect（connection）；
voidf（destination&d/*其他参数*/）
{
//表示我们正在连接什么
//使用连接所需的信息
//打开连接
//关闭给定的连接
//获得一个连接；记住使用完后要关闭它
connectionc=connect（&d）；
//使用连接
//如果我们在f退出前忘记调用disconnect，就无法关闭c了
}
如果connection有一个析构函数，就可以在f结束时由析构函数自动关闭连接。但是，
connection没有析构函数。这个问题与我们上一个程序中使用shared_ptr避免内存
泄漏几乎是等价的。使用shared_ptr来保证connection被正确关闭，已被证明是一
种有效的方法。
}
使用我们自己的释放操作
默认情况下，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr
被销毁时，它默认地对它管理的指针进行delete操作。为了用shared_ptr来管理一
个connection，我们必须首先定义一个函数来代替delete。这个删除器（deleter）函
数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除
器必须接受单个类型为connection*的参数：
voidend_connection（connection*p）{disconnect（*p）；}
当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数（参
见6。7节，第221页）：
voidf（destination&d/*其他参数*/）
{
connectionc=connect（&d）；
shared_ptr<connection>p（&c，end_connection）；
//使用连接
//当f退出时（即使是由于异常而退出），connection会被正确关闭

Page443
12。1动态内存与智能指针
当p被销毁时，它不会对自己保存的指针执行delete，而是调用end_connection。
接下来，end_connection会调用disconnect，从而确保连接被关闭。如果f正常退
出，那么p的销毁会作为结束处理的一部分。如果发生了异常，p同样会被销毁，从而连
接被关闭。
注意：智能指针陷阱
智能指针可以提供对动态分配的内存安全又方便的管理，但这建立在正确使用的
前提下。为了正确使用智能指针，我们必须坚持一些基本规范：
●不使用相同的内置指针值初始化（或reset）多个智能指针。
‧deleteget（）返回的指针。
•不使用get（）初始化或reset另一个智能指针。
•如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的
指针就变为无效了。
•如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除
器（参见12。1。4节，第415页和12。1。5节，第419页）。
12。1。4节练习
练习12。14：编写你自己版本的用shared_ptr管理connection的函数。
练习12。15：重写第一题的程序，用lambda（参见10。3。2节，第346页）代替end_connection
函数。
12。1。5unique_ptr
一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能
有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也
被销毁。表12。4列出了unique_ptr特有的操作。shared_ptr相同的操作列在表
12。1（第401页）中。
与shared_ptr不同，没有类似make_shared的标准库函数返回一个
unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针
上。类似shared_ptr，初始化unique_ptr必须采用直接初始化形式：
unique_ptr<double>p1；//可以指向一个double的unique_ptr
unique_ptr<int>p2（newint（42））；//p2指向一个值为42的int
由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或
赋值操作：
unique_ptr<string>pl（newstring（"Stegosaurus"））；
unique_ptr<string>p2（p1）；
unique_ptr<string>p3；
p3=p2；
//错误：unique_ptr不支持拷贝
//错误：unique_ptr不支持赋值
417
470
C++
11

Page444
418
471
表12。4：unique_ptr操作（另参见表12。1，第401页）
unique_ptr<T>ul
unique_ptr<T，D>u2
unique_ptr<T，D>u（d）
u=nullptr
u。release（）
u。reset（）
u。reset（q）
u。reset（nullptr）
空unique_ptr，可以指向类型为T的对象｡u1会使用delete
来释放它的指针；u2会使用一个类型为D的可调用对象来释放
它的指针
空unique_ptr，指向类型为T的对象，用类型为D的对象d
代替delete
释放u指向的对象，将u置为空
u放弃对指针的控制权，返回指针，并将u置为空
释放u指向的对象
如果提供了內置指针q，令u指向这个对象；否则将u置为空
虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的
所有权从一个（非const）unique_ptr转移给另一个unique：
第12章动态内存
//将所有权从p1（指向stringStegosaurus）转移给p2
unique_ptr<string>p2（pl。release（））；//release将p1置为空
unique_ptr<string>p3（newstring（"Trex"））；
//将所有权从p3转移给p2
p2。reset（p3。release（））；//reset释放了p2原来指向的內存
release成员返回unique_ptr当前保存的指针并将其置为空。因此，p2被初始化为
p1原来保存的指针，而p1被置为空。
reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果
unique_ptr不为空，它原来指向的对象被释放。因此，对p2调用reset释放了用
"Stegosaurus"初始化的string所使用的内存，将p3对指针的所有权转移给p2，并
将p3置为空。
调用release会切断unique_ptr和它原来管理的对象间的联系。release返回
的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。在本例中，管理内存
的责任简单地从一个智能指针转移给另一个。但是，如果我们不用另一个智能指针来保存
release返回的指针，我们的程序就要负责资源的释放：
p2。release（）；
autop=p2。release（）；//正确，但我们必须记得delete（p）
//错误：p2不会释放内存，而且我们丢失了指针
传递unique_ptr参数和返回unique_ptr
不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的
unique_ptr。最常见的例子是从函数返回一个unique_ptr：
unique_ptr<int>clone（intp）{
//正确：从int*创建一个unique_ptr<int>
returnunique_ptr<int>（newint（p））；
}
还可以返回一个局部对象的拷贝：
//
returnret；
unique_ptr<int>clone（intp）{
unique_ptr<int>ret（newint（p））；

Page445
12。1动态内存与智能指针
对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特
殊的“拷贝”，我们将在13。6。2节（第473页）中介绍它。
向后兼容：：auto_ptr
标准库的较早版本包含了一个名为auto_ptr的类，它具有unique_ptr的部分
特性，但不是全部。特别是，我们不能在容器中保存auto_ptr，也不能从函数中返回
auto_ptr。
虽然auto_ptr仍是标准库的一部分，但编写程序时应该使用unique_ptro
向unique_ptr传递删除器
类似shared_ptr，unique_ptr默认情况下用delete释放它指向的对象。与
shared_ptr一样，我们可以重载一个unique_ptr中默认的删除器（参见12。1。4节，
第415页）。但是，unique_ptr管理删除器的方式与shared_ptr不同，其原因我们将
在16。1。6节（第599页）中介绍。
重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或
reset）该类型的对象。与重载关联容器的比较操作（参见11。2。2节，第378页）类似，
我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个
这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）：
//p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象
//它会调用一个名为fcn的delT类型对象
unique_ptr<objT，delT>p（newobjT，fcn）；
作为一个更具体的例子，我们将重写连接程序，用unique_ptr来代替shared_ptr，
如下所示：
voidf（destination&d/*其他需要的参数*/）
{
connectionc=connect（&d）；//打开连接
//当p被销毁时，连接将会关闭
unique_ptr<connection，decltype（end_connection）*>
p（&c，end_connection）；
//使用连接
//当f退出时（即使是由于异常而退出），connection会被正确关闭
}
在本例中我们使用了decltype（参见2。5。3节，第62页）来指明函数指针类型。由于
decltype（end_connection）返回一个函数类型，所以我们必须添加一个*来指出我们
正在使用该类型的一个指针（参见6。7节，第223页）。
12。1。5节练习
练习12。16：如果你试图拷贝或赋值unique_ptr，编译器并不总是能给出易于理解的
错误信息。编写包含这种错误的程序，观察编译器如何诊断这种错误。
练习12。17：下面的unique_ptr声明中，哪些是合法的，哪些可能导致后续的程序错
误?解释每个错误的问题在哪里。
419
472

Page446
420
473
C++
11
intix=1024，*pi=&ix，*pi2
typedefunique_ptr<int>IntP；
（a）IntPp0（ix）；
（c）IntPp2（pi2）；
（e）IntPp4（newint（2048））；
练习12。18：shared_ptr为什么没有release成员?
weak_ptr<T>w
weak_ptr<T>w（sp）
w=p
=
newint（2048）；
w。reset（）
w。use_count（）
w。expired（）
w。lock（）
12。1。6weak_ptr
weak_ptr（见表12。5）是一种不控制所指向对象生存期的智能指针，它指向由一个
shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变
shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被
释放。即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓
住了这种智能指针“弱”共享对象的特点。
第12章动态内存
（b）IntPpl（pi）；
（d）IntPp3（&ix）；
（f）Intep5（p2。get（））；
表12。5：weak_ptr
空weak_ptr可以指向类型为T的对象
与shared_ptrsp指向相同对象的weak_ptr。T必须能转换为
sp指向的类型
p可以是一个shared_ptr或一个weak_ptro赋值后w与p共享
对象
将w置为空
与w共享对象的shared_ptr的数量
若w。use_count（）为0，返回true，否则返回false
如果expired为true，返回一个空shared_ptr；否则返回一个
指向w的对象的shared_ptr
当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：
autop=make_shared<int>（42）；
weak_ptr<int>wp（p）；//wp弱共享p；p的引用计数未改变
本例中wp和p指向相同的对象。由于是弱共享，创建wp不会改变p的引用计数；wp指
向的对象可能被释放掉。
由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。
此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象
的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向
的底层对象也就会一直存在。例如：
if（shared_ptr<int>np=wp。lock（））{//如果np不为空则条件成立
//在if中，np与p共享对象
}
在这段代码中，只有当lock调用返回true时我们才会进入if语句体。在if中，使用
np访问共享对象是安全的。
核查指针类
作为weak_ptr用途的一个展示，我们将为StrBlob类定义一个伴随指针类。我们

Page447
12。1动态内存与智能指针
的指针类将命名为StrBlobetr，会保存一个weak_ptr，指向StrBlob的data成员，
这是初始化时提供给它的。通过使用weak_ptr，不会影响一个给定的StrBlob所指向
的vector的生存期。但是，可以阻止用户访问一个不再存在的vector的企图。
StrBlobPtr会有两个数据成员：wptr，或者为空，或者指向一个StrBlob中的
vector；curr，保存当前对象所表示的元素的下标。类似它的伴随类StrBlob，我们
的指针类也有一个check成员来检查解引用StrBlobPtr是否安全：
//对于访问一个不存在元素的尝试，StrBlobPtr抛出一个异常
classStrBlobPtr{
public：
StrBlobPtr（）：curr（0）{}
StrBlobPtr（StrBlob&a，size_tsz=0）：
wptr（a。data），curr（sz）{}
std：：string&deref（）const；
StrBlobPtr&incr（）；//前缀递增
private：
//若检查成功，check返回一个指向vector的shared_ptr
std：：shared_ptr<std：：vector<std：：string>>
check（std：：size_t，conststd：：string&）const；
//保存一个weak_ptr，意味着底层vector可能会被销毁
std：：weak_ptr<std：：vector<std：：string>>wptr；
std：：size_tcurr；//在数组中的当前位置
}；
默认构造函数生成一个空的StrBlobPtr。其构造函数初始化列表（参见7。1。4节，
第237页）将curr显式初始化为0，并将wptr隐式初始化为一个空weak_ptr。第二
个构造函数接受一个StrBlob引用和一个可选的索引值。此构造函数初始化wptr，令
其指向给定StrBlob对象的shared_ptr中的vector，并将curr初始化为sz的值。
我们使用了默认参数（参见6。5。1节，第211页），表示默认情况下将curr初始化为第一
个元素的下标。我们将会看到，StrBlob的end成员将会用到参数sz。
值得注意的是，我们不能将StrBlobPtr绑定到一个constStrBlob对象。这个
限制是由于构造函数接受一个非constStrBlob对象的引用而导致的。
StrBlobPtr的check成员与StrBlob中的同名成员不同，它还要检查指针指向
的vector是否还存在：
{
std：：shared_ptr<std：：vector<std：：string>>
StrBlobPtr：：check（std：：size_ti，conststd：：string&msg）const
autoret=wptr。lock（）；//vector还存在吗?
if（!ret）
throwstd：：runtime_error（"unboundStrBlobPtr"）；
if（i>=ret->size（））
throwstd：：outofrange（msg）；
returnret；//否则，返回指向vector的shared_ptr
421
474
}
由于一个weak_ptr不参与其对应的shared_ptr的引用计数，StrBlobPtr指向的475
vector可能已经被释放了。如果vector已销毁，lock将返回一个空指针。在本例中，
任何vector的引用都会失败，于是抛出一个异常。否则，check会检查给定索引，如
果索引值合法，check返回从lock获得的shared_ptr。

Page448
422
476
指针操作
我们将在第14章学习如何定义自己的运算符｡现在，我们将定义名为deref和incr
的函数，分别用来解引用和递增StrBlobPtr。
deref成员调用check，检查使用vector是否安全以及curr是否在合法范围内：
std：：string&StrBlobPtr：：deref（）const
{
}
autop=check（curr，"dereferencepastend"）；
return（*p）[curr]；//（*p）是对象所指向的vector
如果check成功，p就是一个shared_ptr，指向StrBlobPtr所指向的vector。表
达式（*p）[curr]解引用shared_ptr来获得vector，然后使用下标运算符提取并返
回curr位置上的元素。
incr成员也调用check：
//前缀递增：返回递增后的对象的引用
StrBlobPtr&StrBlobPtr：：incr（）
{
第12章动态内存
}；
//如果curr已经指向容器的尾后位置，就不能递增它
check（curr，"incrementpastendofStrBlobPtr"）；
++curr；//推进当前位置
return*this；
}
当然，为了访问data成员，我们的指针类必须声明为StrBlob的friend（参见
7。3。4节，第250页）。我们还要为StrBlob类定义begin和end操作，返回一个指向它
自身的StrBlobPtr：
//对于StrBlob中的友元声明来说，此前置声明是必要的
classStrBlobPtr；
classStrBlob{
friendclassStrBlobPtr；
//其他成员与12。1。1节（第405页）中声明相同
//返回指向首元素和尾后元素的StrBlobPtr
StrBlobPtrbegin（）{returnStrBlobPtr（*this）；}
StrBlobPtrend（）
{autoret=StrBlobPtr（*this，data->size（））；
returnret；}
12。1。6节练习
练习12。19：定义你自己版本的StrBlobptr，更新StrBlob类，加入恰当的friend
声明及begin和end成员。
练习12。20：编写程序，逐行读入一个输入文件，将内容存入一个StrBlob中，用一
个StrBlobPtr打印出StrBlob中的每个元素。
练习12。21；也可以这样编写StrBlobPtr的deref成员：
std：：string&deref（）const

Page449
12。2动态数组
{return（*check（curr，"dereferencepastend"））[curr]；}
你认为哪个版本更好?为什么?
练习12。22：为了能让StrBlobPtr使用constStrBlob，你觉得应该如何修改?
定义一个名为ConstStrBlobPtr的类，使其能够指向constStrBlob。
12。2动态数组
new和delete运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分
配内存的功能。例如，vector和string都是在连续内存中保存它们的元素，因此，当
容器需要重新分配内存时（参见9。4节，第317页），必须一次性为很多元素分配内存。
为了支持这种需求，C++语言和标准库提供了两种一次分配一个对象数组的方法｡C++
语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一
个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供
更好的性能和更灵活的内存管理能力，原因我们将在12。2。2节（第427页）中解释。
很多（可能是大多数）应用都没有直接访问动态数组的需求。当一个应用需要可变数
量的对象时，我们在StrBlob中所采用的方法几乎总是更简单、更快速并且更安全的
即，使用vector（或其他标准库容器）。如我们将在13。6节（第470页）中看到的，使
用标准库容器的优势在新标准下更为显著。在支持新标准的标准库中，容器操作比之前的
版本要快速得多。
Best
Practices
大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、
更不容易出现内存管理错误并且可能有更好的性能。
如前所述，使用容器的类可以使用默认版本的拷贝、赋值和析构操作（参见7。1。5节，
第239页）。分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象
时管理所关联的内存。
直到学习完第13章，不要在类内的代码中分配动态内存。
WARNING
12。2。1new和数组
为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要
分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向
第一个对象的指针：
//调用get_size确定分配多少个int
int*pia=newint[get_size（）]；//pia指向第一个int
方括号中的大小必须是整型，但不必是常量。
也可以用一个表示数组类型的类型别名（参见2。5。1节，第60页）来分配一个数组，
这样，new表达式中就不需要方括号了：
typedefintarrT[42]；//arrT表示42个int的数组类型
int*p=newarri；
//分配一个42个int的数组；p指向第一个int
在本例中，new分配一个int数组，并返回指向第一个int的指针。即使这段代码中没
423
477

Page450
424
478
C++
11
由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end（参
见3。5。3节，第106页）。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）
C++）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理
（所谓的）动态数组中的元素。
11
要记住我们所说的动态数组并不是数组类型，这是很重要的。
C++
有方括号，编译器执行这个表达式时还是会用new[]。即，编译器执行如下形式：
int*p=newint[42]；
分配一个数组会得到一个元素类型的指针
虽然我们通常称newT[]分配的内存为“动态数组”，但这种叫法某种程度上有些误
导。当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组
元素类型的指针。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组
类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的——连[num]都
没有。new返回的是一个元素类型的指针。
第12章动态内存
WARNING
初始化动态分配对象的数组
默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。
可以对数组中的元素进行值初始化（参见3。3。1节，第88页），方法是在大小之后跟一对
空括号。
=
int*pia=newint[10]；
//10个未初始化的int
//10个值初始化为0的int
int*pia2newint[10]（）；
string*psa
string*psa2=newstring[10]（）；//10个空string
newstring[10]；
//10个空string
在新标准中，我们还可以提供一个元素初始化器的花括号列表：
//10个int分别用列表中对应的初始化器初始化
int*pia3=newint[10]{0，1，2，3，4，5，6，7，8，9}；
//10个string，前4个用给定的初始化器初始化，剩余的进行值初始化
string*psa3newstring[10]{"a"，"an"，"the"，string（3，'x'）}；
与内置数组对象的列表初始化（参见3。5。1节，第102页）一样，初始化器会用来初始化
动态数组中开始部分的元素。如果初始化器数目小于元素数目，剩余元素将进行值初始化。
如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，
new会抛出一个类型为bad_array_new_length的异常。类似bad_alloc，此类型定
义在头文件new中。
虽然我们用空括号对数组中元素进行值初始化，但不能在括号中给出初始化器，这意
味着不能用auto分配数组（参见12。1。2节，第407页）。
动态分配一个空数组是合法的
可以用任意表达式来确定要分配的对象的数目：
sizetn=get_size（）；//get_size返回需要的元素的数目
//分配数组保存元素
int*p=newint[n]；
for（int*q=p；q!=p+n；++q）
/*处理数组*/；

Page451
12。2动态数组
这产生了一个有意思的问题：如果get_size返回0，会发生什么?答案是代码仍能正常
工作。虽然我们不能创建一个大小为0的静态数组对象，但当n等于0时，调用new[n]
是合法的：
chararr[0]；
//错误：不能定义长度为0的数组
char*cp=newchar[0]；//正确：但cp不能解引用
当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证
与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一
样（参见3。5。3节，第106页），我们可以像使用尾后迭代器一样使用这个指针。可以用此
指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，
也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。
在我们假想的循环中，若get_size返回0，则n也是0，new会分配0个对象。for
循环中的条件会失败（p等于q+n，因为n为0）。因此，循环体不会被执行。
释放动态数组
为了释放动态数组，我们使用一种特殊形式的delete--在指针前加上一个空方括
号对：
deletep；
delete[]pa；
//p必须指向一个动态分配的对象或为空
//pa必须指向一个动态分配的数组或为空
第二条语句销毁pa指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，
即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。
当我们释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向
一个对象数组的第一个元素。如果我们在delete一个指向数组的指针时忽略了方括号
（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。
回忆一下，当我们使用一个类型别名来定义一个数组类型时，在new表达式中不使
用[]。即使是这样，在释放一个数组指针时也必须使用方括号：
typedefintarrT[42]；//arrT是42个int的数组的类型别名
int*p=newarrT；
delete[]p；
//分配一个42个int的数组；p指向第一个元素
//方括号是必需的，因为我们当初分配的是一个数组
不管外表如何，p指向一个对象数组的首元素，而不是一个类型为arrT的单一对象。因
此，在释放p时我们必须使用[]。
如果我们在delete一个数组指针时忘记了方括号，或者在delete一个单一
对象的指针时使用了方括号，编译器很可能不会给出警告。我们的程序可能在
WARNING执行过程中在没有任何警告的情况下行为异常。
智能指针和动态数组
标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个
unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号：
//up指向一个包含10个未初始化int的数组
unique_ptr<int[]>up（newint[10]）；
up。release（）；//自动用delete[]销毁其指针
425
479

Page452
426
480
类型说明符中的方括号（<int[]>）指出up指向一个int数组而不是一个int。由于
up指向一个数组，当up销毁它管理的指针时，会自动使用delete[]。
指向数组的unique_ptr提供的操作与我们在12。1。5节（第417页）中使用的那些
操作有一些不同，我们在表12。6中描述了这些操作。当一个unique_ptr指向一个数组
时，我们不能使用点和箭头成员运算符。毕竟unique_ptr指向的是一个数组而不是单
个对象，因此这些运算符是无意义的。另一方面，当一个unique_ptr指向一个数组时，
我们可以使用下标运算符来访问数组中的元素：
for（size_ti=0；i!=10；++i）
第12章动态内存
up[i]i；//为每个元素赋予一个新值
表12。6：指向数组的unique_ptr
指向数组的unique_ptr不支持成员访问运算符（点和箭头运算符）。
其他unique_ptr操作不变。
unique_ptr<T[]>u
unique_ptr<T[]>u（p）
u[i]
u可以指向一个动态分配的数组，数组元素类型为T
u指向内置指针p所指向的动态分配的数组。p必须能转换为类型
T*（参见4。11。2节，第143页）
返回u拥有的数组中位置i处的对象
u必须指向一个数组
与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用
shared_ptr管理一个动态数组，必须提供自己定义的删除器：
//为了使用shared_ptr，必须提供一个删除器
shared_ptr<int>sp（newint[10]，[]（int*p）{delete[]p；}）；
sp。reset（）；//使用我们提供的lambda释放数组，它使用delete[]
本例中我们传递给shared_ptr个lambda（参见10。3。2节，第346页）作为删除器，
它使用delete[]释放数组。
如果未提供删除器，这段代码将是未定义的。默认情况下，shared_ptr使用delete
销毁它指向的对象。如果此对象是一个动态数组，对其使用delete所产生的问题与释放
一个动态数组指针时忘记[]产生的问题一样（参见12。2。1节，第425页）。
shared_ptr不直接支持动态数组管理这一特性会影响我们如何访问数组中的元素：
//shared_ptr未定义下标运算符，并且不支持指针的算术运算
for（size_ti=0；i!=10；++i）
*（sp。get（）+i）=i；//使用get获取一个内置指针
shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访
问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。
12。2。1节练习
练习12。23：编写一个程序，连接两个字符串字面常量，将结果保存在一个动态分配的
char数组中。重写这个程序，连接两个标准库string对象。
练习12。24：编写一个程序，从标准输入读取一个字符串，存入一个动态分配的字符数
组中。描述你的程序如何处理变长输入。测试你的程序，输入一个超出你分配的数组长
度的字符串。

Page453
12。2动态数组
练习12。25：给定下面的new表达式，你应该如何释放pa?
int*pa=newint[10]；
12。2。2allocator类
new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一
起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常
希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应
有什么值。
当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们
希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才
真正执行对象创建操作（同时付出一定开销）。
一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。例如：
//构造n个空string
string*constpnewstring[n]；
strings；
string*qPi
//q指向第一个string
while（cin>>s&&q!=p+n）
*q++=s；
//赋予*q一个新值
constsize_tsize=q-p；
//记住我们读取了多少个string
//使用数组
delete[]p；//p指向一个数组；记得用delete[]来释放
new表达式分配并初始化了n个string。但是，我们可能不需要n个string，少量
string可能就足够了。这样，我们就可能创建了一些永远也用不到的对象。而且，对于
那些确实要使用的对象，我们也在初始化之后立即赋予了它们新值。每个使用到的元素都
被赋值了两次：第一次是在默认初始化时，随后是在赋值时。
更重要的是，那些没有默认构造函数的类就不能动态分配数组了。
allocator类
标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造
分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。表
12。7概述了allocator支持的操作。在本节中，我们将介绍这些allocator操作。在
13。5节（第464页），我们将看到如何使用这个类的典型例子。
类似vector，allocator是一个模板（参见3。3节，第86页）。为了定义一个
allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个
allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位
置：
allocator<string>alloc；
autoconstp=alloc。allocate（n）；
这个allocate调用为n个string分配了内存。
//可以分配string的allocator对象
//分配n个未初始化的string
427
481

Page454
428
482
allocator<T>a
483
a。allocate（n）
a。deallocate（p，n）
a。construct（p，args）
a。destroy（p）
表12。7：标准库allocator类及其算法
定义了一个名为a的allocator对象，它可以为类型为T
的对象分配内存
分配一段原始的、未构造的内存，保存n个类型为T的对象
释放从T*指针p中地址开始的内存，这块内存保存了n个类
型为T的对象；p必须是一个先前由allocate返回的指针，
且n必须是p创建时所要求的大小。在调用deallocate之
前，用户必须对在这块内存中创建的对象调用destroy
WARNING
p必须是一个类型为T*的指针，指向一块原始内存；arg被
传递给类型为T的构造函数，用来在p指向的内存中构造一
个对象
allocator分配未构造的内存
allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对
象。在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定
C++位置构造一个元素。额外参数用来初始化构造的对象。类似make_shared的参数（参见
11
12。1。1节，第401页），这些额外参数必须是与构造的对象的类型相匹配的合法的初始化器：
autoq=p；//q指向最后构造的元素之后的位置
alloc。construct（q++）；
//*q为空字符串
//*qcccccccccc
//*q为hi!
第12章动态内存
p为T*类型的指针，此算法对p指向的对象执行析构函数（参
见12。1。1节，第402页）
alloc。construct（g++，
alloc。construct（q++，"hi"）；
10，'c'）；
在早期版本的标准库中，construct只接受两个参数：指向创建对象位置的指针和一个
元素类型的值。因此，我们只能将一个元素拷贝到未构造空间中，而不能用元素类型的任
何其他构造函数来构造一个元素。
还未构造对象的情况下就使用原始内存是错误的：
cout<<*p<<endl；//正确：使用string的输出运算符
cout<<*q<<endl；//灾难：q指向未构造的内存!
为了使用allocate返回的内存，我们必须用construct构造对象。使用未
构造的内存，其行为是未定义的。
当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy
接受一个指针，对指向的对象执行析构函数（参见12。1。1节，第402页）：
while（q!=p）
alloc。destroy（--q）；//释放我们真正构造的string
在循环开始处，q指向最后构造的元素之后的位置。我们在调用destroy之前对q进行
了递减操作。因此，第一次调用destroy时，q指向最后一个构造的元素。最后一步循
环中我们destroy了第一个构造的元素，随后q将与p相等，循环结束。
我们只能对真正构造了的元素进行destroy操作。
WARNING
一旦元素被销毁后，就可以重新使用这部分内存来保存其他string，也可以将其归

Page455
12。2动态数组
还给系统。释放内存通过调用deallocate来完成：
alloc。deallocate（p，n）；
我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，
传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具
有一样的值。
拷贝和填充未初始化内存的算法
标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。
表12。8描述了这些函数，它们都定义在头文件memory中。
表12。8：allocator算法
这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。
uninitialized_copy（b，e，b2）
uninitialized_copy_n（b，n，b2）
uninitialized_fill（b，e，t）
uninitialized_fill_n（b，n，t）
从迭代器b和e指出的输入范围中拷贝元素到迭代器
b2指定的未构造的原始内存中。b2指向的内存必须
足够大，能容纳输入序列中元素的拷贝
从迭代器b指向的元素开始，拷贝n个元素到b2开
始的内存中
在迭代器b和e指定的原始内存范围中创建对象，对
象的值均为t的拷贝
从迭代器b指向的内存地址开始创建n个对象。b必
须指向足够大的未构造的原始内存，能够容纳给定数
量的对象
作为一个例子，假定有一个int的vector，希望将其内容拷贝到动态内存中。我们
将分配一块比vector中元素所占用空间大一倍的动态内存，然后将原vector中的元素
拷贝到前一半空间，对后一半空间用一个给定值进行填充：
//分配比vi中元素所占用空间大一倍的动态内存
autop=alloc。allocate（vi。size（）*2）；
//通过拷贝vi中的元素来构造从p开始的元素
autoq=uninitialized_copy（vi。begin（），vi。end（），p）；
//将剩余元素初始化为42
uninitialized_fill_n（q，vi。size（），42）；
类似拷贝算法（参见10。2。2节，第341页），uninitialized_copy接受三个迭代
器参数。前两个表示输入序列，第三个表示这些元素将要拷贝到的目的空间。传递给
uninitialized_copy的目的位置迭代器必须指向未构造的内存。与copy不同，
uninitialized_copy在给定目的位置构造元素。
类似copy，uninitialized_copy返回（递增后的）目的位置迭代器。因此，
次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。
在本例中，我们将此指针保存在q中，然后将q传递给uninitialized_fill_n。此
函数类似fill_n（参见10。2。2节，第340页），接受一个指向目的位置的指针、一个计
数和一个值。它会在目的位置指针指向的内存中创建给定数目个对象，用给定值对它们进
行初始化。
429
484

Page456
430
12。2。2节练习
练习12。26：用allocator重写第427页中的程序。
485
品12。3使用标准库：文本查询程序
我们将实现一个简单的文本查询程序，作为标准库相关内容学习的总结。我们的程序
允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的
列表。如果一个单词在一行中出现多次，此行只列出一次。行会按照升序输出——即，第
7行会在第9行之前显示，依此类推。
第12章动态内存
例如，我们可能读入一个包含本章內容（指英文版中的文本）的文件，在其中寻找单
词element。输出结果的前几行应该是这样的：
elementoccurs112times。
（line36）Asetelementcontainsonlyakey；
（line158）operatorcreatesanewelement
（line160）Regardlessofwhethertheelement
（line168）Whenwefetchanelementfromamap，we
（line214）Iftheelementisnotfound，findreturns
接下来还有大约100行，都是单词element出现的位置。
12。3。1文本查询程序设计
开始一个程序的设计的一种好方法是列出程序的操作。了解需要哪些操作会帮助我们
分析出需要什么样的数据结构。从需求入手，我们的文本查询程序需要完成如下任务：
•当程序读取输入文件时，它必须记住单词出现的每一行。因此，程序需要逐行读取
输入文件，并将每一行分解为独立的单词
●当程序生成输出时，
-它必须能提取每个单词所关联的行号
-行号必须按升序出现且无重复
-它必须能打印给定行号中的文本。
利用多种标准库设施，我们可以很漂亮地实现这些要求：
•我们将使用一个vector<string>来保存整个输入文件的一份拷贝。输入文件中
的每行保存为vector中的一个元素。当需要打印一行时，可以用行号作为下标来
提取行文本。
•我们使用一个istringstream（参见8。3节，第287页）来将每行分解为单词。
•我们使用一个set来保存每个单词在输入文本中出现的行号。这保证了每行只出
现一次且行号按升序保存。
•我们使用一个map来将每个单词与它出现的行号set关联起来。这样我们就可以
方便地提取任意单词的set。
我们的解决方案还使用了shared_ptr，原因稍后进行解释。
数据结构
虽然我们可以用vector、set和map来直接编写文本查询程序，但如果定义一个更

Page457
12。3使用标准库：文本查询程序
为抽象的解决方案，会更为有效。我们将从定义一个保存输入文件的类开始，这会令文件
查询更为容易。我们将这个类命名为TextQuery，它包含一个vector和一个map。
vector用来保存输入文件的文本，map用来关联每个单词和它出现的行号的set。这个
类将会有一个用来读取给定输入文件的构造函数和一个执行查询的操作。
查询操作要完成的任务非常简单：查找map成员，检查给定单词是否出现。设计这
个函数的难点是确定应该返回什么内容。一旦找到了一个单词，我们需要知道它出现了多
少次、它出现的行号以及每行的文本。
返回所有这些内容的最简单的方法是定义另一个类，可以命名为QueryResult，来
保存查询结果。这个类会有一个print函数，完成结果打印工作。
在类之间共享数据
我们的QueryResult类要表达查询的结果。这些结果包括与给定单词关联的行号的
set和这些行对应的文本。这些数据都保存在TextQuery类型的对象中。
由于QueryResult所需要的数据都保存在一个TextQuery对象中，我们就必须确
定如何访问它们。我们可以拷贝行号的set，但这样做可能很耗时。而且，我们当然不希
望拷贝vector，因为这可能会引起整个文件的拷贝，而目标只不过是为了打印文件的一
小部分而已（通常会是这样）。
通过返回指向TextQuery对象内部的迭代器（或指针），我们可以避免拷贝操作。
但是，这种方法开启了一个陷阱：如果TextQuery对象在对应的QueryResult对象之
前被销毁，会发生什么?在此情况下，QueryResult就将引用一个不再存在的对象中的
数据。
对于QueryResult对象和对应的TextQuery对象的生存期应该同步这一观察结
果，其实已经暗示了问题的解决方案。考虑到这两个类概念上“共享”了数据，可以使用
shared_ptr（参见12。1。1节，第400页）来反映数据结构中的这种共享关系。
使用TextQuery类
当我们设计一个类时，在真正实现成员之前先编写程序使用这个类，是一种非常有用
的方法。通过这种方法，可以看到类是否具有我们所需要的操作。例如，下面的程序使用
了TextQuery和QueryResult类｡这个函数接受一个指向要处理的文件的ifstream，
并与用户交互，打印给定单词的查询结果
voidrunQueries（ifstream&infile）
{
//infile是一个ifstream，指向我们要处理的文件
TextQuerytq（infile）；//保存文件并建立查询map
//与用户交互：提示用户输入要查询的单词，完成查询并打印结果
while（true）{
cout<<"enterwordtolookfor，orqtoquit："；
strings；
//若遇到文件尾或用户输入了'q'时循环终止
if（!（cin>>s）||s=="q"）break；
//指向查询并打印结果
print（cout，tq。query（s））<<endl；
431
486

Page458
432
487
我们首先用给定的ifstream初始化一个名为tq的TextQuery对象。TextQuery的
构造函数读取输入文件，保存在vector中，并建立单词到所在行号的map。
while（无限）循环提示用户输入一个要查询的单词，并打印出查询结果，如此往复。
循环条件检测字面常量true（参见2。1。3节，第37页），因此永远成功。循环的退出是通
过if语句中的break（参见5。5。1节，第170页）实现的。此if语句检查输入是否成功。
如果成功，它再检查用户是否输入了q。输入失败或用户输入了q都会使循环终止。一日
用户输入了要查询的单词，我们要求tq查找这个单词，然后调用print打印搜索结果。
第12章动态内存
12。3。1节练习
练习12。27：TextQuery和QueryResult类只使用了我们已经介绍过的语言和标准
库特性。不要提前看后续章节内容，只用已经学到的知识对这两个类编写你自己的版本。
练习12。28：编写程序实现文本查询，不要定义类来管理数据。你的程序应该接受一个
文件，并与用户交互来查询单词。使用vector、map和set容器来保存来自文件的数
据并生成查询结果。
练习12。29：我们曾经用dowhile循环来编写管理用户交互的循环（参见5。4。4节，第
169页）。用dowhile重写本节程序，解释你倾向于哪个版本，为什么。
12。3。2文本查询程序类的定义
我们以TextQuery类的定义开始。用户创建此类的对象时会提供一个istream，
用来读取输入文件。这个类还提供一个query操作，接受一个string，返回一个
QueryResult表示string出现的那些行。
设计类的数据成员时，需要考虑与QueryResult对象共享数据的需求。
QueryResult类需要共享保存输入文件的vector和保存单词关联的行号的set｡因此，
这个类应该有两个数据成员：一个指向动态分配的vector（保存输入文件）的
shared_ptr和一个string到shared_ptr<set>的map。map将文件中每个单词关
联到一个动态分配的set上，而此set保存了该单词所出现的行号。
为了使代码更易读，我们还会定义一个类型成员（参见7。3。1节，第243页）来引用
行号，即string的vector中的下标：
classQueryResult；//为了定义函数query的返回类型，这个定义是必需的
classTextQuery{
public：
}；
usingline_no=std：：vector<std：：string>：：size_type；
TextQuery（std：：ifstream&）；
QueryResultquery（conststd：：string&）const；
private：
std：：shared_ptr<std：：vector<std：：string>>file；//输入文件
//每个单词到它所在的行号的集合的映射
std：：map<std：：string，
std：：shared_ptr<std：：set<line_no>>>wm；
488这个类定义最困难的部分是解开类名。与往常一样，对于可能置于头文件中的代码，在使
用标准库名字时要加上std：：（参见3。1节，第74页）。在本例中，我们反复使用了std：：，

Page459
12。3使用标准库：文本查询程序
使得代码开始可能有些难读。例如，
std：：map<std：：string，std：：shared_ptr<std：：set<line_no>>>wm；
如果写成下面的形式可能就更好理解一些
map<string，shared_ptr<set<line_no>>>wm；
TextQuery构造函数
TextQuery的构造函数接受一个ifstream，逐行读取输入文件：
//读取输入文件并建立单词到行号的映射
TextQuery：：TextQuery（ifstream&is）：file（newvector<string>）
{
stringtext；
while（getline（is，text））{
file->push_back（text）；
intn=file->size（）-1；
istringstreamline（text）；
stringword；
while（line>>word）{
//对文件中每一行
//保存此行文本
//当前行号
//将行文本分解为单词
//对行中每个单词
//如果单词不在wm中，以之为下标在wm中添加一项
auto&lines=wm[word]；//lines是一个shared_ptr
if（!lines）//在我们第一次遇到这个单词时，此指针为空
lines。reset（newset<line_no>）；//分配一个新的set
lines->insert（n）；
//将此行号插入set中
构造函数的初始化器分配一个新的vector来保存输入文件中的文本。我们用getline
逐行读取输入文件，并存入vector中。由于file是一个shared_ptr，我们用->运
算符解引用file来提取file指向的vector对象的push_back成员。
接下来我们用一个istringstream（参见8。3节，第287页）来处理刚刚读入的一
行中的每个单词。内层while循环用istringstream的输入运算符来从当前行读取每
个单词，存入word中。在while循环内，我们用map下标运算符提取与word相关联
的shared_ptr<set>，并将lines绑定到此指针。注意，lines是一个引用，因此改
变lines也会改变wm中的元素。
若word不在map中，下标运算符会将word添加到wm中（参见11。3。4节，第387
页），与word关联的值进行值初始化。这意味着，如果下标运算符将word添加到wm中，
lines将是一个空指针。如果lines为空，我们分配一个新的set，并调用reset更
新lines引用的shared_ptr，使其指向这个新分配的set。
不管是否创建了一个新的set，我们都调用insert将当前行号添加到set中。由
于lines是一个引用，对insert的调用会将新元素添加到wm中的set中。如果一个
给定单词在同一行中出现多次，对insert的调用什么都不会做。
QueryResult*
QueryResult类有三个数据成员：一个string，保存查询单词；一个shared_ptr，
指向保存输入文件的vector；一个shared_ptr，指向保存单词出现行号的set。它唯
433
489

Page460
434
一的一个成员函数是一个构造函数，初始化这三个数据成员：
classQueryResult（
friendstd：：ostream&print（std：：ostream&，constQueryResult&）；
public：
QueryResult（std：：strings，
private：
sought（s），lines（p），file（f）{}
{
std：：shared_ptr<std：：set<line_no>>p，
}
std：：stringsought；//查询单词
std：：shared_ptr<std：：set<line_no>>lines；
}；
构造函数的唯一工作是将参数保存在对应的数据成员中，这是在其初始化器列表中完成的
（参见7。1。4节，第237页）。
std：：shared_ptr<std：：vector<std：：string>>f）：
query函数
query函数接受一个string参数，即查询单词，query用它来在map中定位对应
的行号set。如果找到了这个string，query函数构造一个QueryResult，保存给定
string、TextQuery的file成员以及从wm中提取的set。
//出现的行号
std：：shared_ptr<std：：vector<std：：string>>file；//输入文件
唯一的问题是：如果给定string未找到，我们应该返回什么?在这种情况下，没有
可返回的set。为了解决此问题，我们定义了一个局部static对象，它是一个指向空的
行号set的shared_ptr。当未找到给定单词时，我们返回此对象的一个拷贝：
QueryResult
TextQuery：：query（conststring&sought）const
{
第12章动态内存
else
490打印结果
//如果未找到sought，我们将返回一个指向此set的指针
static
shared_ptr<set<line_no>>nodata（newset<line_no>）；
//使用find而不是下标运算符来查找单词，避免将单词添加到wm中!
autoloc=wm。find（sought）；
if（loc==wm。end（））
returnQueryResult（sought，nodata，file）；//未找到
print函数在给定的流上打印出给定的QueryResult对象：
ostream&print（ostream&os，constQueryResult&qr）
returnQueryResult（sought，loc->second，file）；
//如果找到了单词，打印出现次数和所有出现的位置
os<<qr。sought<<"occurs
<<qr。lines->size（）<<""
<<make_plural（qr。lines->size（），"time"，"s"）<<endl；
//打印单词出现的每一行
for（autonum：*qr。lines）//对set中每个单词
//避免行号从0开始给用户带来的困惑
os<<"\t（line"<<num+1<<"）
"1

Page461
12。3使用标准库：文本查询程序
<<*（qr。file->begin（）+num）<<endl；
returnoS；
}
我们调用qr。lines指向的set的size成员来报告单词出现了多少次。由于set是一
个shared_ptr，必须解引用lines。调用make_plural（参见6。3。2节，第201页）
来根据大小是否等于1打印time或times。
在for循环中，我们遍历lines所指向的set。for循环体打印行号，并按人们习
惯的方式调整计数值。set中的数值就是vector中元素的下标，从0开始编号。但大多
数用户认为第一行的行号应该是1，因此我们对每个行号都加上1，转换为人们更习惯的
形式。
我们用行号从file指向的vector中提取一行文本。回忆一下，当给一个迭代器加
上一个数时，会得到vector中相应偏移之后位置的元素（参见3。4。2节，第99页）。因
此，file->begin（）+num即为file指向的vector中第num个位置的元素。
注意此函数能正确处理未找到单词的情况。在此情况下，set为空。第一条输出语句
会注意到单词出现了0次。由于*res。lines为空，for循环一次也不会执行。
12。3。2节练习
练习12。30：定义你自己版本的TextQuery和QueryResult类，并执行12。3。1节（第
431页）中的runQueries函数。
练习12。31：如果用vector代替set保存行号，会有什么差别?哪种方法更好?为什
么?
练习12。32：重写TextQuery和QueryResult类，用StrBlob代替vector<string>
保存输入文件。
练习12。33：在第15章中我们将扩展查询系统，在QueryResult类中将会需要一些
额外的成员。添加名为begin和end的成员，返回一个迭代器，指向一个给定查询返
回的行号的set中的位置｡再添加一个名为get_file的成员，返回一个shared_ptr，
指向QueryResult对象中的文件。
435

Page462
436
491
小结
在C++中，内存是通过new表达式分配，通过delete表达式释放的。标准库还定
义了一个allocator类来分配动态内存块。
分配动态内存的程序应负责释放它所分配的内存。内存的正确释放是非常容易出错的
地方：要么内存永远不会被释放，要么在仍有指针引用它时就被释放了。新的标准库定义
了智能指针类型—-shared_ptr、unique_ptr和weak_ptr，可令动态内存管理更为
安全。对于一块内存，当没有任何用户使用它时，智能指针会自动释放它。现代C++程序
应尽可能使用智能指针。
术语表
allocator标准库类，用来分配未构造的
内存。
空悬指针（danglingpointer）一个指针，
指向曾经保存一个对象但现在已释放的内
存。众所周知，空悬指针引起的程序错误
非常难以调试。
delete释放new分配的内存。deletep
释放对象，delete[]p释放p指向的数
组。p可以为空，或者指向new分配的内
存。
释放器（deleter）传递给智能指针的函数，
用来代替delete释放指针绑定的对象。
析构函数（destructor）特殊的成员函数，
负责在对象离开作用域或被释放时完成清
理工作。
第12章动态内存
动态分配的（dynamicallyallocated）在
自由空间中分配的对象。在自由空间中分
配的对象直到被显式释放或程序结束才会
销毁。
自由空间（freestore）程序可用的内存池，
保存动态分配的对象。
堆（heap）自由空间的同义词。
new从自由空间分配内存。newT分配
并构造一个类型为T的对象，并返回一个
指向该对象的指针。如果T是一个数组类
型，new返回一个指向数组首元素的指针。
类似的，new[n]T分配n个类型为T
的对象，并返回指向数组首元素的指针。
默认情况下，分配的对象进行默认初始化。
我们也可以提供可选的初始化器。
定位new（placementnew）一种new表
达式形式，接受一些额外的参数，在new
关键字后面的括号中给出。例如，new
（nothrow）int告诉new不要抛出异常。
引用计数（referencecount）一个计数
器，记录有多少用户共享一个对象。智能
指针用它来判断什么时候释放所指向的对
象是安全的。
shared_ptr提供所有权共享的智能指
针：对共享对象来说，当最后一个指向它
的shared_ptr被销毁时会被释放。
智能指针（smartpointer）标准库类型，
行为类似指针，但可以检查什么时候使用
指针是安全的。智能指针类型负责在恰当
的时候释放内存。
unique_ptr提供独享所有权的智能指针：
当unique_ptr被销毁时，它指向的对象
被释放。unique_ptr不能直接拷贝或赋
值。
weak_ptr
种智能指针，指向由
shared_ptr管理的对象。在确定是否应
释放对象时，shared_ptr并不把
weak_ptr统计在内。

Page463
第Ⅱ部分
类设计者的工具
内容
第13章
第14章
第15章
第16章
拷贝控制，
操作重载与类型转换。。
面向对象程序设计
模板与泛型编程。
439
489
525
577
类是C++的核心概念。我们已经从第7章开始详细介绍了如何定义类。第7章涵盖了
使用类的所有基本知识：类作用域、数据隐藏以及构造函数，还介绍了类的一些重要特性：
成员函数、隐式this指针、友元以及const、static和mutable成员。在第III部分
中，我们将延伸类的有关话题的讨论，将介绍拷贝控制、重载运算符、继承和模板。
如前所述，在C++中，我们通过定义构造函数来控制在类类型的对象初始化时做什么。
类还可以控制在对象拷贝、赋值、移动和销毁时做什么。在这方面，C++与其他语言是不
同的，其他很多语言都没有给予类设计者控制这些操作的能力。第13章将介绍这些内容。
本章还会介绍新标准引入的两个重要概念：右值引用和移动操作。
第14章介绍运算符重载，这种机制允许内置运算符作用于类类型的运算对象。这样，
我们创建的类型直观上就可以像内置类型一样使用，运算符重载是C++借以实现这一目的
的方法之一。
类可以重载的运算符中有一种特殊的运算符——函数调用运算符。对于重载了这种运
494算符的类，我们可以“调用”其对象，就好像它们是函数一样。新标准库中提供了一些设
施，使得不同类型的可调用对象可以以一种一致的方式来使用，我们也将介绍这部分内容。
第14章最后将介绍另一种特殊类型的类成员函数——转换运算符。这些运算符定义
了类类型对象的隐式转换机制。编译器应用这种转换机制的场合与原因都与内置类型转换
是一样的。
第III部分的最后两章将介绍C++如何支持面向对象编程和泛型编程。
493
