# 使用函数

要使用CPP函数，必需做如下工作：

1.  提供函数原型
2.  提供函数定义
3.  调用函数

函数原型，格式如下：

```
typename functionName(parms);
```

比如：

```cpp
double calculate_tax(int tvarp);
```

函数定义，格式如下：

```
typename functionName(parms){
	statement(s)
}
```

如：

```cpp
double calculate_tax(int tvarp) {
    double tax = 0;
    if (tvarp > 15000) {
        tax += (tvarp - 15000) * 0.15;
        tvarp - 15000;
    }
    if (tvarp > 5000) {
        tax += (tvarp - 5000) * 0.1;
    }
    return tax;
}
```

# 函数参数

Cpp一般按值传递，就是会创建一个变量（形参），然后将实参的值传给形参。形参的生命周期只在函数执行过程中，执行结束就销毁。（如果形参是class类型，并且不是引用，那么会执行复制构造函数和析构函数）。

# 数组形参

数组的两个特殊性质：不允许拷贝数组以及使用数组时会将其转换成指针。

因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

```cpp
//尽管形式不同，但这三个print函数是等价的，每个函数都有一个const int*类型的形参

void print (const int*) ;
void print (const int[]) ;	//可以看出来，函数的意图是作用于一个数组
void print (const int[10]) ;	//这里的维度表示我们期望数组含有多少元素，实际不一定
```



# const形参

见const关键字总结

# 多维数组形参

```cpp
void array_fun_2(int (*arr)[2], int len);

void array_fun_3(int (*arr)[2][3], int len);
```

和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。

**数组第二维(以及后面所有维度)的大小都是数组类型的一部分，不能省略。**

# 结构形参

按值传递很简单，略。

传递结构的地址：

-   调用函数时，将结构的地址(&pplace)而不是结构本身(pplace) 传递给它
-   将形参声明为指向polar的指针，即polar \*类型。由于函数不应该修改结构，因此使用了const 修饰符
-   由于形参是指针而不是结构，因此应间接成员运算符(->)， 而不是成员运算符(句点)

# 函数指针

用法：

1.  获取函数的地址
2.  声明一个函数指针
3.  使用函数指针来调用函数

**获取函数的地址**

获取函数的地址很简单，只要使用函数名(后面不跟参数)即可。

**声明一个函数指针**

函数原型

```cpp
int fun(double d);
```

函数指针

```cpp
int (*pf)(double);
pf = fun;
```

**使用函数指针来调用函数**

```cpp
int fun(double d);
void use_fun_ptr(int num, int (*pf)(double));

int main()
{
    int (*pf)(double);
    pf = fun;
    use_fun_ptr(5, pf);
    return 0;
}

int fun(double d)
{
    return (int) d;
}

void use_fun_ptr(int num, int (*pf)(double))
{
    for (int i = 0; i < num; ++i)
    {
        cout << pf(i * 3.4 / 2) << endl;
    }
}
```

```
0
1
3
5
6
```

# C++函数调用原理

编译过程的最终产品是可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址，计算机随后将逐步执行这些指令。
执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码(也许还需将返回值放入到寄存器中)，然后跳回到地址被保存的指令处。

这意味着使用函数时，会有一定的开销。

# 内联函数

内联函数的编译代码与其他程序代码“内联”起来了。编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。

要使用内联函数，必须采取下述措施之一：

-   在函数声明前加上关键字inline
-   在函数定义前加上关键字inline

通常的做法是省略原型，将整个定义(即函数头和所有函数代码)放在本应提供原型的地方。

```cpp
inline void inline_function()
{
    cout << "i am inline function" << endl;
}
```

# 默认参数

```cpp
void default_fun(int n = 1);
```

通过函数原型添加默认参数。

# 函数匹配

```cpp
void f() ;
void f(int);
void f(int, int);
void f(double, double = 3.14);

f(5.6); // 调用void f(double, double = 3.14);
```

## 确定候选函数和可行函数

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。在这个例子中，有4个名为f的候选函数。

第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数(viable function)。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

我们能根据实参的数量从候选函数中排除掉两个。不使用形参的函数和使用两个int形参的函数显然都不适合本次调用，这是因为我们的调用只提供了一个实参，而它们分别有0个和两个形参。

如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似,实参与形参匹配的含义可能是它们具有相同的类型, 也可能是实参类型和形参类型满足转换规则。在上面的例子中,剩下的两个函数都是可行的:

-   f (int) 是可行的，因为实参类型 double 能转换成形参类型 int。
-   f(double, double) 是可行的，因为它的第二个形参提供了默认值，而第一个形参的类型正好是double，与函数使用的实参类型完全一致。

如果没找到可行函数,编译器将报告无匹配函数的错误。

## 含有多个形参的函数匹配

我们来分析如下的调用会发生什么情况：

f(42, 2.56);

如果有且只有一个函数满足下列条件，则匹配成功：

-   该函数每个实参的匹配都不劣于其他可行函数需要的匹配。
-   至少有一个实参的匹配优于其他可行函数提供的匹配。

如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。

在上面的调用中，只考虑第一个实参时我们发现函数f(int, int)能精确匹配；要想匹配第二个函数，int类型的实参必须转换成 double 类型。显然需要内置类型转换的匹配劣于精确匹配，因此仅就第一个实参来说，f(int, int)比f(double, double)更好。

接着考虑第二个实参2.56，此时f(double, double) 是精确匹配；要想调用f(int, int)必须将2.56从double类型转换成int类型｡ 因此仅就第二个实参来说, f(double, double)更好。

编译器最终将因为这个调用具有二义性而拒绝其请求：因为每个可行函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。

# 函数模版

```cpp
template<typename T>
void val_swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}

void test_val_swap()
{
    int *a = new int;
    int *b = new int;
    *a = 1;
    *b = 2;
    val_swap(a, b);

    cout << "a = " << *a << endl;
    cout << "b = " << *b << endl;
}
```

```
a = 2
b = 1
```

要建立一个模板，关键字template和typename是必需的，关键字class可以代替typename。另外，必须使用尖括号。类型名可以任意选择(这里为T)。

## 显式具体化

```cpp
//非模板函数
void val_swap(int &a, int &b);

//模板函数
template<typename T>
void val_swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}

//具体化，<int>是可选的，也可以不写
template<>
void val_swap<int>(int &a, int &b);
```

