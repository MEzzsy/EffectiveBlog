# 定义模板

## 函数模板

我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。

compare的模板版本可能像下面这样：

```c++
template <typename T>
int compare(const T &vl, const T &v2) {
  if (v1 < v2) return -1;
  if (v2 < vl) return 1;
  return 0;
}
```

类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。

我们的compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。

### 实例化函数模板

当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。

```
cout << compare(1, 0) << endl; //T为int
```

实参类型是int。编译器会推断出模板实参为int，并将它绑定到模板参数T。

编译器用推断出的模板参数来为我们实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。

这些编译器生成的版本通常被称为模板的实例（instantiation）。

### 模板类型参数

我们的compare函数有一个模板类型参数（type parameter）。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。

类型参数前必须使用关键字 class或typename。在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字。

### 非类型模板参数

除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename 来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。

例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是constchar的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度：

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1) [N], const char (&p2) [M])
{
	return strcmp(p1, p2);
}
```

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。

### inline 和 constexpr 的函数模板

函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样。inline或constexpr说明符放在模板参数列表之后，返回类型之前。

```c++
//正确：inline说明符跟在模板参数列表之后
template <typename T> inline T min(const T&, const T&);
//错误：inline说明符的位置不正确
inline template <typename T> T min (const T&, const T&);
```

### 模板编译

当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

函数模板和类模板成员函数的定义通常放在头文件中。

### 大多数编译错误在实例化期间报告

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。

-   第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。
-   第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。
-   第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

## 类模板

类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。

>   代码见demo的Blob.h

### 类模板的成员函数

与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。

```c++
template <typename T>
class Blob {
  // ...
  void check(size_type i, const std::string& msg) const;
};

// check member
template <typename T>
void Blob<T>::check(size_type i, const std::string& msg) const {
  if (i >= data->size()) throw std::out_of_range(msg);
}
```

### 类模板成员函数的实例化

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。

### 在类代码内简化模板类名的使用

当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。

### 在类模板外使用类模板名

当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。

```c++
// member operators
// postfix: increment/decrement the object but return the unchanged value
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int) {
  // no check needed here; the call to prefix increment will do the check
  BlobPtr ret = *this;  // save the current value
  ++*this;              // advance one element; prefix ++ checks the increment
  return ret;           // return the saved state
}
```

由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的BlobPtr，它所用类型与类实例化所用类型一致。在函数体内，我们已经进入类的作用域，因此在定义ret时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。因此，ret的定义与如下代码等价：

```c++
BlobPtr<T> ret = *this;
```

### 类模板和友元

当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

### 模板类型别名

类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个typedef来引用实例化的类。

```
typedef Blob<string> StrBlob;
```

新标准允许我们为类模板定义一个类型别名：

```
template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors 是一个pair<string, string>
```

## 模板参数

类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为T，但实际上我们可以使用任何名字。

### 模板参数与作用域

模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模669板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名。

### 使用类的类型成员

回忆一下，我们用作用域运算符（:）来访问static成员和类型成员。例如，如果我们写下string::size_type，编译器有 string 的定义，从而知道 size_type 是一个类型。

但对于模板代码就存在困难。例如，假定T是一个模板类型参数，当编译器遇到类似T::mem这样的代码时，它不会知道mem是一个类型成员还是一个static数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。

默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字typename来实现这一点：

```c++
template <typename T>
typename T::value_type top(const T& c) {
	if (!c.empty())
		return c.back();
    else
		return typename T::value_type();
}
```

### 默认模板实参

就像我们能为函数参数提供默认实参一样，我们也可以提供默认模板实参(default template argument)。

### 模板默认实参与类模板

无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。

```c++
template <class T = int> class Numbers {}
Numbers<long double> lots_of_precision;
Numbers<> average_precision; // 空<>表示我们希望使用默认类型
```

## 成员模板

一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数。

## 控制实例化

当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。

在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化（explicit instantiation）来避免这种开销。一个显式实例化有如下形式：

```
extern template declaration;	//实例化声明
template declaration;			//实例化声明
```

declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，

```
//实例化声明与定义
extern template class Blob<string>;			//声明
template int compare(const int&, const int&); // 定义
```

当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。

# 模板实参推断

对于函数模板，编译器利用调用中的函数实参来确定其模板参数。

## 函数模板显式实参

在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。

### 指定显式模板实参

```
template <typename T1, typename T2, typename T3>
Tl sum(T2, T3);
```

在本例中，没有任何函数实参的类型可用来推断T1的类型。

```
//T1是显式指定的，T2和T3是从函数实参类型推断而来的
auto val3 = sum<long long>(i, lng); // long long sum(int, long)
```

## 尾置返回类型与类型转换

![53](assets/53.jpg)

此例中，我们知道函数应该返回`*beg`，而且知道我们可以用`decltype（*beg）`来获取此表达式的类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数：

```c++
/**
 * @brief 尾置返回类型
 * @return 返回的是引用
 */
template <typename It>
auto fcn(It it) -> decltype(*it) {
  return *it;
}
```

```c++
void testFcn() {
  int array[1];
  array[0] = 123;
  NDK_LOG("array[0]=%d array[0] ptr=%p", array[0], &array[0]);
  int &num = fcn(std::begin(array));
  NDK_LOG("num=%d num ptr=%p", num, &num);
}
```

```
array[0]=123 array[0] ptr=0x7ff7b4fcb08c
num=123 num ptr=0x7ff7b4fcb08c
```

### 进行类型转换的标准库模板类

有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似fcn的函数，但返回一个元素的值而非引用。

为了获得元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件type_traits中。

```c++
/**
 * @brief 尾置返回类型
 * @return 返回的是值（拷贝）
 */
template <typename It>
auto fcn2(It it) -> typename std::remove_reference<decltype(*it)>::type {
  return *it;
}
```

```c++
void testFcn2() {
  int array[1];
  array[0] = 123;
  NDK_LOG("array[0]=%d array[0] ptr=%p", array[0], &array[0]);
  // int &num = fcn2(std::begin(array)); // 编译错误，不能返回引用
  int num = fcn2(std::begin(array));
  NDK_LOG("testFcn2 num=%d num ptr=%p", num, &num);
}
```

```
array[0]=123 array[0] ptr=0x7ff7baffe0ec
testFcn2 num=123 num ptr=0x7ff7baffe0e8
```

![54](assets/54.jpg)

## 函数指针和实参推断

当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。

例如，假定我们有一个函数指针，它指向的函数返回int，接受两个参数，每个参数都是指向constint的引用。我们可以使用该指针指向compare的一个实例：

```c++
template <typename T> int compare (const T&, const T&);
// pf1 指向实例 int compare(const int&, const int&)
int (*pf1) (const int&, const int&) = compare;
```

pf1中参数的类型决定了T的模板实参的类型。如果不能从函数指针类型确定模板实参，则产生错误：

```c++
//func的重载版本；每个版本接受一个不同的函数指针类型
void func (int (*) (const string&, const string&));
void func(int(*) (const int&, const int&));
func(compare); // 错误: 使用 compare 的哪个实例?
```

## 模板实参推断和引用

### 从左值引用函数参数推断类型

当一个函数参数是模板类型参数的一个普通（左值）引用时（即，形如T&），绑定规则告诉我们，只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。实参可以是const类型，也可以不是。如果实参是const的，则T将被推断为const类型：

```c++
template <typename T> void f1(T&); // 实参必须是一个左值
//对f1的调用使用实参所引用的类型作为模板参数类型
f1(i)；
//i是一个int；模板参数类型T是int
f1(ci); // ci 是一个 const int; 模板参数T是const int
f1(5)；//错误：传递给一个&参数的实参必须是一个左值
```

如果一个函数参数的类型是`const T&`，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象（const或非const）、一个临时对象或是一个字面常量值。当函数参数本身是const时，T的类型推断的结果不会是一个const类型。const已经是函数参数类型的一部分；因此，它不会也是模板参数类型的一部分：

```c++
template <typename T> void f2(const T&); // 可以接受一个右值
//f2中的参数是const&；实参中的const是无关的
//在每个调用中，f2的函数参数都被推断为constint&
f2(i)；//i是一个int；模板参数T是int
f2(ci); // ci 是一个 const int, 但模板参数T是 int
f2(5)；//一个const&参数可以绑定到一个右值；T是int
```

### 从右值引用函数参数推断类型

当一个函数参数是一个右值引用（即，形如T&&）时，正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的T的类型是该右值实参的类型：

```
template <typename T> void f3 (T&&);
f3(42)；//实参是一个int类型的右值；模板参数T是int
```

### 引用折叠和右值引用参数

假定i是一个int对象，我们可能认为像`f3(i)`这样的调用是不合法的。毕竟，i是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。

但是，C++语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是move这种标准库设施正确工作的基础。

1.   右值引用参数的推断成引用的引用。通常，我们不能（直接）定义一个引用的引用，但是，通过类型别名或通过模板类型参数间接定义是可以的。
2.   引用折叠。如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。

-   `X& &`，`X& &&`和`X&& &`都折叠成类型`X&`
-   类型`X&& &&`折叠成`X&&`

>   引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。

这两个规则导致了两个重要结果：

-   如果一个函数参数是一个指向模板类型参数的右值引用（如，T&&），则它可以被
    绑定到一个左值；且
-   如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将
    被实例化为一个（普通）左值引用参数（T&）

如果一个函数参数是指向模板参数类型的右值引用（如，T&&），则可以传递給它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&）。

### 编写接受右值引用参数的模板函数

模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响：
template <typename T> void f3(T&& val)
{
Tt=val；//拷贝还是绑定一个引用?
609
C++
11
689

Page 636
610
690
第16章模板与泛型编程
t=fcn（t）；//赋值只改变t还是既改变t又改变val?
if（val==t）{/*。。。*/}//若T是引用类型，则一直为true
}
当我们对一个右值调用f3时，例如字面常量42，T为int。在此情况下，局部变量t的
类型为int，且通过拷贝参数val的值被初始化。当我们对t赋值时，参数val保持
不变。
另一方面，当我们对一个左值i调用f3时，则T为int&。当我们定义并初始化局
部变量t时，赋予它类型int&。因此，对t的初始化将其绑定到val。当我们对t赋值
时，也同时改变了val的值。在f3的这个实例化版本中，if判断永远得到true。
当代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的
代码就变得异常困难（虽然removereference这样的类型转换类可能会有帮助（参见
16。2。3节，第605页））。
在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。我们将在
16。2。7节（第612页）中介绍实参转发，在16。3节（第614页）中介绍模板重载。
目前应该注意的是，使用右值引用的函数模板通常使用我们在13。6。3节（第481页）
中看到的方式来进行重载：
template <typename T> void f(T&&);
//绑定到非const右值
template <typename T> void f(const T&); // 左值和 const 右值
与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或
const 右值。
16。2。5节练习
练习16。42：对下面每个调用，确定T和val的类型：
template <typename T> void g(T&& val);
int i = 0; const int ci = i;
（a）g（i）；（b）g（ci）；（c）g（i*ci）；
=
ci），g的模板参数将是什
练习16。43：使用上一题定义的函数，如果我们调用g（i
么?
练习16。44：使用与第一题中相同的三个调用，如果g的函数参数声明为T（而不是T&&），
确定T的类型。如果g的函数参数是constT&呢?
练习16。45：给定下面的模板，如果我们对一个像42这样的字面常量调用g，解释会发
生什么?如果我们对一个int类型的变量调用g呢?
template <typename T> void g(T&& val) { vector<T> v; }
16。2。6理解std：：move
标准库move函数（参见13。6。1节，第472页）是使用右值引用的模板的一个很好的
例子。幸运的是，我们不必理解move所使用的模板机制也可以直接使用它。但是，研究
move是如何工作的可以帮助我们巩固对模板的理解和使用。
在13。6。2节（第473页）中我们注意到，虽然不能直接将一个右值引用绑定到一个左
值上，但可以用move获得一个绑定到左值上的右值引用。由于move本质上可以接受任

Page 637
16。2模板实参推断
何类型的实参，因此我们不会惊讶于它是一个函数模板。
std::move 是如何定义的
标准库是这样定义move的：
//在返回类型和类型转换中也要用到typename，参见16。1。3节（第593页）
//remove_reference是在16。2。3节（第605页）中介绍的
template <typename T>
typename
{
remove_reference<T>::type&& move (T&& t)
//static_cast是在4。11。3节（第145页）中介绍的
return static_cast<typename remove_reference<T>::type&&>(t);
}
这段代码很短，但其中有些微妙之处。首先，move的函数参数T&&是一个指向模板类型
参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可
以传递给move一个左值，也可以传递给它一个右值：
string sl("hi!"), s2;
s2=std：：move（string（"bye!"））；//正确：从一个右值移动数据
s2=std：：move（s1）；//正确：但在赋值之后，s1的值是不确定的
std::move 是如何工作的
在第一个赋值中，传递给move的实参是string的构造函数的右值结果一
string（"bye!"）。如我们已经见到过的，当向一个右值引用函数参数传递一个右值时，
由实参推断出的类型为被引用的类型（参见16。2。5节，第608页）。因此，在
std::move(string("bye!")) 中:
推断出的T的类型为string。
因此,remove_reference 用string 进行实例化。
string.
remove_reference<string> type
• move 的返回类型是 string&&。
• move 的函数参数t的类型为string&&。
因此，这个调用实例化move<string>，即函数
string&& move(string &&t)
函数体返回 static_cast<string&&>(t)。t 的类型已经是 string&&,于是类型转
换什么都不做。因此，此调用的结果就是它所接受的右值引用。
现在考虑第二个赋值，它调用了std：：move（）。在此调用中，传递给move的实参
是一个左值。这样：
• 推断出的T的类型为string& (string 的引用,而非普通 string)。
• 因此,remove_reference 用string&进行实例化。
• remove_reference<string&> type
• move 的返回类型仍是string&&。
move 的函数参数t实例化为string& &&,会折叠为string&。
因此，这个调用实例化move<string&>，即
string&& move(string &t)
string.
611
691

Page 638
612
这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返
回static_cast<string&&>(t)。在此情况下, t 的类型为 string&,cast 将其转
换为string& & 。
从一个左值static_cast到一个右值引用是允许的
11
C++通常情况下，staticcast只能用于其他合法的类型转换（参见4。11。3节，第145
页）。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为
右值引用，但我们可以用static_cast显式地将一个左值转换为一个右值引用。
对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断
692左值。有时候，例如在我们的StrVec类的reallocate函数（参见13。6。1节，第469
页）中，我们知道截断一个左值是安全的。一方面，通过允许进行这样的转换，C++语言
认可了这种用法。但另一方面，通过强制使用static_cast，C++语言试图阻止我们意
外地进行这种转换。
最后，虽然我们可以直接编写这种类型转换代码，但使用标准库move函数是容易得
多的方式。而且，统一使用std：：move使得我们在程序中查找潜在的截断左值的代码变
得很容易。
第16章模板与泛型编程
16。2。6节练习
练习16。46：解释下面的循环，它来自13。5节（第469页）中的StrVec：：reallocate：
for (size ti = 0; i != size(); ++i)
alloc.construct (dest++, std::move (*elem++));
16。2。7转发
某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们
需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。
作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我
们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函
数的初步模样：
//接受一个可调用对象和另外两个参数的模板
//对“翻转”的参数调用给定的可调用对象
//flipl是一个不完整的实现：顶层const和引用丟失了
template <typename F, typename T1, typename T2>
void flip1 (F f, T1 t1, T2 t2)
{
f（t2，t1）；
}
}
这个函数一般情况下工作得很好，但当我们希望用它调用一个接受引用参数的函数时就会
出现问题：
voidf（intv1，int&v2）//注意v2是一个引用
{
cout<<v1<<"<<++v2<<endl；

Page 639
16。2模板实参推断
在这段代码中，f改变了绑定到v2的实参的值。但是，如果我们通过flip1调用f，f
所做的改变就不会影响实参：
f（42，i）；
//f改变了实参i
flipl（f，j，42）；//通过flip1调用f不会改变j
问题在于j被传递给flip1的参数t1。此参数是一个普通的、非引用的类型int，而非
int&。因此，这个flip1调用会实例化为
void flipl (void (*fcn) (int, int&), int t1, int t2);
j的值被拷贝到t1中。f中的引用参数被绑定到t1，而非j，从而其改变不会影响j。
定义能保持类型信息的函数参数
为了通过翻转函数传递一个引用，我们需要重写函数，使其参数能保持给定实参的“左
值性”。更进一步，可以想到我们也希望保持参数的const属性。
通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应
实参的所有类型信息。而使用引用参数（无论是左值还是右值）使得我们可以保持const
属性，因为在引用类型中的const是底层的。如果我们将函数参数定义为T1&&和T2&&，
通过引用折叠（参见16。2。5节，第608页）就可以保持翻转实参的左值/右值属性（参见
16。2。5节，第608页）：
template <typename F, typename T1, typename T2>
void flip2(F f, T1 &&t1, T2 &&t2)
{
f（t2，t1）；
}
与较早的版本一样，如果我们调用flip2（f，j，42），将传递给参数t1一个左值j。
但是，在flip2中，推断出的T1的类型为int&，这意味着t1的类型会折叠为int&。
由于是引用类型，t1被绑定到j上。当flip2调用f时，f中的引用参数v2被绑定到
t1，也就是被绑定到j当f递增v2时，它也同时改变了j的值。
Note
如果一个函数参数是指向模板类型参数的右值引用（如T&&），它对应的实参
的const属性和左值/右值属性将得到保持。
这个版本的flip2解决了一半问题。它对于接受一个左值引用的函数工作得很好，
但不能用于接受右值引用参数的函数。例如：
void g(int &&i, int& j)
{
cout<<i<<""<<j<<endl；
}
如果我们试图通过flip2调用g，则参数t2将被传递给g的右值引用参数。即使我们传
递一个右值给flip2：
flip2（g，i，42）；//错误：不能从一个左值实例化int&&
传递给g的将是flip2中名为t2的参数。函数参数与其他任何变量一样，都是左值表
达式（参见13。6。1节，第471页）。因此，flip2中对g的调用将传递给g的右值引用参
数一个左值。
613
693

Page 640
614
694
11
695
在调用中使用std：：forward保持类型信息
我们可以使用一个名为forward的新标准库设施来传递flip2的参数，它能保持原
始实参的类型｡类似 move, forward 定义在头文件utility中。与move 不同, forward
必须通过显式模板实参来调用（参见16。2。2节，第603页）。forward返回该显式实参类
型的右值引用。即，forward<T>的返回类型是T&&。
通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参
数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值属性：
template <typename Type> intermediary(Type &&arg)
{
第16章模板与泛型编程
Note
finalFcn (std::forward<Type>(arg));
//。。。
}
本例中我们使用Type作为forward的显式模板实参类型，它是从arg推断出来的。由
于arg是一个模板类型参数的右值引用，Type将表示传递给arg的实参的所有类型信息。
如果实参是一个右值，则Type是一个普通（非引用）类型，forward<Type>将返回
Type&&。如果实参是一个左值，则通过引用折叠，Type本身是一个左值引用类型。在此
情况下，返回类型是一个指向左值引用类型的右值引用。再次对forward<Type>的返回
类型进行引用折叠，将返回一个左值引用类型。
Note
当用于一个指向模板参数类型的右值引用函数参数（T&&）时，forward会保
持实参类型的所有细节。
使用forward，我们可以再次重写翻转函数：
template <typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2)
{
f(std::forward<T2>(t2), std::forward<T1>(t1));
}
如果我们调用flip（g，i，42），i将以int&类型传递给g，42将以int&&类型传递
给go
与std::move 相同,对std::forward 不使用using 声明是一个好主意。
我们将在18。2。3节（第706页）中解释原因。
16。2。7节练习
练习16。47：编写你自己版本的翻转函数，通过调用接受左值和右值引用参数的函数来
测试它。
16。3重载与模板
函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函
数必须具有不同数量或类型的参数。
如果涉及函数模板，则函数匹配规则（参见6。4节，第209页）会在以下几方面受到

Page 641
16。3重载与模板
影响：
•对于一个调用，其候选函数包括所有模板实参推断（参见16。2节，第600页）成
功的函数模板实例。
候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。
●
与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来
排序。当然，可以用于函数模板调用的类型转换是非常有限的（参见16。2。1节，第
601页）。
•与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。
但是，如果有多个函数提供同样好的匹配，则：
如果同样好的函数中只有一个是非模板函数，则选择此函数。
如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比
其他模板更特例化，则选择此模板。
否则，此调用有歧义。
WARNING
编写重载模板
作为一个例子，我们将构造一组函数，它们在调试中可能很有用。我们将这些调试函
数命名为debug_rep，每个函数都返回一个给定对象的string表示。我们首先编写此
函数的最通用版本，将它定义为一个模板，接受一个const对象的引用：
正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的
实参类型转换有深刻的理解。
//打印任何我们不能处理的类型
template <typename T> string debug_rep(const T &t)
{
ostringstream ret; // 参见 8.3 节(第 287页)
ret<<t；//使用T的输出运算符打印t的一个表示形式
return ret.str(); // 返回 ret 绑定的 string 的一个副本
}
此函数可以用来生成一个对象对应的string表示，该对象可以是任意具备输出运算符的
类型。
{
接下来，我们将定义打印指针的debug_rep版本：
//打印指针的值，后跟指针指向的对象
//注意：此函数不能用于char*；参见16。3节（第617页）
template <typename T> string debug_rep(T *p)
ostringstream ret;
ret << "pointer: "
if (p)
else
<<pi
"1
//打印指针本身的值
ret<<"<<debug_rep（*p）；//打印p指向的值
ret << " null pointer"; // 或指出p为空
return ret.str(); // 返回 ret 绑定的 string 的一个副本
}
此版本生成一个string，包含指针本身的值和调用debug_rep获得的指针指向的值。
注意此函数不能用于打印字符指针，因为IO库为char*值定义了一个<<版本。此<<版本
假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。我们将在16。3
615
696

Page 642
616
697
节（第617页）介绍如何处理字符指针。
我们可以这样使用这些函数：
string s("hi");
cout << debug_rep(s)<< endl;
对于这个调用，只有第一个版本的debug_rep是可行的。第二个debug_rep版本要求
一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指
针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。由于只有一个可行
函数，所以此函数被调用。
如果我们用一个指针调用debug_rep：
cout << debug_rep(&s) << endl;
两个函数都生成可行的实例：
第16章模板与泛型编程
• debug_rep(const string*&),由第一个版本的 debug_rep 实例化而来,T
被绑定到 string*。
• debug_rep(string*),由第二个版本的 debug_rep 实例化而来,T被绑定到
string。
第二个版本的debug_rep的实例是此调用的精确匹配。第一个版本的实例需要进行普通
指针到const指针的转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编
译器确实选择了这个版本。
多个可行模板
作为另外一个例子，考虑下面的调用：
const string *sp = &s;
cout << debug_rep(sp)<< endl;
此例中的两个模板都是可行的，而且两个都是精确匹配：
debug_rep(const string*&),由第一个版本的 debug_rep 实例化而来,T
被绑定到 string*。
debug_rep(const string*),由第二个版本的 debug_rep 实例化而来,T
被绑定到 const string。
在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义
的。但是，根据重载函数模板的特殊规则，此调用被解析为debug_rep（T*），即，更特
例化的版本。
设计这条规则的原因是，没有它，将无法对一个const的指针调用指针版本的
debug_rep。问题在于模板 debug_rep(const T&)本质上可以用于任何类型,包括指
针类型。此模板比debug_rep（T*）更通用，后者只能用于指针类型。没有这条规则，传
递const的指针的调用永远是有歧义的。
Note
当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。
非模板和模板重载
作为下一个例子，我们将定义一个普通非模板版本的debug_rep来打印双引号包围

Page 643
16。3重载与模板
的string:
//打印双引号包围的string
string debug_rep(const string &s)
{
}
现在,当我们对一个 string 调用 debug_rep 时:
return57+S+'''；
string s("hi");
cout << debug_rep(s)<< endl;
有两个同样好的可行函数：
• debug_rep<string>(const string&),第一个模板,T被绑定到 string*。
• debug_rep(const string&),普通非模板函数。
在本例中，两个函数具有相同的参数列表，因此显然两者提供同样好的匹配。但是，编译
器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，出
于相同的原因，一个非模板函数比一个函数模板更好。
对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选
Note择非模板版本。
重载模板和类型转换
还有一种情况我们到目前为止尚未讨论：C风格字符串指针和字符串字面常量。现在
有了一个接受string的debug_rep版本，我们可能期望一个传递字符串的调用会匹配
这个版本。但是，考虑这个调用：
cout << debug_rep("hi world!") << endl; // 调用debug_rep (T*)
本例中所有三个debug_rep版本都是可行的：
• debug_rep(const T&),T被绑定到 char[10]。
• debug_rep(T*),T被绑定到 const char。
• debug_rep(const string&),要求从 const char*到 string 的类型转换。
对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次（许可的）数组
到指针的转换，而对于函数匹配来说，这种转换被认为是精确匹配（参见6。6。1节，第219
页）。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配
那么好，所以两个模板成为可能调用的函数。与之前一样，T*版本更加特例化，编译器会
选择它。
如果我们希望将字符指针按string处理，可以定义另外两个非模板重载版本：
//将字符指针转换为string, 并调用 string 版本的 debug_reg
string debug_rep(char *p)
{
}
}
return debug_rep(string(p));
string debug_rep(const char *p)
{
return debug_rep(string(p));
617
698

Page 644
618
699
C++
11
缺少声明可能导致程序行为异常
值得注意的是，为了使char*版本的debug_rep正确工作，在定义此版本时，
debug_rep（conststring&）的声明必须在作用域中。否则，就可能调用错误的
debug_rep 版本:
template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
//为了使debug_rep（char*）的定义正确工作，下面的声明必须在作用域中
string debug_rep(const string &);
string debug_rep(char *p)
{
V
第16章模板与泛型编程
}
通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而
言，则不是这样。如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不
重要了。在本例中，如果忘记了声明接受string参数的debug_rep版本，编译器会默
默地实例化接受constT&的模板版本。
Tip
//如果接受一个conststring&的版本的声明不在作用域中，
// 返回语句将调用 debug_rep(const T&)的T实例化为 string 的版本
return debug_rep(string(p));
在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器
由于未遇到你希望调用的函数而实例化一个并非你所需的版本。
16。3节练习
练习16。48：编写你自己版本的debug_rep函数。
练习16。49：解释下面每个调用会发生什么：
template <typename T> void f(T);
template <typename T> void f(const T*);
template <typename T> void g(T);
template <typename T> void T*)
inti=42，*p=&i；
const int ci = 0, *p2 = &ci;
g（42）；g（p）；g（ci）；g（p2）；
f（42）；f（p）；f（ci）；f（p2）；
练习16。50：定义上一个练习中的函数，令它们打印一条身份信息。运行该练习中的代
码。如果函数调用的行为与你预期不符，确定你理解了原因。
16。4可变参数模板
一个可变参数模板（variadictemplate）就是一个接受可变数目参数的模板函数或模板
类。可变数目的参数被称为参数包（parameterpacket）。存在两种参数包：模板参数包
700 (template parameter packet),表示零个或多个模板参数;函数参数包(function parameter
packet），表示零个或多个函数参数。
我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表

Page 645
16。4可变参数模板
中，class。。。或typename。。。指出接下来的参数表示零个或多个类型的列表；一个类型
名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，
如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：
//Args是一个模板参数包；rest是一个函数参数包
//Args表示零个或多个模板类型参数
//rest表示零个或多个函数参数
template <typename T, typename... Args>
void foo(const T &t, const Args&
rest);
声明了foo是一个可变参数函数模板，它有一个名为T的类型参数，和一个名为Args
的模板参数包。这个包表示零个或多个额外的类型参数。foo的函数参数列表包含一个
const&类型的参数，指向T的类型，还包含一个名为rest的函数参数包，此包表示零
个或多个函数参数。
与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译
器还会推断包中参数的数目。例如，给定下面的调用：
int i = 0; double d = 3.14; string s = "how now brown cow";
//包中有三个参数
//包中有两个参数
//包中有一个参数
//空包
foo（i，s，42，d）；
foo（s，42，"hi"）；
foo(d, s);
foo("hi");
编译器会为foo实例化出四个不同的版本：
void foo(const int&, const string&, const int&, const double&);
void foo(const string&, const int&, const char[3]&);
void foo(const double&, const string&);
void foo(const char[3]&);
在每个实例中，T的类型都是从第一个实参的类型推断出来的。剩下的实参（如果有的话）
提供函数额外实参的数目和类型。
sizeof...运算符
当我们需要知道包中有多少元素时，可以使用sizeof。。。运算符。类似sizeof（参
见4。9节，第139页），sizeof。。。也返回一个常量表达式（参见2。4。4节，第58页），而且
不会对其实参求值：
template<typename
Args> void g(Args
args){
cout << sizeof...(Args) << endl; //类型参数的数目
cout << sizeof...(args) << endl; //函数参数的数目
}
16。4节练习
练习 16.51:调用本节中的每个 foo,确定 sizeof... (Args)和sizeof(rest)分别
返回什么。
练习16。52：编写一个程序验证上一题的答案。
619
C++
11
701

Page 646
620
16。4。1编写可变参数函数模板
如6。2。6节（第198页）所述，我们可以使用一个initializer_list来定义一个
可接受可变数目实参的函数。但是，所有实参必须具有相同的类型（或它们的类型可以转
换为同一个公共类型）。当我们既不知道想要处理的实参的数目也不知道它们的类型时，
可变参数函数是很有用的。作为一个例子，我们将定义一个函数，它类似较早的
error_msg函数，差别仅在于新函数实参的类型也是可变的。我们首先定义一个名为
print的函数，它在一个给定流上打印给定实参列表的内容。
可变参数函数通常是递归的（参见6。3。2节，第204页）。第一步调用处理包中的第一
个实参，然后用剩余实参调用自身。我们的print函数也是这样的模式，每次递归调用
将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变
参数的print函数，它接受一个流和一个对象：
//用来终止递归并打印最后一个元素的函数
//此函数必须在可变参数版本的print定义之前声明
template<typename T>
ostream &print (ostream &os, const T &t)
{
returnos<<t；//包中最后一个元素之后不打印分隔符
}
//包中除了最后一个元素之外的其他元素都会调用这个版本的print
第16章模板与泛型编程
template <typename T, typename... Args>
ostream &print (ostream &os, const T &t, const Args&... rest)
{
os<<t<<"，"；
return print(os, rest...);
//打印第一个实参
//递归调用，打印其他实参
}
第一个版本的print负责终止递归并打印初始调用中的最后一个实参。第二个版本的
print是可变参数版本，它打印绑定到t的实参，并调用自身来打印函数参数包中的剩
余值。
这段程序的关键部分是可变参数函数中对print的调用：
return print(os, rest...); //递归调用,打印其他实参
我们的可变参数版本的print函数接受三个参数：一个ostream&，一个constT&和
个参数包。而此调用只传递了两个实参。其结果是rest中的第一个实参被绑定到t，剩
702余实参形成下一个print调用的参数包。因此，在每个调用中，包中的第一个实参被移
除，成为绑定到t的实参。即，给定：
print（cout，i，s，42）；//包中有两个参数
递归会执行如下：
调用
print (cout, i, s, 42)
print(cout, s, 42)
S
print(cout, 42) 调用非可变参数版本的 print
t
i
rest...
s，42
42
前两个调用只能与可变参数版本的print匹配，非可变参数版本是不可行的，因为这两
个调用分别传递四个和三个实参，而非可变参数print只接受两个实参。

Page 647
16。4可变参数模板
对于最后一次递归调用print（cout，42），两个print版本都是可行的。这个调
用传递两个实参，第一个实参的类型为ostream&。因此，可变参数版本的print可以
实例化为只接受两个参数：一个是ostream&参数，另一个是constT&参数。
对于最后一个调用，两个函数提供同样好的匹配。但是，非可变参数模板比可变参数
模板更特例化，因此编译器选择非可变参数版本（参见16。3节，第615页）。
当定义可变参数版本的print时，非可变参数版本的声明必须在作用域中。
WARNING否则，可变参数版本会无限递归。
16。4。1节练习
练习16。53：编写你自己版本的print函数，并打印一个、两个及五个实参来测试它，
要打印的每个实参都应有不同的类型。
练习16。54：如果我们对一个没有<<运算符的类型调用print，会发生什么?
练习16。55：如果我们的可变参数版本print的定义之后声明非可变参数版本，解释可
变参数的版本会如何执行。
16。4。2包扩展
对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）
它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）。扩展一个包就是
将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边
放一个省略号（。。。）来触发扩展操作。
例如，我们的print函数包含两个扩展：
template <typename T, typename... Args>
ostream &
print (ostream &os, const T &t, const Args&... rest)
{
os<<t<<"，"；
return print(os, rest...);
//扩展Args
//扩展rest
}
第一个扩展操作扩展模板参数包，为print生成函数参数列表。第二个扩展操作出现在
对print的调用中。此模式为print调用生成实参列表。
对Args的扩展中，编译器将模式constArg&应用到模板参数包Args中的每个元
素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如
const type&。例如:
print（cout，i，s，42）；//包中有两个参数
最后两个实参的类型和模式一起确定了尾置参数的类型。此调用被实例化为：
ostream&
print (ostream&, const int&, const string&, const int&);
第二个扩展发生在对print的（递归）调用中。在此情况下，模式是函数参数包的
名字（即rest）。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调
621
703

Page 648
622
704
C++
11
用等价于：
print(os, s, 42);
理解包扩展
print中的函数参数包扩展仅仅将包扩展为其构成元素，C++语言还允许更复杂的扩
展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用debug_rep（参
见16。3节，第615页），然后调用print打印结果string：
// 在 print 调用中对每个实参调用 debug_rep
template <typename... Args>
ostream &errorMsg(ostream &os, const Args&... rest)
{
第16章模板与泛型编程
// print(os, debug_rep(al), debug_rep(a2),
return print(os, debug_rep(rest)...);
}
这个print调用使用了模式debug_reg（rest）。此模式表示我们希望对函数参数
包rest中的每个元素调用debug_rep。扩展结果将是一个逗号分隔的debug_rep调
用列表。即，下面调用：
debug_rep (an)
errorMsg (cerr, fcnName, code.num (), otherData, "other", item);
就好像我们这样编写代码一样
print(cerr, debug_rep(fcnName), debug_rep(code.num()),
debug_rep(otherData), debug_rep("otherData"),
debug_rep(item));
Note
与之相对，下面的模式会编译失败
// 将包传递给 debug_rep; print (os, debug_rep(al, a2,
print (os, debug_rep(rest...)); // 错误:此调用无匹配函数
这段代码的问题是我们在debug_rep调用中扩展了rest，它等价于
print(cerr, debug_rep(fcnName, code.num(),
扩展中的模式会独立地应用于包中的每个元素。
otherData, "otherData", item));
在这个扩展中，我们试图用一个五个实参的列表来调用debug_rep，但并不存在与此调
用匹配的debug_rep版本.debug_rep函数不是可变参数的,而且没有哪个debug_rep
版本接受五个参数。
an））
16。4。2节练习
练习16。56：编写并测试可变参数版本的errorMsg。
练习16。57：比较你的可变参数版本的errorMsg和6。2。6节（第198页）中的error_msg
函数。两种方法的优点和缺点各是什么?
16。4。3转发参数包
在新标准下，我们可以组合使用可变参数模板与forward机制来编写函数，实现将

Page 649
16。4可变参数模板
其实参不变地传递给其他函数。作为例子，我们将为StrVec类（参见13。5节，第465
页)添加一个 emplace_back 成员。标准库容器的 emplace_back 成员是一个可变参
数成员模板（参见16。1。4节，第596页），它用其实参在容器管理的内存空间中直接构造
一个元素。
我们为 StrVec 设计的 emplace_back 版本也应该是可变参数的,因为 string 有
多个构造函数，参数各不相同。由于我们希望能使用string的移动构造函数，因此还需
要保持传递给emplace_back的实参的所有类型信息。
如我们所见，保持类型信息是一个两阶段的过程。首先，为了保持实参中的类型信息，
必须将emplace_back的函数参数定义为模板类型参数的右值引用（参见16。2。7节，第
613页）：
class StrVec {
public:
template <class... Args> void emplace_back(Args&&...);
//其他成员的定义，同13。5节（第465页）
}；
模板参数包扩展中的模式是&&，意味着每个函数参数将是一个指向其对应实参的右值引
用。
其次,当emplace_back将这些实参传递给 construct 时,我们必须使用 forward
来保持实参的原始类型（参见16。2。7节，第614页）：
template <class... Args>
inline.
void StrVec::emplace_back(Args&&... args)
{
chknalloc（）；//如果需要的话重新分配StrVec内存空间
alloc.construct (first free++, std::forward<Args>(args)...);
emplace_back的函数体调用了chk_n_alloc（参见13。5节，第465页）来确保有足
够的空间容纳一个新元素，然后调用了construct在first_free指向的位置中创建
了一个元素。construct调用中的扩展为
std::forward<Args>(args)...
它既扩展了模板参数包Args，也扩展了函数参数包args。此模式生成如下形式的元素
std::forward<T>(t)
其中T表示模板参数包中第i个元素的类型，t表示函数参数包中第i个元素。例如，
假定svec是一个StrVec，如果我们调用
svec.emplace_back(10, 'c'); // 将 cccccccccc 添加为新的尾元素
construct 调用中的模式会扩展出
std::forward<int>(10), std::forward<char>(c)
通过在此调用中使用forward，我们保证如果用一个右值调用emplace_back，则
construct也会得到一个右值。例如，在下面的调用中：
svec.emplace_back(s1 + s2); // 使用移动构造函数
传递给 emplace_back 的实参是一个右值,它将以如下形式传递给 construct
623
705

Page 650
624
706
第16章模板与泛型编程
std::forward<string>(string("the end"))
forward<string>的结果类型是 string&&, 因此 construct 将得到一个右值引用实
参。construct会继续将此实参传递给string的移动构造函数来创建新元素。
建议：转发和可变参数模板
可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的
emplace_back 函数一样的形式:
//fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用
template<typename... Args>
void fun(Args&&... args) //将Args 扩展为一个右值引用的列表
（
// work 的实参既扩展 Args 又扩展args
work(std::forward<Args>(args)...);
}
这里我们希望将fun的所有实参转发给另一个名为work的函数，假定由它完成函数的
实际工作。类似 emplace_back中对 construct 的调用, work 调用中的扩展既扩展
了模板参数包也扩展了函数参数包。
由于fun的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们
使用std：：forward传递这些实参，因此它们的所有类型信息在调用work时都会得
到保持。
16。4。3节练习
练习16。58：为你的StrVec类及你为16。1。2节（第591页）练习中编写的Vec类添加
emplace back 函数。
练习16。59：假定s是一个string，解释调用svec。emplace_back（s）会发生什么。
练习16。60：解释make_shared（参见12。1。1节，第401页）是如何工作的。
练习16。61：定义你自己版本的makeshared。
16。5模板特例化
编写单一模板，使之对任何可能的模板实参都是最适合的，都能实例化，这并不总是
能办到。在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败
或做得不正确。其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从
通用模板实例化。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一
个特例化版本。
我们的compare函数是一个很好的例子，它展示了函数模板的通用定义不适合一个
特定类型（即字符指针）的情况。我们希望compare通过调用strcmp比较两个字符指
针而非比较指针值。实际上，我们已经重载了compare函数来处理字符串字面常量（参
见16。1。1节，第579页）：

Page 651
16。5模板特例化
//第一个版本；可以比较任意两个类型
template <typename T> int compare(const T&, const T&);
//第二个版本处理字符串字面常量
template<size_t N, size_t M>
int compare(const char (&) [N], const char (&) [M]);
但是，只有当我们传递给compare一个字符串字面常量或者一个数组时，编译器才会调
用接受两个非类型模板参数的版本。如果我们传递给它字符指针，就会调用第一个版本：
const char *p1 = "hi", *p2 = "mom";
compare (p1, p2);
compare ("hi", "mom");
//调用第一个模板
//调用有两个非类型参数的版本
我们无法将一个指针转换为一个数组的引用，因此当参数是p1和p2时，第二个版本的
compare 是不可行的。
为了处理字符指针（而不是数组），可以为第一个版本的compare定义一个模板特例
化(template specialization)版本。一个特例化版本就是模板的一个独立的定义,在其中一
个或多个模板参数被指定为特定的类型。
定义函数模板特例化
当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指
出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对（<>）。空尖
括号指出我们将为原模板的所有模板参数提供实参：
//compare的特殊版本，处理字符数组的指针
template <>
int compare(const char* const&pl, const char* const&p2)
{
return strcmp(p1,p2);
}
理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数
类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：
template <typename T> int compare (const T&, const T&);
其中函数参数为一个const类型的引用。类似类型别名，模板参数类型、指针及const
之间的相互作用会令人惊讶（参见2。5。1节，第60页）。
我们希望定义此函数的一个特例化版本，其中T为constchar*。我们的函数要求
一个指向此类型const版本的引用。一个指针类型的const版本是一个常量指针而不是
指向const类型的指针（参见2。4。2节，第56页）。我们需要在特例化版本中使用的类型
是const char* const&,即一个指向 const char的const 指针的引用。
Note
函数重载与模板特例化
当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模
板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而
非函数名的一个重载版本。
特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。
625
707
708

Page 652
626
709
第16章模板与泛型编程
我们将一个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到
函数匹配。例如，我们已经定义了两个版本的compare函数模板，一个接受数组引用参
数，另一个接受constT&。我们还定义了一个特例化版本来处理字符指针，这对函数匹
配没有影响。当我们对字符串字面常量调用compare时
compare ("hi", "mom")
对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字
符数组参数的版本更特例化（参见16。3节，第615页），因此编译器会选择它。
如果我们将接受字符指针的compare版本定义为一个普通的非模板函数（而不是模
板的一个特例化版本），此调用的解析就会不同。在此情况下，将会有三个可行的函数：
两个模板和非模板的字符指针版本。所有三个函数都提供同样好的匹配。如前所述，当一
个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本（参见16。3节，
第615页）。
关键概念：普通作用域规则应用于特例化
为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例
的代码之前，特例化版本的声明也必须在作用域中。
对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处
理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生
成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特
例化版本声明顺序导致的错误，而这种错误又很难查找。
如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参
集合，就会产生错误。但是，这种错误编译器又无法发现。
Best
Practices
模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放
在前面，然后是这些模板的特例化版本。
类模板特例化
除了特例化函数模板，我们还可以特例化类模板。作为一个例子，我们将为标准库
hash模板定义一个特例化版本，可以用它来将Sales_data对象保存在无序容器中。默
认情况下，无序容器使用hash<key_type>（参见11。4节，第394页）来组织其元素。
为了让我们自己的数据类型也能使用这种默认组织方式，必须定义hash模板的一个特例
化版本。一个特例化hash类必须定义：
•一个重载的调用运算符（参见14。8节，第506页），它接受一个容器关键字类型的
对象，返回一个sizet。
两个类型成员,result_type 和argument_type,分别调用运算符的返回类型
和参数类型。
‧默认构造函数和拷贝赋值运算符（可以隐式定义，参见13。1。2节，第443页）。
在定义此特例化版本的hash时，唯一复杂的地方是：必须在原模板定义所在的命名空
间中特例化它。我们将在18。2节（第695页）中介绍更多命名空间的相关内容。现在，我
们只需知道——我们可以向命名空间添加成员。为了达到这一目的，首先必须打开命名空间：
//打开std命名空间，以便特例化std：：hash
namespace std {

Page 653
16。5模板特例化
}//关闭std命名空间；注意：右花括号之后没有分号
花括号对之间的任何定义都将成为命名空间std的一部分。
下面的代码定义了一个能处理Sales_data的特例化hash版本：
//打开std命名空间，以便特例化std：：hash
namespace std {
template<>//我们正在定义一个特例化版本，模板参数为Salesdata
struct hash<Sales_data>
{
//用来散列一个无序容器的类型必须要定义下列类型
typedef size_t result_type;
typedef Sales_data argument_type; //默认情况下,此类型需要==
size_t operator() (const Sales_data& s) const;
//我们的类使用合成的拷贝控制成员和默认构造函数
}；
size t
{
hash<Sales_data>::operator() (const Sales_data& s) const
return hash<string>()(s.bookNo)
hash<unsigned>() (s.units_sold)
hash<double>() (s.revenue);
}
}//关闭std命名空间；注意：右花括号之后没有分号
^
我们的hash<Sales_data>定义以template<>开始，指出我们正在定义一个全特例化
的模板。我们正在特例化的模板名为hash，而特例化版本为hash<Sales_data>。接
下来的类成员是按照特例化hash的要求而定义的。
类似其他任何类，我们可以在类内或类外定义特例化版本的成员，本例中就是在类外
定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任
何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）
应该产生不同的结果。
在本例中，我们将定义一个好的哈希函数的复杂任务交给了标准库。标准库为内置类
型和很多标准库类型定义了hash类的特例化版本。我们使用一个（未命名的）
hash<string>对象来生成 bookNo 的哈希值,用一个 hash<unsigned>对象来生成
units_sold 的哈希值,用一个 hash<double>对象来生成 revenue 的哈希值。我们
将这些结果进行异或运算（参见4。8节，第137页），形成给定Salesdata对象的完整
的哈希值。
值得注意的是，我们的hash函数计算所有三个数据成员的哈希值，从而与我们为
Sales_data定义的operator==（参见14。3。1节，第497页）是兼容的。默认情况下，
为了处理特定关键字类型，无序容器会组合使用key_type对应的特例化hash版本和
key_type上的相等运算符。
假定我们的特例化版本在作用域中，当将Sales_data作为容器的关键字类型时，
编译器就会自动使用此特例化版本：
// 使用 hash<Sales data>和14.3.1 节(第 497页)中 Sales data的operator==
unordered multiset<Sales data> SDset;
由于 hash<Sales_data>使用 Sales_data 的私有成员,我们必须将它声明为
627
710

Page 654
628
711
Sales_data 的友元:
template <class T> class std::hash; // 友元声明所需要的
class Sales data {
friend class std::hash<Sales data>;
//其他成员定义，如前
}；
这段代码指出特殊实例 hash<Sales_data>是 Sales_data 的友元。由于此实例定义
在std命名空间中，我们必须记得在friend声明中应使用std：：hash。
Note
第16章模板与泛型编程
Note
为了让Salesdata的用戶能使用hash的特例化版本，我们应该在
Salesdata的头文件中定义该特例化版本。
类模板部分特例化
与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一
部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化
（partialspecialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指
定的模板参数提供实参。
我们只能部分特例化类模板，而不能部分特例化函数模板。
在16。2。3节（第605页）中我们介绍了标准库remove_reference类型。该模板是
通过一系列的特例化版本来完成其功能的：
//原始的、最通用的版本
template <class T> struct remove_reference {
typedef T type;
}；
//部分特例化版本，将用于左值引用和右值引用
template <class T> struct remove_reference<T&> // 左值引用
{ typedef T type; };
template <class T> struct remove_reference<T&&> // 右值引用
{ typedef T type; };
第一个模板定义了最通用的模板。它可以用任意类型实例化；它将模板实参作为type成
员的类型。接下来的两个类是原始模板的部分特例化版本。
由于一个部分特例化版本本质是一个模板，与往常一样，我们首先定义模板参数。类
似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定
类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们
为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始
模板中的参数按位置对应。
部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例
化版本。在本例中，特例化版本的模板参数的数目与原始模板相同，但是类型不同。两个
特例化版本分别用于左值引用和右值引用类型：
int i;
//decltype（42）为int，使用原始模板
remove_reference<decltype(42)>::type a;

Page 655
16。5模板特例化
//decltype（i）为int&，使用第一个（T&）部分特例化版本
remove_reference<decltype(i)>::type
b；
//decltype（std：：move（i））为int&&，使用第二个（即T&&）部分特例化版本
remove_reference<decltype (std::move(i))>::type c;
三个变量a、b和c均为int类型。
特例化成员而不是类
我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果Foo是一个模
板类，包含一个成员Bar，我们可以只特例化该成员：
template <typename T> struct Foo {
Foo(const T &t= T()): mem(t) { }
voidBar（）{/*。。。*/}
}；
T mem;
//Foo的其他成员
template<>
//我们正在特例化一个模板
void Foo<int>::Bar() // 我们正在特例化 Foo<int>的成员 Bar
{
//进行应用于int的特例化处理
}
本例中我们只特例化Foo<int>类的一个成员，其他成员将由Foo模板提供：
// 实例化 Foo<string>::Foo()
// 实例化 Foo<string>::Bar()
//实例化Foo<int>：：Foo（）
//使用我们特例化版本的Foo<int>：：Bar（）
Foo<string> fs;
fs.Bar();
Foo<int> fi;
fi.Bar();
当我们用int之外的任何类型使用Foo时，其成员像往常一样进行实例化。当我们用int
使用Foo时，Bar之外的成员像往常一样进行实例化。如果我们使用Foo<int>的成员
Bar，则会使用我们定义的特例化版本。
16。5节练习
练习 16.62:定义你自己版本的 hash<Sales data>,并定义一个 Sales data对象
的unordered_multiset。将多条交易记录保存到容器中,并打印其内容。
练习16。63：定义一个函数模板，统计一个给定值在一个vector中出现的次数。测试
你的函数,分别传递给它一个 double 的 vector, 一个 int 的 vector 以及一个
string的vector。
练习16。64为上一题中的模板编写特例化版本来处理vector<constchar*>。编
写程序使用这个特例化版本。
练习16。65：在16。3节（第617页）中我们定义了两个重载的debug_rep版本，一个
接受constchar*参数，另一个接受char*参数。将这两个函数重写为特例化版本。
练习16。66：重载debug_rep函数与特例化它相比，有何优点和缺点?
练习16。67：定义特例化版本会影响debug_rep的函数匹配吗?如果不影响，为什么?
629
712

Page 656
630
713
小结
模板是C++语言与众不同的特性，也是标准库的基础。一个模板就是一个编译器用来
生成特定类类型或函数的蓝图。生成特定类或函数的过程称为实例化。我们只编写一次模
板，就可以将其用于多种类型和值，编译器会为每种类型和值进行模板实例化。
我们既可以定义函数模板，也可以定义类模板。标准库算法都是函数模板，标准库容
器都是类模板。
显式模板实参允许我们固定一个或多个模板参数的类型或值。对于指定了显式模板实
参的模板参数，可以应用正常的类型转换。
一个模板特例化就是一个用户提供的模板实例，它将一个或多个模板参数绑定到特定
类型或值上。当我们不能（或不希望）将模板定义用于某些特定类型时，特例化非常有用。
第16章模板与泛型编程
最新C++标准的一个主要部分是可变参数模板。一个可变参数模板可以接受数目和类
型可变的参数。可变参数模板允许我们编写像容器的emplace成员和标准库
makeshared函数这样的函数，实现将实参传递给对象的构造函数。
术语表
类模板(class template) 模板定义,可
从它实例化出特定的类。类模板的定义以
关键字template开始，后跟尖括号对<
和>，其内为一个用逗号分隔的一个或多个
模板参数的列表，随后是类的定义。
默认模板实参(default template argument)
一个类型或一个值，当用户未提供对应模
板实参时，模板会使用它。
显式模板实参(explicit template argument)
在一个函数调用中或定义模板类类型时，
由用户提供的模板实参。显式模板实参在
紧跟在模板名的尖括号对中给出。
显式实例化(explicit instantiation)
的类或函数。
声明，为所有模板参数提供了显式实参。714实例（instantiation）编译器从模板生成
用来指导实例化过程。如果声明是extern
的，模板将不会被实例化；否则，模板将
利用指定的实参进行实例化。对每个
extern模板声明，在程序中某处必须有
一个extern的显式实例化。
函数参数包(function parameter pack)表
示零个或多个函数参数的参数包。
函数模板(function template) 模板定义,
可从它实例化出特定函数。函数模板的定
义以关键字template开始，后跟尖括号
对<和>，其内为一个用逗号分隔的一个或
多个模板参数的列表，随后是函数的定义。
实例化(instantiate) 编译器处理过程,
用实际的模板实参来生成模板的一个特殊
实例，其中参数被替换为对应的实参。当
函数模板被调用时，会自动根据传递给它
的实参来实例化。而使用类模板时，则需
要我们提供显式模板实参。
成员模板(member template) 本身是模
板的成员函数。成员模板不能是虚函数。
非类型参数(nontype parameter) 表示
值的模板参数。非类型模板参数的实参必
须是常量表达式。
包扩展(pack expansion) 处理过程,将
一个参数包替换为其中元素的列表。
参数包(parameter pack) 表示零个或多
个参数的模板或函数参数。
部分特例化(partial specialization) 类模
板的一个版本，其中指定了某些但不是所

Page 657
术语表
有模板参数，或是一个或多个参数的属性
未被完全指定。
模式（pattern）定义了扩展后参数包中每
个元素的形式。
模板实参(template argument) 用来实
例化模板参数的类型或值。
模板实参推断(template argument
deduction）编译器确定实例化哪个函数
模板的过程。编译器检查那些使用模板参
数的实参的类型，将这些类型或值绑定到
模板参数，来自动实例化一个函数版本。
模板参数(template parameter) 在模板
参数列表中指定的名字，可在模板定义内
部使用。模板参数可以是类型参数，也可
以是非类型参数。为了使用一个类模板，
我们必须为每个模板参数提供显式实参。
编译器使用这些类型或值实例化出一个类
版本，其中所有用到模板参数的地方都被
替换为实际的实参。当使用一个函数模板
时，编译器使用调用中的函数实参推断模
板实参，并使用推断出的模板实参实例化
出一个特定的函数。
模板参数列表(template parameter list)
用逗号分隔的参数列表，用于模板的定义
或声明中。每个参数可以是一个类型参数，
也可以是一个非类型参数。
模板参数包(template parameter pack)
表示零个或多个模板参数的参数包。
模板特例化(template specialization)类
模板、类模板的成员或函数模板的重定义，
其中指定了某些（或全部）模板参数。模
板特例化版本必须出现在原模板的声明之
后，必须出现在任何利用特殊实参来使用
模板的代码之前。一个函数模板中的每个
模板参数都必须完全特例化。
类型参数(type parameter)模板参数列
表中的名字，用来表示类型。类型参数在
关键字typename 或 class 之后指定。
类型转换(type transformation) 由标准
库定义的类模板，可将给定的模板类型参
数转换为一个相关类型。
可变参数模板(variadic template) 接受
可变数目模板实参的模板。模板参数包用
省略号指定(如 class...、typename...或
type-name...)
631

Page 658

Page 659
第IV部分
高级主题
内容
第17章
第18章
第19章
标准库特殊设施，
用于大型程序的工具，
特殊工具与技术。。。
635
683
725
第IV部分将介绍C++和标准库的一些附加特性，虽然这些特性在特定的情况下很有
用，但并非每个C++程序员都需要它们。这些特性分为两类：一类对于求解大规模的问题
很有用；另一类适用于特殊问题而非通用问题。针对特殊问题的特性既有属于C++语言的
（将在第19章介绍），也有属于标准库的（将在第17章进行介绍）。
在第17章中我们介绍四个具有特殊目的的标准库设施：bitset类和三个新标准库
设施（tuple、正则表达式和随机数）。我们还将介绍IO库中某些不常用的部分。
第18章介绍异常处理、命名空间和多重继承。这些特性在设计大序时是最有用的。
即使是一个程序员就能编写的足够简单的程序，也能从异常处理机制受益，这也是为
什么我们在第5章介绍了异常处理的基本知识的原因。但是，对于需要大型团队才能完成
的程序设计问题，运行时错误处理才显得更为重要也更难于管理。在第18章中，我们会
额外介绍一些有用的异常处理设施。我们还将详细讨论异常是如何处理的，并展示如何定
义和使用自己的异常类。这一章还会介绍新标准中异常处理方面的改进-如何指出一个
特定函数不会抛出异常。
大型应用程序通常会使用来自多个提供商的代码。如果提供商不得不将他们定义的名
字放置在单一的命名空间中，那么将多个独立开发的库组合起来是很困难的（如果能组合
的话）。独立开发的库几乎必然会使用与其他库相同的名字；对于某个库中定义的名字，
如果另一个库中使用了相同的名字，就会引起冲突。为了避免名字冲突，我们可以在一个
namespace 中定义名字。
715
716
