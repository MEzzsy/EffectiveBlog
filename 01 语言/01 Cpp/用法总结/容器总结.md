# 概述

![12](assets/12.jpg)

# vector

初始化

```
vector<int> v1 (10) ;	// v1有10个元素，每个的值都是0
vector<int> v2{10} ;	// v2有1个元素，该元素的值是10
vector<int> v3(10，1) ;	// v3有10个元素，每个的值都是1
vector<int> v4{10，1};	//v4有2个元素，值分别是10和1
```

>   开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。
>
>   特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。

## 改变容器大小

![16](assets/16.jpg)

## 管理容量的成员函数

![17](assets/17.jpg)

reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。

如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

这样，调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque，vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

## reserve和resize的区别

resize：如果容量增大，capacity和size都会跟着增大。resize是添加元素。如果容量减少，capacity不会变化，size会减少。

reserve：如果容量增大，capacity会增大，size不变，reserve不会添加元素。如果容量减少，都不会发生变化。

```cpp
void testVectorResizeAndReserve() {
  {
    std::vector<int> v;
    v.resize(10, 1);
    NDK_LOG("resize: capacity=%d size=%d", v.capacity(), v.size());
    // 容量减小
    v.resize(5, 2);
    NDK_LOG("resize: capacity=%d size=%d", v.capacity(), v.size());
  }
  {
    std::vector<int> v;
    v.reserve(10);
    NDK_LOG("reserve: capacity=%d size=%d", v.capacity(), v.size());
    // 容量减小
    v.reserve(5);
    NDK_LOG("reserve: capacity=%d size=%d", v.capacity(), v.size());
  }
}
```

```
resize: capacity=10 size=10
resize: capacity=10 size=5
reserve: capacity=10 size=0
reserve: capacity=10 size=0
```



# 迭代器

和指针不一样的是， 获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员。

编译器决定b和e的类型。一般来说，我们不清楚(不在意)迭代器准确的类型到底是什么。

# swap操作

除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在**常数时间**内完成。

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。
例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。

与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

# 顺序容器操作

## 访问元素

![13](assets/13.jpg)

### 访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：

![14](assets/14.jpg)

如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

### 下标操作和安全的随机访问

如果我们希望确保下标是合法的，可以使用at成员函数。

## 删除元素

![15](assets/15.jpg)

## 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题

在向容器添加元素后：

-   如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器､指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
-   对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
-   对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后：

-   对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
-   对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
-   对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。使用失效的迭代器、指针或引用是严重的运行时错误。

# 字符串

## 修改操作

![18](assets/18.jpg)

## 搜索操作

![19](assets/19.jpg)

## 数值转换

![20](assets/20.jpg)

# 泛型算法

## 概述

用户可能还希望做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法，大多数算法都定义在头文件algorithm中。

## 初识泛型算法

### 写容器元素的算法

#### 算法不检查写操作

可以用fill_n将一个新值赋予vector中的元素：

```cpp
vector<int> vec;	// 空vector
// 使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0);	// 将所有元素重置为0
```

函数fill_n假定写入指定个元素是安全的。即，如下形式的调用

```
fill_n(dest, n, val);
```

fill_n假定dest指向一个元素，而从dest开始的序列至少包含n个元素。

一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）。

#### 介绍back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。为了展示如何用算法向容器写入数据，我们现在将使用back_inserter，它是定义在头文件iterator
中的一个函数。

```cpp
{
  // 引入头文件#include "iterator"
  std::vector<string> vec;    // 空vector
  fill_n(std::back_inserter(vec), 5, "1");    // 将所有元素重置为0

  string log;
  // #include "numeric"
  // // 初始值不能写""，因为这是const char *，const char *不支持+法
  log = std::accumulate(vec.cbegin(), vec.cend(), log);
  NDK_LOG("log=%s", log.data());
}
```

## 定制操作

### lambda捕获和返回

#### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。

```cpp
void testLambda() {
  int val = 123;
  NDK_LOG("val p=%p", &val);
  auto lambda1 = [=]() {
    NDK_LOG("lambda1 p=%p", &val);
  };
  lambda1();
  auto lambda2 = [&]() {
    NDK_LOG("lambda2 p=%p", &val);
  };
  lambda2();
}
```

```
val p=0x7ff7b463b63c
lambda1 p=0x7ff7b463b638
lambda2 p=0x7ff7b463b63c
```

lambda捕获列表

![21](assets/21.jpg)

#### 可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。

```cpp
  {
    int val = 123;
    // 编译错误
//    auto lambda1 = [val]() {
//      return ++val;
//    };

    auto lambda2 = [val]() mutable {
      return ++val;
    };
    int v = lambda2();
    NDK_LOG("lambda2 v=%d", v);
  }
```

#### 指定lambda返回类型

当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型

```cpp
{
  auto abs = [](int i) -> int {
    if (i < 0) return -i; else return i;
  };
  int val = abs(-100);
}
```

### 参数绑定

如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表
达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。**如果lambda的捕获列表为空，通常可以用函数来代替它。**

但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。可以使用bind标准库函数，它定义在头文件functional中。调用bind的一般形式为：

![22](assets/22.jpg)

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。

```cpp
int functionTestBind(int a, int b) {
  return a + b;
}

void testBind() {
  {
    int a = 10;
    auto add = [a](int num) {
      return a + num;
    };
    int b = add(20);
    NDK_LOG("testBind %d", b);
  }
  {
    int a = 10;
    // #include "functional"
    auto add = std::bind(functionTestBind, std::placeholders::_1, a);
    int b = add(20);
    NDK_LOG("testBind %d", b);
  }
}
```

#### bind的参数

更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。

```cpp
void functionTestBind2(int a, int b, int c, int d) {
  NDK_LOG("functionTestBind2 a=%d b=%d c=%d d=%d", a, b, c, d);
}

{
  auto fun = std::bind(functionTestBind2, 1, std::placeholders::_2, 3, std::placeholders::_1);
  fun(2, 4);
}
```

## 再探迭代器

### 反向迭代器

#### 反向迭代器和其他迭代器间的关系

```cpp
void testIterator() {
  string word = "abc,defg,hij";
  // 找第一个单词
  string first(word.cbegin(), std::find(word.cbegin(), word.cend(), ','));
  NDK_LOG("testIterator first=%s", first.data());

  // 找最后一个单词
  auto it = std::find(word.crbegin(), word.crend(), ',');
  // 因为反向迭代器，所以单词是倒着打的
  string last(word.crbegin(), it);
  NDK_LOG("testIterator last=%s", last.data());
  // 需要用base函数来恢复
  last = string(it.base(), word.cend());
  NDK_LOG("testIterator last=%s", last.data());
}
```

```
testIterator first=abc
testIterator last=jih
testIterator last=hij
```

![23](assets/23.jpg)



# 10。5泛型算法结构

任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只
要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些
算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分
为5个迭代器类别（iteratorcategory），如表10。5所示。每个算法都会对它的每个迭代器
参数指明须提供哪类迭代器。
输入迭代器
输出迭代器
前向迭代器
双向迭代器
随机访问迭代器
表10。5：迭代器类别
只读，不写；单遍扫描，只能递增
只写，不读；单遍扫描，只能递增
可读写；多遍扫描，只能递增
可读写；多遍扫描，可递增递减
可读写，多遍扫描，支持全部迭代器运算
第二种算法分类的方式（如我们在本章开始所做的）是按照是否读、写或是重排序列
中的元素来分类。附录A按这种分类方法列出了所有算法。
算法还共享一组参数传递规范和一组命名规范，我们在介绍迭代器类别之后将介绍这
些内容。
10。5。15类迭代器
类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只
有特定类别的迭代器才支持。例如，ostream_iterator只支持递增、解引用和赋值。
vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算术运算。
迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代
365
410

Page392
366
411
器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。
C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在
一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace
函数需要一对迭代器，至少是前向迭代器。类似的，replace_copy的前两个迭代器参
数也要求至少是前向迭代器。其第三个迭代器表示目的位置，必须至少是输出迭代器。其
他的例子类似。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法
传递一个能力更差的迭代器会产生错误。
WARNING
第10章泛型算法
对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告
或提示。
迭代器类别
输入迭代器（inputiterator）：可以读取序列中的元素。一个输入迭代器必须支持
•用于比较两个迭代器的相等和不相等运算符（==､!=）
●用于推进迭代器的前置和后置递增运算（++）
•用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧
•箭头运算符（->），等价于（*it）。member，即，解引用迭代器，并提取对象的成
员
输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能
导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下
来并用来访问元素｡因此，输入迭代器只能用于单遍扫描算法｡算法find和accumulate
要求输入迭代器；而istream_iterator是一种输入迭代器。
输出迭代器（outputiterator）：可以看作输入迭代器功能上的补集——只写而不读元素。输
出迭代器必须支持
用于推进迭代器的前置和后置递增运算（++）
●
解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器
赋值，就是将值写入它所指向的元素）
我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算
法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输
出迭代器。ostream_iterator类型也是输出迭代器。
。
前向迭代器（forwarditerator）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。
前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我
们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法
replace要求前向迭代器，forward_list上的迭代器是前向迭代器。
412双向迭代器（bidirectionaliterator）：可以正向/反向读写序列中的元素。除了支持所有前向
迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法reverse要求
双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代
現
随机访问迭代器（random-accessiterator）：提供在常量时间内访问序列中任意元素的能力。
此类迭代器支持双向迭代器的所有功能，此外还支持表3。7（第99页）中的操作：

Page393
10。5泛型算法结构
●用于比较两个迭代器相对位置的关系运算符（<、<=､>和>=）
•迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前
进（或后退）给定整数个元素后的位置
●用于两个迭代器上的减法运算符（-），得到两个迭代器的距离
•下标运算符（iter[n]），与*（iter[n]）等价
算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随
机访问迭代器，用于访问内置数组元素的指针也是。
10。5。1节练习
练习10。38：列出5个迭代器类别，以及每类迭代器所支持的操作。
练习10。39：list上的迭代器属于哪类?vector呢?
练习10。40：你认为copy要求哪类迭代器?reverse和unique呢?
10。5。2算法形参模式
在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有
帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具
有如下4种形式之一：
alg（beg，end，otherargs）；
alg（beg，end，dest，otherargs）；
alg（beg，end，beg2，otherargs）；
alg（beg，end，beg2，end2，otherargs）；
-dest、
其中alg是算法的名字，beg和end表示算法所操作的输入范围。几乎所有算法都接受一
个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种
beg2和end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承413
担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非
迭代器的特定参数。
接受单个目标迭代器的算法
dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定（assume）；按其
需要写入数据，不管写入多少个元素都是安全的。
向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。
367
WARNING
如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的
元素内。更常见的情况是，dest被绑定到一个插入迭代器（参见10。4。1节，第358页）
或是一个ostream_iterator（参见10。4。2节，第359页）。插入迭代器会将新元素添加
到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，
同样不管要写入多少个元素都没有问题。

Page394
368
414
接受第二个输入序列的算法
接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。
这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。
如果一个算法接受beg2和end2，这两个迭代器表示第二个范围。这类算法接受两
个完整指定的范围：[beg，end）表示的范围和[beg2end2）表示的第二个范围。
只接受单独的beg2（不接受end2）的算法将beg2作为第二个输入范围中的首元素。
此范围的结束位置未指定，这些算法假定从beg2开始的范围与beg和end所表示的范
围至少一样大。
WARNING
第10章泛型算法
接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围
至少一样大。
10。5。3算法命名规范
除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个
操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位
置等问题。
一些算法使用重载形式传递一个谓词
接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都
是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额
外谓词参数，来代替<或==：
unique（beg，end）；
//使用运算符比较元素

unique（beg，end，comp）；//使用comp比较元素
==

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==
运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的
函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义（参见6。4节，第208页）。
find（beg，end，val）；
find_if（beg，end，pred）；
_if版本的算法
接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个
谓词（参见10。3。1节，第344页）代替元素值。接受谓词参数的算法都有附加的_if前缀：
//查找输入范围中val第一次出现的位置
//查找第一个令pred为真的元素
这两个算法都在输入范围中查找特定元素第一次出现的位置｡算法find查找一个指定值；
算法find_if查找使得pred返回非零值的元素。
这两个算法提供了命名上差异的版本，而非重载版本，因为两个版本的算法都接受相
同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准
库选择提供不同名字的版本而不是重载。
区分拷贝元素的版本和不拷贝的版本
默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提
供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的

Page395
10。6特定容器算法
算法都在名字后面附加一个_copy（参见10。2。2节，第341页）：
reverse（beg，end）；
//反转输入范围中元素的顺序
reverse_copy（beg，end，dest）；//将元素按逆序拷贝到dest
一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：
//从v1中删除奇数元素
remove_if（v1。begin（），vl。end（），
//将偶数元素从v1拷贝到v2；v1不变
[]（inti）{returni%2；}）；
remove_copy_if（v1。begin（），v1。end（），back_inserter（v2），
[]（inti）{returni%2；}）；
两个算法都调用了lambda（参见10。3。2节，第346页）来确定元素是否为奇数。在第一个
调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（亦即偶数）
元素从输入范围拷贝到v2中。
10。5。3节练习
练习10。41：仅根据算法和参数的名字，描述下面每个标准库算法执行什么操作：
replace（beg，end，old_val，new_val）；
replace_if（beg，end，pred，new_val）；
replace_copy（beg，end，dest，old_val，new_val）；
replace_copy_if（beg，end，dest，pred，new_val）；
10。6特定容器算法
与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算
法，如表10。6所示。特别是，它们定义了独有的sort、merge、remove、reverse和
unique｡通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，
因为这两个类型分别提供双向迭代器和前向迭代器。
链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换
输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速
“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。
Best
对于list和forward_list，应该优先使用成员函数版本的算法而不是通用
Practices算法。
表10。6：list和forward_list成员函数版本的算法
这些操作都返回void
lst。merge（1st2）
1st。merge（1st2，comp）。
lst。remove（val）
lst。remove_if（pred）
lst。reverse（）
将来自1st2的元素合并入lstolst和1st2都必须是有序的。
元素将从1st2中删除。在合并之后，1st2变为空。第一个版
本使用<运算符：第二个版本使用给定的比较操作
调用erase删除掉与给定值相等（==）或令一元谓词为真的每
个元素
反转1st中元素的顺序
369
415

Page396
370
416
lst。sort（）
lst。sort（comp）
lst。unique（）
lst。unique（pred）
使用<或给定比较操作排序元素
（p，1st2，p2）
第10章泛型算法
splice成员
链表类型还定义了splice算法，其描述见表10。7。此算法是链表数据结构所特有的，
因此不需要通用版本。
lst。splice（args）或flst。splice_after（args）
（p，1st2）
（p，1st2，b，e）
调用erase删除同一个值的连续拷贝。第一个版本使用==；第
二个版本使用给定的二元谓词
表10。7：list和forward_list的splice成员函数的参数
续表
p是一个指向1st中元素的迭代器，或一个指向flst首前位
置的迭代器。函数将1st2的所有元素移动到1st中p之前的
位置或是flst中p之后的位置。将元素从1st2中删除。lst2
的类型必须与1st或flst相同，且不能是同一个链表
p2是一个指向1st2中位置的有效的迭代器。将p2指向的元
素移动到1st中，或将p2之后的元素移动到flst中。1st2
可以是与1st或flst相同的链表
b和e必须表示1st2中的合法范围。将给定范围中的元素从
1st2移动到1st或flst。lst2与1st（或flst）可以是相
同的链表，但p不能指向给定范围中元素
链表特有的操作会改变容器
多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版
本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove的链表版本会
删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。
merge
类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列
写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本
会销毁
给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在
merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。
10。6节练习
练习10。42：使用list代替vector重新实现10。2。3节（第343页）中的去除重复单
词的程序。

Page397
小结
小结
标准库定义了大约100个类型无关的对序列进行操作的算法。序列可以是标准库容器
类型中的元素、一个内置数组或者是（例如）通过读写一个流来生成的。算法通过在迭代
器上进行操作来实现类型无关。多数算法接受的前两个参数是一对迭代器，表示一个元素
范围。额外的迭代器参数可能包括一个表示目的位置的输出迭代器，或是表示第二个输入
范围的另一个或另一对迭代器。
根据支持的操作不同，迭代器可分为五类：输入、输出、前向、双向以及随机访问迭
代器。如果一个迭代器支持某个迭代器类别所要求的操作，则属于该类别。
如同迭代器根据操作分类一样，传递给算法的迭代器参数也按照所要求的操作进行分
类。仅读取序列的算法只要求输入迭代器操作。写入数据到目的位置迭代器的算法只要求
输出迭代器操作，依此类推。
算法从不直接改变它们所操作的序列的大小。它们会将元素从一个位置拷贝到另一个
位置，但不会直接添加或删除元素。
（371
虽然算法不能向序列添加元素，但插入迭代器可以做到。一个插入迭代器被绑定到一
个容器上。当我们将一个容器元素类型的值赋予一个插入迭代器时，迭代器会将该值添加
到容器中。
148007
容器forward_list和list对一些通用算法定义了自己特有的版本。与通用算法
不同，这些链表特有版本会修改给定的链表。
术语表
back_inserter这是一个迭代器适配器，它
接受一个指向容器的引用，生成一个插入
迭代器，该插入迭代器用push_back向
指定容器添加元素。
双向迭代器（bidirectionaliterator）支持
前向迭代器的所有操作，还具有用--在序
列中反向移动的能力。
二元谓词（binarypredicate）接受两个参
数的谓词。
bind标准库函数，将一个或多个参数绑定
到一个可调用表达式。bind定义在头文件
functional中。
可调用对象（callableobject）可以出现
在调用运算符左边的对象。函数指针、
lambda以及重载了函数调用运算符的类的
对象都是可调用对象。
捕获列表（capturelist）lambda表达式的
作
一部分，指出lambda表达式可以访问所在
上下文中哪些变量。
cref标准库函数，返回一个可拷贝的对象，
其中保存了一个指向不可拷贝类型的
const对象的引用。
前向迭代器（forwarditerator）可以读写
元素，但不必支持--的迭代器。
front_inserter迭代器适配器，给定一个容
器，生成一个用push_front向容器开始
位置添加元素的插入迭代器。
泛型算法（genericalgorithm）类型无关
的算法。
输入迭代器（inputiterator）可以读但不
能写序列中元素的迭代器。
插入迭代器（insertiterator）迭代器适配
器，生成一个迭代器，该迭代器使用容器
操作向给定容器添加元素。
417
418

Page398
372
插入器（inserter）迭代器适配器，接受
一个迭代器和一个指向容器的引用，生成
一个插入迭代器，该插入迭代器用insert
在给定迭代器指向的元素之前的位置添加
元素。
istream_iterator读取输入流的流迭代
現
命。
迭代器类别（iteratorcategory）根据所支
持的操作对迭代器进行的分类组织。迭代
器类别形成一个层次，其中更强大的类别
支持更弱类别的所有操作。算法使用迭代
器类别来指出迭代器参数必须支持哪些操
只要迭代器达到所要求的最小类别，
它就可以用于算法。例如，一些算法只要
求输入迭代器。这类算法可处理除只满足
输出迭代器要求的迭代器之外的任何迭代
器。而要求随机访问迭代器的算法只能用
于支持随机访问操作的迭代器。
lambda表达式（lambdaexpression）可
调用的代码单元。一个lambda类似一个未
命名的内联函数。一个lambda以一个捕获
列表开始，此列表允许lambda访问所在函
数中的变量。类似函数，lambda有一个（可
能为空的）参数列表、一个返回类型和一
个函数体。lambda可以忽略返回类型。如
果函数体是一个单一的return语句，返
回类型就从返回对象的类型推断。否则，
忽略的返回类型默认定为void。
第10章泛型算法
移动迭代器（moveiterator）迭代器适配
器，生成一个迭代器，该迭代器移动而不
是拷贝元素。移动迭代器将在第13章中进
行介绍。
ostream_iterator写输出流的迭代器。
输出迭代器（outputiterator）可以写元素，
但不必具有读元素能力的迭代器。
谓词（predicate）返回可以转换为bool
类型的值的函数。泛型算法通常用来检测
元素。标准库使用的谓词是一元（接受一
个参数）或二元（接受两个参数）的。
随机访问迭代器（random-accessiterator）
支持双向迭代器的所有操作再加上比较迭
代器值的关系运算符、下标运算符和迭代
器上的算术运算，因此支持随机访问元素。
ref标准库函数，从一个指向不能拷贝的类
型的对象的引用生成一个可拷贝的对象。
反向迭代器（reverseiterator）在序列中
反向移动的迭代器。这些迭代器交换了++
和——的含义。
流迭代器（streamiterator）可以绑定到
一个流的迭代器。
一元谓词（unarypredicate）接受一个参
数的谓词。
