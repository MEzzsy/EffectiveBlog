# 概述

![12](assets/12.jpg)

# vector

初始化

```
vector<int> v1 (10) ;	// v1有10个元素，每个的值都是0
vector<int> v2{10} ;	// v2有1个元素，该元素的值是10
vector<int> v3(10，1) ;	// v3有10个元素，每个的值都是1
vector<int> v4{10，1};	//v4有2个元素，值分别是10和1
```

>   开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。
>
>   特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。

## 改变容器大小

![16](assets/16.jpg)

## 管理容量的成员函数

![17](assets/17.jpg)

reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。

如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

这样，调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque，vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

## reserve和resize的区别

resize：如果容量增大，capacity和size都会跟着增大。resize是添加元素。如果容量减少，capacity不会变化，size会减少。

reserve：如果容量增大，capacity会增大，size不变，reserve不会添加元素。如果容量减少，都不会发生变化。

```cpp
void testVectorResizeAndReserve() {
  {
    std::vector<int> v;
    v.resize(10, 1);
    NDK_LOG("resize: capacity=%d size=%d", v.capacity(), v.size());
    // 容量减小
    v.resize(5, 2);
    NDK_LOG("resize: capacity=%d size=%d", v.capacity(), v.size());
  }
  {
    std::vector<int> v;
    v.reserve(10);
    NDK_LOG("reserve: capacity=%d size=%d", v.capacity(), v.size());
    // 容量减小
    v.reserve(5);
    NDK_LOG("reserve: capacity=%d size=%d", v.capacity(), v.size());
  }
}
```

```
resize: capacity=10 size=10
resize: capacity=10 size=5
reserve: capacity=10 size=0
reserve: capacity=10 size=0
```



# 迭代器

和指针不一样的是， 获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员。

编译器决定b和e的类型。一般来说，我们不清楚(不在意)迭代器准确的类型到底是什么。

# swap操作

除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在**常数时间**内完成。

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。
例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。

与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

# 顺序容器操作

## 访问元素

![13](assets/13.jpg)

### 访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：

![14](assets/14.jpg)

如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

### 下标操作和安全的随机访问

如果我们希望确保下标是合法的，可以使用at成员函数。

## 删除元素

![15](assets/15.jpg)

## 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题

在向容器添加元素后：

-   如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器､指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
-   对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
-   对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后：

-   对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
-   对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
-   对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。使用失效的迭代器、指针或引用是严重的运行时错误。

# 字符串

## 修改操作

![18](assets/18.jpg)

## 搜索操作

![19](assets/19.jpg)

## 数值转换

![20](assets/20.jpg)

# 泛型算法

## 概述

用户可能还希望做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法，大多数算法都定义在头文件algorithm中。

## 初识泛型算法

### 写容器元素的算法

#### 算法不检查写操作

可以用fill_n将一个新值赋予vector中的元素：

```cpp
vector<int> vec;	// 空vector
// 使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0);	// 将所有元素重置为0
```

函数fill_n假定写入指定个元素是安全的。即，如下形式的调用

```
fill_n(dest, n, val);
```

fill_n假定dest指向一个元素，而从dest开始的序列至少包含n个元素。

一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）。

#### 介绍back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。为了展示如何用算法向容器写入数据，我们现在将使用back_inserter，它是定义在头文件iterator
中的一个函数。

```cpp
{
  // 引入头文件#include "iterator"
  std::vector<string> vec;    // 空vector
  fill_n(std::back_inserter(vec), 5, "1");    // 将所有元素重置为0

  string log;
  // #include "numeric"
  // // 初始值不能写""，因为这是const char *，const char *不支持+法
  log = std::accumulate(vec.cbegin(), vec.cend(), log);
  NDK_LOG("log=%s", log.data());
}
```

## 定制操作

### lambda捕获和返回

#### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。

```cpp
void testLambda() {
  int val = 123;
  NDK_LOG("val p=%p", &val);
  auto lambda1 = [=]() {
    NDK_LOG("lambda1 p=%p", &val);
  };
  lambda1();
  auto lambda2 = [&]() {
    NDK_LOG("lambda2 p=%p", &val);
  };
  lambda2();
}
```

```
val p=0x7ff7b463b63c
lambda1 p=0x7ff7b463b638
lambda2 p=0x7ff7b463b63c
```

lambda捕获列表

![21](assets/21.jpg)

#### 可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。

```cpp
  {
    int val = 123;
    // 编译错误
//    auto lambda1 = [val]() {
//      return ++val;
//    };

    auto lambda2 = [val]() mutable {
      return ++val;
    };
    int v = lambda2();
    NDK_LOG("lambda2 v=%d", v);
  }
```

#### 指定lambda返回类型

当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型

```cpp
{
  auto abs = [](int i) -> int {
    if (i < 0) return -i; else return i;
  };
  int val = abs(-100);
}
```

### 参数绑定

如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表
达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。**如果lambda的捕获列表为空，通常可以用函数来代替它。**

但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。可以使用bind标准库函数，它定义在头文件functional中。调用bind的一般形式为：

![22](assets/22.jpg)

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。

```cpp
int functionTestBind(int a, int b) {
  return a + b;
}

void testBind() {
  {
    int a = 10;
    auto add = [a](int num) {
      return a + num;
    };
    int b = add(20);
    NDK_LOG("testBind %d", b);
  }
  {
    int a = 10;
    // #include "functional"
    auto add = std::bind(functionTestBind, std::placeholders::_1, a);
    int b = add(20);
    NDK_LOG("testBind %d", b);
  }
}
```

#### bind的参数

更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。

```cpp
void functionTestBind2(int a, int b, int c, int d) {
  NDK_LOG("functionTestBind2 a=%d b=%d c=%d d=%d", a, b, c, d);
}

{
  auto fun = std::bind(functionTestBind2, 1, std::placeholders::_2, 3, std::placeholders::_1);
  fun(2, 4);
}
```

## 再探迭代器

### 反向迭代器

#### 反向迭代器和其他迭代器间的关系

```cpp
void testIterator() {
  string word = "abc,defg,hij";
  // 找第一个单词
  string first(word.cbegin(), std::find(word.cbegin(), word.cend(), ','));
  NDK_LOG("testIterator first=%s", first.data());

  // 找最后一个单词
  auto it = std::find(word.crbegin(), word.crend(), ',');
  // 因为反向迭代器，所以单词是倒着打的
  string last(word.crbegin(), it);
  NDK_LOG("testIterator last=%s", last.data());
  // 需要用base函数来恢复
  last = string(it.base(), word.cend());
  NDK_LOG("testIterator last=%s", last.data());
}
```

```
testIterator first=abc
testIterator last=jih
testIterator last=hij
```

![23](assets/23.jpg)

# 关联容器(map等)

![24](assets/24.jpg)

## 关联容器概述

无序容器还提供一些用来调整哈希性能的操作，关联容器的迭代器都是双向的。

### 关键字类型的要求

#### 有序容器的关键字类型

可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“**小于等于**”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：

-   两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1。
-   如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。
-   如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。

#### 使用关键字类型的比较函数

```cpp
class C {
 public:
  C(int val);
 public:
  int val = 0;
};

static bool compareC(const C &c1, const C &c2) {
  NDK_LOG("compareC");
  return c1.val < c2.val;
}

void testMap() {
  C c1(1);
  C c2(2);
  std::map<C, int, decltype(compareC) *> m(compareC);

  m[c1] = 10;
  m[c2] = 20;
}
```

使用decltype来指出自定义操作的类型。记住，当用decltype来获得一个函数指针类型时，必须加上一个*来指出我们要使用一个给定函数类型的指针。

## 关联容器操作

![25](assets/25.jpg)

### 关联容器迭代器

当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值。

>   必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。

### 添加元素

![26](assets/26.png)

### 删除元素

![27](assets/27.jpg)

### map的下标操作

map和unordered_map容器提供了下标运算符和一个对应的at函数（参见9。3。2
节，第311页），如表11。6所示。set类型不支持下标，因为set中没有与关键字相关联
的“值”。元素本身就是关键字，因此“获取与一个关键字相关联的值”的操作就没有意
义了。我们不能对一个multimap或一个unordered_multimap进行下标操作，因为
这些容器中可能有多个值与一个关键字相关联。
将会执行如下操作：
表11。5：从关联容器删除元素
从c中删除每个关键字为k的元素。返回一个size_type值，指
出删除的元素的数量
类似我们用过的其他下标运算符，map下标运算符接受一个索引（即，一个关键字），
获取与此关键字相关联的值。但是，与其他下标运算符不同的是，如果关键字并不在map
中，会为它创建一个元素并插入到map中，关联值将进行值初始化（参见3。3。1节，第88页）。
例如，如果我们编写如下代码
map<string，size_t>word_count；//emptymap
//插入一个关键字为Anna的元素，关联值进行值初始化；然后将1賦予它
word_count["Anna"]=1；
从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，
不能等于c。end（）。返回一个指向p之后元素的迭代器，若p指
向c中的尾元素，则返回c。end（）
删除迭代器对b和e所表示的范围中的元素。返回e
在word_count中搜索关键字为Anna的元素，未找到。
•将一个新的关键字-值对插入到word_count中。关键字是一个conststring，
保存Anna。值进行值初始化，在本例中意味着值为0。
●提取出新插入的元素，并将值1赋予它。
由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。
c[k]
对一个map使用下标操作，其行为与数组或vector上的下标操作很不相同：
Note使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到
map中。
c。at（k）
nap和unol
unordered_map的下标操作
表11。6：map
返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，
对其进行值初始化
访问关键字为k的元素，带参数检查；若k不在c中，抛出一个
out_of_range异常（参见5。6节，第173页）
使用下标操作的返回值
map的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。通
387
436

Page414
388
常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但对map
则不然；当对一个map进行下标操作时，会获得一个mapped_type对象；但当解引用
一个map迭代器时，会得到一个value_type对象（参见11。3节，第381页）。
与其他下标运算符相同的是，map的下标运算符返回一个左值（参见4。1。1节，第121
页）。由于返回的是一个左值，所以我们既可以读也可以写元素：
cout<<word_count["Anna"]；
++word_count["Anna"]；
cout<<wordcount["Anna"]；
Note
//用Anna作为下标提取元素；会打印出1
//提取元素，将其增1
//提取元素并打印它；会打印出2
第11章关联容器
与vector与string不同，map的下标运算符返回的类型与解引用map迭
代器得到的类型不同。
如果关键字还未在map中，下标运算符会添加一个新元素，这一特性允许我们编写
出异常简洁的程序，例如单词计数程序中的循环（参见11。1节，第375页）。另一方面，
有时只是想知道一个元素是否已在map中，但在不存在时并不想添加元素。在这种情况
下，就不能使用下标运算符。
11。3。4节练习
练习11。24：下面的程序完成什么功能?
map<int，int>m；
m[0]=1；
练习11。25：对比下面程序与上一题程序
vector<int>v；
v[0]1；
练习11。26：可以用什么类型来对一个map进行下标操作?下标运算符返回的类型是什
么?请给出一个具体例子——即，定义一个map，然后写出一个可以用来对map进行下
标操作的类型以及下标运算符将会返回的类型。
11。3。5访问元素
关联容器提供多种查找一个指定元素的方法，如表11。7所示。应该使用哪个操作依赖
于我们要解决什么问题。如果我们所关心的只不过是一个特定元素是否已在容器中，可能
find是最佳选择。对于不允许重复关键字的容器，可能使用find还是count没什么区
别。但对于允许重复关键字的容器，count还会做更多的工作：如果元素在容器中，它还
437会统计有多少个元素有相同的关键字。如果不需要计数，最好使用find：
set<int>iset={0，1，2，3，4，5，6，7，8，9）；
iset。find（1）；
//返回一个迭代器，指向key==1的元素
iset。find（11）；//返回一个迭代器，其值等于iset。end（）
iset。count（1）；//返回1
iset。count（11）；//返回0
表11。7：在一个关联容器中查找元素的操作
lower_bound和upper_bound不适用于无序容器。
下标和at操作只适用于非const的map和unordered_map。

Page415
11。3关联容器操作
c。find（k）
c。count（k）
c。lowerbound（k）
c。upper_bound（k）
c。equal_range（k）
续表
返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，
则返回尾后迭代器
返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返
回值永远是0或1
返回一个迭代器，指向第一个关键字不小于k的元素
返回一个迭代器，指向第一个关键字大于k的元素
返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存
在，pair的两个成员均等于c。end（）
对map使用find代替下标操作
对map和unordered_map类型，下标运算符提供了最简单的提取元素的方法。但是，
如我们所见，使用下标操作有一个严重的副作用：如果关键字还未在map中，下标操作
会插入一个具有给定关键字的元素。这种行为是否正确完全依赖于我们的预期是什么。例
如，单词计数程序依赖于这样一个特性：使用一个不存在的关键字作为下标，会插入一个
新元素，其关键字为给定关键字，其值为0。也就是说，下标操作的行为符合我们的预期。
但有时，我们只是想知道一个给定关键字是否在map中，而不想改变map。这样就
不能使用下标运算符来检查一个元素是否存在，因为如果关键字不存在的话，下标运算符
会插入一个新元素。在这种情况下，应该使用find：
if（word_count。find（"foobar"）==wordcount。end（））
cout<<"foobarisnotinthemap"<<endl；
在multimap或multiset中查找元素
在一个不允许重复关键字的关联容器中查找一个元素是一件很简单的事情——元素
要么在容器中，要么不在。但对于允许重复关键字的容器来说，过程就更为复杂：在容器
中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素
具有给定关键字，则这些元素在容器中会相邻存储。
例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。438
可以用三种不同方法来解决这个问题。最直观的方法是使用find和count：
stringsearch_item（"AlaindeBotton"）；
autoentries=authors。count（searchitem）；
autoiter=authors。find（searchitem）；
//用一个循环查找此作者的所有著作
while（entries）{
Note
cout<<iter->second<<endl；
++iter；
--entries；
//要查找的作者
//元素的数量
//此作者的第一本书
//打印每个题目
//前进到下一本书
//记录已经打印了多少本书
}
首先调用count确定此作者共有多少本著作，并调用find获得一个迭代器，指向第一
个关键字为此作者的元素。for循环的迭代次数依赖于count的返回值。特别是，如果
count返回0，则循环一次也不执行。
389
当我们遍历一个multimap或multiset时，保证可以得到序列中所有具有
给定关键字的元素。

Page416
390
439
一种不同的，面向迭代器的解决方法
我们还可以用lower_bound和upper_bound来解决此问题。这两个操作都接受一
个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向
第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定
关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和
upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，
用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围（参见9。2。1
节，第296页），表示所有具有该关键字的元素的范围。
当然，这两个操作返回的迭代器可能是容器的尾后迭代器。如果我们查找的元素具有
容器中最大的关键字，则此关键字的upper_bound返回尾后迭代器｡如果关键字不存在，
且大于容器中任何关键字，则lower_bound返回的也是尾后迭代器。
Note
第11章关联容器
lowerbound返回的迭代器可能指向一个具有给定关键字的元素，但也可能
不指向。如果关键字不在容器中，则lower_bound会返回关键字的第一个安
全插入点——不影响容器中元素顺序的插入位置。
使用这两个操作，我们可以重写前面的程序：
//authors和search_item的定义，与前面的程序一样
//beg和end表示对应此作者的元素的范围
for（autobegauthors。lowerbound（searchitem），
end=authors。upper_bound（search_item）；
beg!=end；++beg）
cout<<beg->second<<endl；//打印每个题目
此程序与使用count和find的版本完成相同的工作，但更直接。对lowerbound的
调用将beg定位到第一个与search_item匹配的元素（如果存在的话）。如果容器中没
有这样的元素，beg将指向第一个关键字大于search_item的元素，有可能是尾后迭代
器。upper_bound调用将end指向最后一个匹配指定关键字的元素之后的元素。这两个
操作并不报告关键字是否存在，重要的是它们的返回值可作为一个迭代器范围（参见9。2。1
节，第296页）。
如果没有元素与给定关键字匹配，则lowerbound和upperbound会返回相等的
迭代器——都指向给定关键字的插入点，能保持容器中元素顺序的插入位置。
假定有多个元素与给定关键字匹配，beg将指向其中第一个元素。我们可以通过递增
beg来遍历这些元素。end中的迭代器会指出何时完成遍历——当beg等于end时，就
表明已经遍历了所有匹配给定关键字的元素了。
由于这两个迭代器构成一个范围，我们可以用一个for循环来遍历这个范围。循环
可能执行零次，如果存在给定作者的话，就会执行多次，打印出该作者的所有项。如果给
定作者不存在，beg和end相等，循环就一次也不会执行。否则，我们知道递增beg最
终会使它到达end，在此过程中我们就会打印出与此作者关联的每条记录。
如果lower_bound和upper_bound返回相同的迭代器，则给定关键字不在
Note容器中。
equal_range函数
解决此问题的最后一种方法是三种方法中最直接的：不必再调用upper_bound和

Page417
11。3关联容器操作
lower_bound，直接调用equal_range即可。此函数接受一个关键字，返回一个迭代
器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代
器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可
以插入的位置。
可以用equal_range来再次修改我们的程序：
//authors和search_item的定义，与前面的程序一样
//pos保存迭代器对，表示与关键字匹配的元素范围
for（autopos=authors。equal_range（search_item）；
pos。first!=pos。second；++pos。first）
cout<<pos。first->second<<endl；//打印每个题目
此程序本质上与前一个使用upper_bound和lower_bound的程序是一样的。不同之处
就是，没有用局部变量beg和end来保存元素范围，而是使用了equal_range返回的
pair。此pair的first成员保存的迭代器与lower_bound返回的迭代器是一样的，
second保存的迭代器与upper_bound的返回值是一样的。因此，在此程序中，
pos。first等价于beg，pos。second等价于end。
11。3。5节练习
练习11。27：对于什么问题你会使用count来解决?什么时候你又会选择find呢?
练习11。28：对一个string到int的vector的map，定义并初始化一个变量来保存
在其上调用find所返回的结果。
练习11。29：如果给定的关键字不在容器中，upper_bound、lower_bound和
equal_range分别会返回什么?
练习11。30：对于本节最后一个程序中的输出表达式，解释运算对象
pos。first->second的含义。
练习11。31：编写程序，定义一个作者及其作品的multimap。使用find在multimap
中查找一个元素并用erase删除它｡确保你的程序在元素不在map中时也能正常运行。
练习11。32：使用上一题定义的multimap编写一个程序，按字典序打印作者列表和他
们的作品。
11。3。6一个单词转换的map
我们将以一个程序结束本节的内容，它将展示map的创建、搜索以及遍历。这个程
序的功能是这样的：给定一个string，将它转换为另一个string。程序的输入是两个
文件。第一个文件保存的是一些规则，用来转换第二个文件中的文本。每条规则由两部分
组成：一个可能出现在输入文件中的单词和一个用来替换它的短语。表达的含义是，每当
第一个单词出现在输入中时，我们就将它替换为对应的短语。第二个输入文件包含要转换
的文本。
如果单词转换文件的内容如下所示：
brbberightback
kokay?
ywhy
rare
391
440
441

Page418
392
uyou
picpicture
thkthanks!
18rlater
我们希望转换的文本为
whereru
ydontusendmeapic
kthk18r
则程序应该生成这样的输出：
whereareyou
whydontyousendmeapicture
okay?thanks!later
单词转换程序
我们的程序将使用三个函数。函数word_transform管理整个过程。它接受两个
ifstream参数：第一个参数应绑定到单词转换文件，第二个参数应绑定到我们要转换的
文本文件。函数buildMap会读取转换规则文件，并创建一个map，用于保存每个单词
到其转换内容的映射。函数transform接受一个string，如果存在转换规则，返回转
换后的内容。
我们首先定义word_transform函数。最重要的部分是调用buildMap和
transform：
voidword_transform（ifstream&map_file，ifstream&input）
{
autotrans_map=buildMap（map_file）；//保存转换规则
stringtext；
while（getline（input，text））{
istringstreamstream（text）；
}
stringword；
boolfirstword=true；
while（stream>>word）{
第11章关联容器
if（firstword）
else
firstword=false；
}
cout<<endl；
//保存输入中的每一行
//读取一行输入
//读取每个单词
//控制是否打印空格
cout<<""；
//在单词间打印一个空格
//transform返回它的第一个参数或其转换之后的形式
cout<<transform（word，transmap）；//打印输出
//完成一行的转换
442函数首先调用buildMap来生成单词转换map，我们将它保存在trans_map中。函数的
剩余部分处理输入文件。while循环用getline一行一行地读取输入文件。这样做的目
的是使得输出中的换行位置能和输入文件中一样。为了从每行中获取单词，我们使用了一
个嵌套的while循环，它用一个istringstream（参见8。3节，第287页）来处理当
前行中的每个单词。
在输出过程中，内层while循环使用一个bool变量firstword来确定是否打印

Page419
11。3关联容器操作
一个空格。它通过调用transform来获得要打印的单词。transform的返回值或者是
word中原来的string，或者是trans_map中指出的对应的转换内容。
建立转换映射
函数buildMap读入给定文件，建立起转换映射。
map<string，string>buildMap（ifstream&map_file）
{
map<string，string>trans_map；//保存转换规则
stringkey；
//要转换的单词
stringvalue；//替换后的內容
//读取第一个单词存入key中，行中剩余内容存入value
while（map_file>>key&&getline（map_file，value））
if（value。size（）>1）//检查是否有转换规则
trans_map[key]value。substr（1）；//跳过前导空格
else
throwruntime_error（"norulefor"+key）；
returntrans_map；
map_file中的每一行对应一条规则。每条规则由一个单词和一个短语组成，短语可能包
含多个单词。我们用>>读取要转换的单词，存入key中，并调用getline读取这一行中
的剩余内容存入value。由于getline不会跳过前导空格（参见3。2。2节，第78页），
需要我们来跳过单词和它的转换内容之间的空格。在保存转换规则之前，检查是否获得了
一个以上的字符。如果是，调用substr（参见9。5。1节，第321页）来跳过分隔单词及
其转换短语之间的前导空格，并将得到的子字符串存入trans_map。
{
注意，我们使用下标运算符来添加关键字-值对。我们隐含地忽略了一个单词在转换
文件中出现多次的情况。如果真的有单词出现多次，循环会将最后一个对应短语存入
trans_map。当while循环结束后，trans_map中将保存着用来转换输入文本的规则。
生成转换文本
函数transform进行实际的转换工作。其参数是需要转换的string的引用和转换
规则map。如果给定string在map中，transform返回相应的短语。否则，transform
直接返回原string：
conststring&
transform（conststring&s，constmap<string，string>&m）
//实际的转换工作；此部分是程序的核心
automap_it=m。find（s）；
//如果单词在转换规则map中
if（map_it!=m。cend（））
else
returnmap_it->second；//使用替換短语
returns；
//否则返回原string
函数首先调用find来确定给定string是否在map中。如果存在，则find返回一个指
向对应元素的迭代器。否则，find返回尾后迭代器。如果元素存在，我们解引用迭代器，
获得一个保存关键字和值的pair（参见11。3节，第381页），然后返回成员second，即
393
443

Page420
394
C++
11
用来替代s的内容。
11。3。6节练习
练习11。33：实现你自己版本的单词转换程序。
练习11。34：如果你将transform函数中的find替换为下标运算符，会发生什么情
况?
练习11。35：在buildMap中，如果进行如下改写，会有什么效果?
trans_map[key]=value。substr（1）；
改为trans_map。insert（{key，value。substr（1）}）
练习11。36：我们的程序并没有检查输入文件的合法性。特别是，它假定转换规则文件
中的规则都是有意义的。如果文件中的某一行包含一个关键字、一个空格，然后就结束
了，会发生什么?预测程序的行为并进行验证，再与你的程序进行比较。
第11章关联容器
11。4无序容器
新标准定义了4个无序关联容器（unorderedassociativecontainer）。这些容器不是使用
比较运算符来组织元素，而是使用一个哈希函数（hashfunction）和关键字类型的==运算
符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应
用中，维护元素的序代价非常高昂，此时无序容器也很有用。
虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要
进行一些性能测试和调优工作｡因此，使用无序容器通常更为简单（通常也会有更好的性能）。
4440如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解
决，就可以使用无序容器。
Tip
使用无序容器
除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert
等）。这意味着我们曾用于map和set的操作也能用于unordered_map和
unordered_set。类似的，无序容器也有允许重复关键字的版本。
因此，通常可以用一个无序容器替换对应的有序容器，反之亦然。但是，由于元素未按
顺序存储，一个使用无序容器的程序的输出（通常）会与使用有序容器的版本不同。
例如，可以用unordered_map重写最初的单词计数程序（参见11。1节，第375页）：
//统计出现次数，但单词不会按字典序排列
unordered_map<string，size_t>word_count；
stringword；
while（cin>>word）
++word_count[word]；
//提取并递增word的计数器
for（constauto&w：word_count）//对map中的每个元素
//打印结果
cout<<w。first<<
"1
11
occurs
<<（（w。second>1）?
<<w。second
"times"："1time"）<<endl；

Page421
11。4无序容器
此程序与原程序的唯一区别是word_count的类型。如果在相同的输入数据上运行此版
本，会得到这样的输出：
containers。occurs1time
useoccurs1time
canoccurs1time
examplesoccurs1time
对于每个单词，我们将得到相同的计数结果。但单词不太可能按字典序输出。
管理桶
无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈
希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜
索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重
复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖
于哈希函数的质量和桶的数量和大小。
对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将445
每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。
当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素
的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么
查找一个特定元素就需要大量比较操作。
无序容器提供了一组管理桶的函数，如表11。8所示。这些成员函数允许我们查询容器
的状态以及在必要时强制容器进行重组。
桶接口
c。bucket_count（）
c。max_bucket_count（）
c。bucketsize（n）
c。bucket（k）
桶迭代
localiterator
constlocaliterator
c。begin（n），c。end（n）
c。cbegin（n），c。cend（n）
哈希策略
c。loadfactor（）
c。max_load_factor（）
c。rehash（n）
c。reserve（n）
表11。8：无序容器管理操作
正在使用的桶的数目
容器能容纳的最多的桶的数量
第n个桶中有多少个元素
关键字为k的元素在哪个桶中
可以用来访问桶中元素的迭代器类型
桶迭代器的const版本
桶n的首元素迭代器和尾后迭代器
与前两个函数类似，但返回constlocal_iterator
每个桶的平均元素数量，返回float值
c试图维护的平均桶大小，返回float值。c会在需要时添
加新的桶，以使得load_factor<=max_loadfactor
395
重组存储，使得bucket_count>=n
且bucket_count>size/max_load_factor
重组存储，使得c可以保存n个元素且不必rehash

Page422
396
446
无序容器对关键字类型的要求
默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还使用一个
hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）
提供了hash模板。还为一些标准库类型，包括string和我们将要在第12章介绍的智
能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、
string还是智能指针类型的无序容器。
但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能
直接使用哈希模板，而必须提供我们自己的hash模板版本。我们将在16。5节（第626页）
中介绍如何做到这一点。
第11章关联容器
我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型
的默认比较操作（参见11。2。2节，第378页）。为了能将Sale_data用作关键字，我们
需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始：
size_thasher（constSales_data&sd）
{
returnhash<string>（）（sd。isbn（））；
}
booleq0p（constSales_data&lhs，constSales_data&rhs）
{
returnlhs。isbn（）==rhs。isbn（）；
}
我们的hasher函数使用一个标准库hash类型对象来计算ISBN成员的哈希值，该hash
类型建立在string类型之上。类似的，eqOp函数通过比较ISBN号来比较两个
Sales_data。
我们使用这些函数来定义一个unordered_multiset
usingSD_multiset=unordered_multiset<Sales_data，
decltype（hasher）*，decltype（eq0p）*>；
//参数是桶大小、哈希函数指针和相等性判断运算符指针
SDmultisetbookstore（42，hasher，eq0p）；
为了简化bookstore的定义，首先为unordered_multiset定义了一个类型别名（参
见2。5。1节，第60页），此集合的哈希和相等性判断操作与hasher和eqOp函数有着相
同的类型。通过使用这种类型，在定义bookstore时可以将我们希望它使用的函数的指
针传递给它。
如果我们的类定义了==运算符，则可以只重载哈希函数：
//使用FooHash生成哈希值；Foo必须有==运算符
unordered_set<Foo，decltype（FooHash）*>fooSet（10，FooHash）；
11。4节练习
练习11。37：一个无序容器与其有序版本相比有何优势?有序版本有何优势?
练习11。38：用unordered_map重写单词计数程序（参见11。1节，第375页）和单词
转换程序（参见11。3。6节，第391页）。

Page423
小结
小结
关联容器支持通过关键字高效查找和提取元素。对关键字的使用将关联容器和顺序容
器区分开来，顺序容器中是通过位置访问元素的。
标准库定义了8个关联容器，每个容器
‧是一个map或是一个setmap保存关键字—值对；set只保存关键字。
●
要求关键字唯一或不要求。
保持关键字有序或不保证有序。
有序容器使用比较函数来比较关键字，从而将元素按顺序存储。默认情况下，比较操作是
采用关键字类型的<运算符。无序容器使用关键字类型的一运算符和一个
hash<key_type>类型的对象来组织元素。
允许重复关键字的容器的名字中都包含multi；而使用哈希技术的容器的名字都以
unordered开头。例如，set是一个有序集合，其中每个关键字只可以出现一次：
unordered_multiset则是一个无序的关键字集合，其中关键字可以出现多次。
关联容器和顺序容器有很多共同的元素。但是，关联容器定义了一些新操作，并对一
些和顺序容器和关联容器都支持的操作重新定义了含义或返回类型。操作的不同反映出关
联容器使用关键字的特点。
有序容器的迭代器通过关键字有序访问容器中的元素。无论在有序容器中还是在无序
容器中，具有相同关键字的元素都是相邻存储的。
术语表
关联数组（associativearray）元素通过
关键字而不是位置来索引的数组。我们称
这样的数组将一个关键字映射到其关联的
值。
关联容器（associativecontainer）类型，
保存对象的集合，支持通过关键字的高效
查找。
hash特殊的标准库模板，无序容器用它来
管理元素的位置。
哈希函数（hashfunction）将给定类型的
值映射到整形（sizet）值的函数。相等
的值必须映射到相同的整数；不相等的值
应尽可能映射到不同整数。
key_type关联容器定义的类型，用来保存
和提取值的关键字的类型。对于一个map，
key_type是用来索引map的类型。对于
set，key_type和value_type是一样的。
map关联容器类型，定义了一个关联数
组。类似vector，map是一个类模板。
但是，一个map要用两个类型来定义：关
键字的类型和关联的值的类型。在一个
map中，一个给定关键字只能出现一次。
每个关键字关联一个特定的值。解引用一
个map迭代器会生成一个pair，它保存
一个const关键字及其关联的值。
mapped_type映射类型定义的类型，就是
映射中关键字关联的值的类型。
multimap关联容器类型，类似map，不同
之处在于，在一个multimap中，一个给
定的关键字可以出现多次。multimap不
支持下标操作。
multiset保存关键字的关联容器类型。在
一个multiset中，一个给定关键字可以
出现多次。
397
447
448

Page424
398
pair类型，保存名为first和second
的public数据成员｡pair类型是模板类
型，接受两个类型参数，作为其成员的类
型。
set保存关键字的关联容器。在一个set
中，一个给定的关键字只能出现一次。
严格弱序（strictweakordering）关联容
器所使用的关键字间的关系。在一个严格
弱序中，可以比较任意两个值并确定哪个
更小。若任何一个都不小于另一个，则认
为两个值相等。
无序容器（unorderedcontainer）关联容
器，用哈希技术而不是比较操作来存储和
访问元素。这类容器的性能依赖于哈希函
数的质量。
unordered_map保存关键字-值对的容
器，不允许重复关键字。
unordered_multimap保存关键字-值对的
容器，允许重复关键字。
unordered_multiset保存关键字的容器，
第11章关联容器
允许重复关键字。
unordered_set保存关键字的容器，不允
许重复关键字。
value_type容器中元素的类型。对于set
和multiset，value_type和key_type
是一样的。对于map和multimap，此类型是
一个pair，其first成员类型为const
key_type，second成员类型为
mapped_type。
*运算符解引用运算符。当应用于map、
set、multimap或multiset的迭代器
时，会生成一个value_type值。注意，
对map和multimap，value_type是一
个pair。
[]运算符下标运算符。只能用于map和
unorderedmap类型的非const对象。
对于映射类型，[]接受一个索引，必须是
一个key_type值（或者是能转换为
key_type的类型）。生成一个
mapped_type值。

Page425
第12章
动态内存
内容
12。1动态内存与智能指针。
12。2动态数组。。
12。3使用标准库：文本查询程序
小结
术语表。
400
423
430
436
436
到目前为止，我们编写的程序中所使用的对象都有着严格定义的生存期。全局对象在
程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序
块时被创建，在离开块时销毁。局部static对象在第一次使用前分配，在程序结束时
销毁。
除了自动和static对象外，C++还支持动态分配对象。动态分配的对象的生存期与
它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。
动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对
象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，
指向它的智能指针可以确保自动地释放它。
449
