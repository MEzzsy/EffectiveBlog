# 概述

![12](assets/12.jpg)

# vector

初始化

```
vector<int> v1 (10) ;	// v1有10个元素，每个的值都是0
vector<int> v2{10} ;	// v2有1个元素，该元素的值是10
vector<int> v3(10，1) ;	// v3有10个元素，每个的值都是1
vector<int> v4{10，1};	//v4有2个元素，值分别是10和1
```

>   开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。
>
>   特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。

## 改变容器大小

![16](assets/16.jpg)

## 管理容量的成员函数

![17](assets/17.jpg)

reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。

如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

这样，调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque，vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

## reserve和resize的区别

resize：如果容量增大，capacity和size都会跟着增大。resize是添加元素。如果容量减少，capacity不会变化，size会减少。

reserve：如果容量增大，capacity会增大，size不变，reserve不会添加元素。如果容量减少，都不会发生变化。

```cpp
void testVectorResizeAndReserve() {
  {
    std::vector<int> v;
    v.resize(10, 1);
    NDK_LOG("resize: capacity=%d size=%d", v.capacity(), v.size());
    // 容量减小
    v.resize(5, 2);
    NDK_LOG("resize: capacity=%d size=%d", v.capacity(), v.size());
  }
  {
    std::vector<int> v;
    v.reserve(10);
    NDK_LOG("reserve: capacity=%d size=%d", v.capacity(), v.size());
    // 容量减小
    v.reserve(5);
    NDK_LOG("reserve: capacity=%d size=%d", v.capacity(), v.size());
  }
}
```

```
resize: capacity=10 size=10
resize: capacity=10 size=5
reserve: capacity=10 size=0
reserve: capacity=10 size=0
```



# 迭代器

和指针不一样的是， 获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员。

编译器决定b和e的类型。一般来说，我们不清楚(不在意)迭代器准确的类型到底是什么。

# swap操作

除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在**常数时间**内完成。

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。
例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。

与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

# 顺序容器操作

## 访问元素

![13](assets/13.jpg)

### 访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：

![14](assets/14.jpg)

如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

### 下标操作和安全的随机访问

如果我们希望确保下标是合法的，可以使用at成员函数。

## 删除元素

![15](assets/15.jpg)

## 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题

在向容器添加元素后：

-   如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器､指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
-   对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
-   对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后：

-   对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
-   对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
-   对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。使用失效的迭代器、指针或引用是严重的运行时错误。

# 字符串

## 修改操作

![18](assets/18.jpg)

## 搜索操作

![19](assets/19.jpg)

## 数值转换

![20](assets/20.jpg)

# 泛型算法

## 概述

用户可能还希望做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。

标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法，大多数算法都定义在头文件algorithm中。

## 初识泛型算法

### 写容器元素的算法

#### 算法不检查写操作

可以用fill_n将一个新值赋予vector中的元素：

```cpp
vector<int> vec;	// 空vector
// 使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0);	// 将所有元素重置为0
```

函数fill_n假定写入指定个元素是安全的。即，如下形式的调用

```
fill_n(dest, n, val);
```

fill_n假定dest指向一个元素，而从dest开始的序列至少包含n个元素。

一个初学者非常容易犯的错误是在一个空容器上调用fill_n（或类似的写元素的算法）。

#### 介绍back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。为了展示如何用算法向容器写入数据，我们现在将使用back_inserter，它是定义在头文件iterator
中的一个函数。

```cpp
{
  // 引入头文件#include "iterator"
  std::vector<string> vec;    // 空vector
  fill_n(std::back_inserter(vec), 5, "1");    // 将所有元素重置为0

  string log;
  // #include "numeric"
  // // 初始值不能写""，因为这是const char *，const char *不支持+法
  log = std::accumulate(vec.cbegin(), vec.cend(), log);
  NDK_LOG("log=%s", log.data());
}
```



back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：
vector<int>vec；//空向量
autoit=back_inserter（vec）；//通过它赋值会将元素添加到vec中
*it=42；//vec中现在有一个元素，值为42
我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：
vector<int>vec；//空向量
//正确：back_inserter创建一个插入迭代器，可用来向vec添加元素
fill_n（back_inserter（vec），10，0）；//添加10个元素到vec
在每步迭代中，fill_n向给定序列的一个元素赋值。由于我们传递的参数是
back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，
这条fill_n调用语句向vec的末尾添加了10个元素，每个元素的值都是0。
拷贝算法
拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的
算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位
置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含
与输入序列一样多的元素，这一点很重要。
我们可以用copy实现内置数组的拷贝，如下面代码所示：
intal[]={0，1，2，3，4，5，6，7，8，9}；
inta2[sizeof（al）/sizeof（*al）]；//a2与al大小一样
//ret指向拷贝到a2的尾元素之后的位置
autoret=copy（begin（al），end（al），a2）；//把al的内容拷贝给a2
此例中我们定义了一个名为a2的数组，并使用sizeof确保a2与数组a1包含同样多的
341
383

Page368
342
元素（参见4。9节，第139页）。接下来我们调用copy完成从a1到a2的拷贝。在调用
copy后，两个数组中的元素具有相同的值。
copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的
尾元素之后的位置。
多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置
在输入序列的末尾，而是创建一个新序列保存这些结果。
例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个
值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，
另一个是新值。它将所有等于第一个值的元素替换为第二个值：
//将所有值为0的元素改为42
replace（ilst。begin（），ilst。end（），0，42）；
第10章泛型算法
此调用将序列中所有的0都替换为42。如果我们希望保留原序列不变，可以调用
replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：
//使用back_inserter按需要增长目标序列
replace_copy（ilst。cbegin（），ilst。cend（），
back_inserter（ivec），0，42）；
此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ist中值为0的
元素在ivec中都变为42。
10。2。2节练习
练习10。6：编写程序，使用fill_n将一个序列中的int值都设置为0。
练习10。7：下面程序是否有错误?如果有，请改正。
（a）vector<int>vec；list<int>lst；inti；
while（cin>>i）
lst。push_back（i）；
copy（1st。cbegin（），1st。cend（），vec。begin（））；
（b）vector<int>vec；
vec。reserve（10）；//reverse将在9。4节（第318页）介绍
fill_n（vec。begin（），10，0）；
练习10。8：本节提到过，标准库算法不会改变它们所操作的容器的大小。为什么使用
back_inserter不会使这一断言失效?
10。2。3重排容器元素的算法
某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输
入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。
例如，假定我们想分析一系列儿童故事中所用的词汇。假定已有一个vector，保存
了多个故事的文本。我们希望化简这个vector，使得每个单词只出现一次，而不管单词
在任意给定文档中到底出现了多少次。
为了便于说明问题，我们将使用下面简单的故事作为输入：

Page369
10。2初识泛型算法
thequickredfoxjumpsovertheslowredturtle
给定此输入，我们的程序应该生成如下vector：
foxjumpsoverquick
消除重复单词
为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector
排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重
复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector
的erase成员来完成真正的删除操作：
voidelimDups（vector<string>&words）
{
}
red
slow
//按字典序排序words，以便查找重复单词
sort（words。begin（），words。end（））；
//unique重排输入范围，使得每个单词只出现一次
//排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
autoend_unique
//使用向量操作erase删除重复单词
words。erase（end_unique，words。end（））；
the
unique（words。begin（），words。end（））；
注意，单词red和the各出现了两次。
turtle
sort算法接受两个迭代器，表示要排序的元素范围。在此例中，我们排序整个vector。
完成sort后，words的顺序如下所示：
foxjumpsoverquickredredslowthetheturtle
使用unique
words排序完毕后，我们希望将每个单词都只保存一次。unique算法重排输入序列，
将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。调用unique后，
vector将变为：
foxjumpsoverquickredslowtheturtle
??????
牛
endunique
（最后一个不重复元素之后的位置）
words的大小并未改变，它仍有10个元素。但这些元素的顺序被改变了——相邻的
重复元素被“删除”了。我们将删除打引号是因为unique并不真的删除任何元素，它只
是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。unique返回的迭代器指
向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值
是什么。
标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删
Note除元素。
使用容器操作删除元素
为了真正地删除无用元素，我们必须使用容器操作，本例中使用erase（参见9。3。3
343
384
385

Page370
344
386
节，第311页）。我们删除从end_unique开始直至words末尾的范围内的所有元素。
这个调用之后，words包含来自输入的8个不重复的单词。
值得注意的是，即使words中没有重复单词，这样调用erase也是安全的。在此情
况下，unique会返回words。end（）。因此，传递给erase的两个参数具有相同的值：
words。end（）。迭代器相等意味着传递给erase的元素范围为空。删除一个空范围没有
什么不良后果，因此程序即使在输入中无重复元素的情况下也是正确的。
第10章泛型算法
10。2。3节练习
练习10。9：实现你自己的elimDups。测试你的程序，分别在读取输入后､调用unique
后以及调用erase后打印vector的内容。
练习10。10：你认为算法不改变容器大小的原因是什么?
10。3定制操作
很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==
运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作
来代替默认运算符。
例如，sort算法默认使用元素类型的<运算符。但可能我们希望的排序顺序与<所定
义的顺序不同，或是我们的序列可能保存的是未定义<运算符的元素类型（如
Sales_data）。在这两种情况下，都需要重载sort的默认行为。
10。3。1向算法传递函数
作为一个例子，假定希望在调用elimDups（参见10。2。3节，第343页）后打印vector
的内容。此外还假定希望单词按其长度排序，大小相同的再按字典序排列。为了按长度重
排vector，我们将使用sort的第二个版本，此版本是重载过的，它接受第三个参数，
此参数是一个谓词（predicate）。
谓词
谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用
的谓词分为两类：一元谓词（unarypredicate，意味着它们只接受单一参数）和二元谓词
（binarypredicate，意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调
用谓词。因此，元素类型必须能转换为谓词的参数类型。
接受一个二元谓词参数的sort版本用这个谓词代替<来比较元素。我们提供给sort
的谓词必须满足将在11。2。2节（第378页）中所介绍的条件。当前，我们只需知道，此操
作必须在输入序列中所有可能的元素值上定义一个一致的序。我们在6。2。2节（第189页）
中定义的isShorter就是一个满足这些要求的函数，因此可以将isShorter传递给
sort。这样做会将元素按大小重新排序：
//比较函数，用来按长度排序单词
boolisShorter（conststring&sl，conststring&s2）。
（
}
returns1。size（）<s2。size（）；

Page371
10。3定制操作
//按长度由短至长排序words
sort（words。begin（），words。end（），isShorter）；
如果words包含的数据与10。2。3节（第343页）中一样，此调用会将words重排，使得
所有长度为3的单词排在长度为4的单词之前，然后是长度为5的单词，依此类推。
排序算法
在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为
了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法
维持相等元素的原有顺序。
通常情况下，我们不关心有序序列中相等元素的相对顺序，它们毕竟是相等的。但是，
在本例中，我们定义的“相等”关系表示“具有相同长度”。而具有相同长度的元素，如387
果看其内容，其实还是各不相同的。通过调用stable_sort，可以保持等长元素间的字
典序：
elimDups（words）；//将words按字典序重排，并消除重复单词
//按长度重新排序，长度相同的单词维持字典序
stable_sort（words。begin（），words。end（），isShorter）；
for（constauto&s：words）//无须拷贝字符串
cout<<s<<""；//打印每个元素，以空格分隔
cout<<endl；
假定在此调用前words是按字典序排列的，则调用之后，words会按元素大小排序，而
长度相同的单词会保持字典序。如果我们对原来的vector内容运行这段代码，输出为：
foxredtheoverslowjumpsquickturtle
10。3。1节练习
练习10。11：编写程序，使用stable_sort和isShorter将传递给你的elimDups
版本的vector排序。打印vector的内容，验证你的程序的正确性。
练习10。12：编写名为compareIsbn的函数，比较两个Sales_data对象的isbn（）
成员。使用这个函数排序一个保存Sales_data对象的vector。
练习10。13：标准库定义了名为partition的算法，它接受一个谓词，对容器内容进
行划分，使得谓词为true的值会排在容器的前半部分，而使谓词为false的值会排
在后半部分。算法返回一个迭代器，指向最后一个使谓词为true的元素之后的位置。
编写函数，接受一个string，返回一个bool值，指出string是否有5个或更多字
符。使用此函数划分words。打印出长度大于等于5的元素。
10。3。2lambda表达式
根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两
个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。例如，
为上一节最后一个练习所编写的程序中，就必须将大小5硬编码到划分序列的谓词中。如
果在编写划分序列的谓词时，可以不必为每个可能的大小都编写一个独立的谓词，显然更
有实际价值。
345
一个相关的例子是，我们将修改10。3。1节（第345页）中的程序，求大于等于一个给
定长度的单词有多少。我们还会修改输出，使程序只打印大于等于给定长度的单词。

Page372
346
388
C++
11
389
我们将此函数命名为biggies，其框架如下所示：
voidbiggies（vector<string>&words，
{
vector<string>：：size_type
第10章泛型算法
sz）
elimDups（words）；//将words按字典序排序，删除重复单词
//按长度排序，长度相同的单词维持字典序
stable_sort（words。begin（），words。end（），isShorter）；
//获取一个迭代器，指向第一个满足size（）>=sz的元素
//计算满足size>=sz的元素的数目
//打印长度大于等于给定值的单词，每个单词后面接一个空格
}
我们的新问题是在vector中寻找第一个大于等于给定长度的元素。一旦找到了这个
元素，根据其位置，就可以计算出有多少元素的长度大于等于给定值。
我们可以使用标准库find_if算法来查找第一个具有特定大小的元素。类似find
（参见10。1节，第336页），find_if算法接受一对迭代器，表示一个范围。但与find
不同的是，find_if的第三个参数是一个谓词。find_if算法对输入序列中的每个元素
调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，
则返回尾迭代器。
编写一个函数，令其接受一个string和一个长度，并返回一个bool值表示该
string的长度是否大于给定长度，是一件很容易的事情。但是，find_if接受一元谓词
-我们传递给find_if的任何函数都必须严格接受一个参数，以便能用来自输入序列
的一个元素调用它。没有任何办法能传递给它第二个参数来表示长度。为了解决此问题，
需要使用另外一些语言特性。
介绍lambda
我们可以向一个算法传递任何类别的可调用对象（callableobject）。对于一个对象或
一个表达式，如果可以对其使用调用运算符（参见1。5。2节，第21页），则称它为可调用
的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一
个逗号分隔的一个或多个参数的列表。
到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针（参见6。7节，
第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14。8节（第
506页）介绍，以及lambda表达式（lambdaexpression）。
一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的
内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数
体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式
[capturelist]（parameterlist）->returntype{functionbody}
其中，capturelist（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为
空）；returntype、parameterlist和functionbody与任何普通函数一样，分别表示返回类型、
参数列表和函数体。但是，与普通函数不同，lambda必须使用尾置返回（参见6。3。3节，
第206页）来指定返回类型。
我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
autof=[]{return42；}；

Page373
10。3定制操作
此例中，我们定义了一个可调用对象f，它不接受参数，返回42。
lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：
cout<<f（）<<endl；//打印42
在lambda中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用f
时，参数列表是空的。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。
如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，
返回类型为void。
Note
如果lambda的函数体包含任何单-return语句之外的内容，且未指定返回
类型，则返回void。
向lambda传递参数
与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形
参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有默认参数（参
见6。5。1节，第211页）。因此，一个lambda调用的实参数目永远与形参数目相等。8
形参初始化完毕，就可以执行函数体了。
作为一个带参数的lambda的例子，我们可以编写一个与isShorter函数完成相同
功能的lambda：
[]（conststring&a，conststring&b）
{returna。size（）<b。size（）；}
空捕获列表表明此lambda不使用它所在函数中的任何局部变量。lambda的参数与
isShorter的参数类似，是conststring的引用。lambda的函数体也与isShorter
类似，比较其两个参数的size（），并根据两者的相对大小返回一个布尔值。
如下所示，可以使用此lambda来调用stable_sort：
//按长度排序，长度相同的单词维持字典序
stable_sort（words。begin（），words。end（），
[]（conststring&a，conststring&b）
{returna。size（）<b。size（）；}）；
当stable_sort需要比较两个元素时，它就会调用给定的这个lambda表达式。
使用捕获列表
我们现在已经准备好解决原来的问题了——编写一个可以传递给find_if的可调用
表达式。我们希望这个表达式能将输入序列中每个string的长度与biggies函数中的
sz参数的值进行比较。
虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确
指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。
捕获列表指引lambda在其内部包含访问局部变量所需的信息。
在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函数体会将
string的大小与捕获的sz的值进行比较：
[sz]（conststring&a）
{returna。size（）>=sz；}；
347
390

Page374
348
391
lambda以一对门开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是
它所在函数中定义的。
由于此lambda捕获ssz，因此lambda的函数体可以使用sz。lambda不捕获words，
因此不能访问此变量。如果我们给lambda提供一个空捕获列表，则代码会编译错误：
//错误：sz未捕获
[]（conststring&a）
Note
{returna。size（）>=sz；}；
第10章泛型算法
一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在
函数体中使用该变量。
调用find_if
使用此lambda，我们就可以查找第一个长度大于等于sz的元素：
//获取一个迭代器，指向第一个满足size（）>=sz的元素
autowc=find_if（words。begin（），words。end（），
[sz]（conststring&a）
{returna。size（）>=sz；}）；
这里对find_if的调用返回一个迭代器，指向第一个长度不小于给定参数sz的元素。
如果这样的元素不存在，则返回words。end（）的一个拷贝。
我们可以使用find_if返回的迭代器来计算从它开始到words的末尾一共有多少个
元素（参见3。4。2节，第99页）：
//计算满足size>=sz的元素的数目
autocount=words。end（）-WC；
cout<<count<<""<<make_plural（count，"word"，"s"）
<<"oflength"<<sz<<"orlonger"<<endl；
我们的输出语句调用make_plural（参见6。3。2节，第201页）来输出“word”或“words”，
具体输出哪个取决于大小是否等于1。
for_each算法
问题的最后一部分是打印words中长度大于等于sz的元素。为了达到这一目的，我
们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列中每个元素调用
此对象：
//打印长度大于等于给定值的单词，每个单词后面接一个空格
for_each（wc，words。end（），
[]（conststring&s）{cout<<s<<""；}）；
cout<<endl；
此lambda中的捕获列表为空，但其函数体中还是使用了两个名字：s和cout，前者是它
自己的参数。
捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕
获列表。一个lambda可以直接使用定义在当前函数之外的名字。在本例中，cout不是定
义在biggies中的局部名字，而是定义在头文件iostream中。因此，只要在biggies
出现的作用域中包含了头文件iostream，我们的lambda就可以使用cout。

Page375
10。3定制操作
Note
完整的biggies
到目前为止，我们已经解决了程序的所有细节，下面就是完整的程序：
voidbiggies（vector<string>&words，
{
捕获列表只用于局部非static变量，lambda可以直接使用局部static变
量和在它所在函数之外声明的名字。
}
vector<string>：：size_typesz）
elimDups（words）；//将words按字典序排序，删除重复单词
//按长度排序，长度相同的单词维持字典序
stable_sort（words。begin（），words。end（），
[]（conststring&a，conststring&b）
{returna。size（）<b。size（）；}）；
//获取一个迭代器，指向第一个满足size（）>=sz的元素
autowcfind_if（words。begin（），words。end（），
[sz]（conststring&a）
{returna。size（）>=sz；}）；
//计算满足size>=sz的元素的数目
autocount=words。end（）-wc；
cout<<count<<""<<make_plural（count，"word"，"s"）
<<"oflength
//打印长度大于等于给定值的单词，每个单词后面接一个空格
for_each（wc，words。end（），
cout<<endl；
<<sz<<"orlonger"<<endl；
[]（conststring&s）{cout<<s<<""；}）；
10。3。2节练习
练习10。14：编写一个lambda，接受两个int，返回它们的和。
练习10。15：编写一个lambda，捕获它所在函数的int，并接受一个int参数。lambda
应该返回捕获的int和int参数的和。
练习10。16：使用lambda编写你自己版本的biggies。
练习10。17：重写10。3。1节练习10。12（第345页）的程序，在对sort的调用中使用lambda
来代替函数compareIsbn。
练习10。18：重写biggies，用partition代替find_if｡我们在10。3。1节练习10。13
（第345页）中介绍了partition算法。
练习10。19：用stable_partition重写前一题的程序，与stable_sort类似，在
划分后的序列中维持原有元素的顺序。
10。3。3lambda捕获和返回
当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。
我们将在14。8。1节（第507页）介绍这种类是如何生成的。目前，可以这样理解，当向一
个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就
349
392

Page376
350
393
是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始
化的变量时，定义了一个从lambda生成的类型的对象。
默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。
类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。
值捕获
类似参数传递，变量的捕获方式也可以是值或引用。表10。1（第352页）列出了几种
不同的构造捕获列表的方式。到目前为止，我们的lambda采用值捕获的方式。与传值参
数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda
创建时拷贝，而不是调用时拷贝：
voidfcnl（）。
{
第10章泛型算法
size_tv1=42；//局部变量
//将v1拷贝到名为f的可调用对象
autof=[v1]{returnvl；}；
v1=0；
autoj=f（）；//j为42；f保存了我们创建它时v1的拷贝
}
由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对
应的值。
引用捕获
我们定义lambda时可以采用引用方式捕获变量。例如：
voidfcn2（）
{
size_tv1=42；//局部变量
//对象f2包含v1的引用
autof2=[&v1]{returnvl；}；
v1=0；
autoj=f2（）；//j为0；f2保存v1的引用，而非拷贝
}
v1之前的&指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的
引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定
的对象。在本例中，当lambda返回v1时，它返回的是v1指向的对象的值。
{
引用捕获与返回引用（参见6。3。2节，第201页）有着相同的问题和限制。如果我们
采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。
lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在
函数结束后执行，捕获的引用指向的局部变量已经消失。
引用捕获有时是必要的。例如，我们可能希望biggies函数接受一个ostream的
引用，用来输出数据，并接受一个字符作为分隔符：
voidbiggies（vector<string>&words，
vector<string>：：size_typesz，
ostream&os=cout，charc
//与之前例子一样的重排words的代码
"）

Page377
10。3定制操作
//打印count的语句改为打印到os
for_each（words。begin（），words。end（），
[&os，c]（conststring&s）{os<<s<<c；}）；
}
我们不能拷贝ostream对象（参见8。1。1节，第279页），因此捕获os的唯一方法就是
捕获其引用（或指向os的指针）。
当我们向一个函数传递一个lambda时，就像本例中调用for_each那样，lambda
会立即执行。在此情况下，以引用方式捕获os没有问题，因为当for_each执行时，
biggies中的变量是存在的。
WARNING
我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一
个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返
回一个局部变量的引用类似，此lambda也不能包含引用捕获。
当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。
建议：尽量保持lambda的变量捕获简单化
罪
一个lambda捕获从lambda被创建（即，定义lambda的代码执行时）到lambda自
身执行（可能有多次执行）这段时间内保存的相关信息。确保lambda每次执行的时候
这些信息都有预期的意义，是程序员的责任。
捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值
捕获方式。在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。
如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在lambda执
行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值。
在lambda从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。也就是说，
在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行
时，该对象的值可能已经完全不同了。
一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，
如果可能的话，应该避免捕获指针或引用。
隐式捕获
除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda
体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中
写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。例如，我们可
以重写传递给find_if的lambda：
//sz为隐式捕获，值捕获方式
wc=find_if（words。begin（），words。end（），
[=]（conststring&s）
{returns。size（）>=sz；}）；
如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐
式捕获和显式捕获：
voidbiggies（vector<string>&words，
351
394

Page378
352
395
[]
[names]
[&]
}
当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符
号指定了默认捕获方式为引用或值。
[=]
当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方
式。即，如果隐式捕获是引用方式（使用了&），则显式捕获命名变量必须采用值方式，因
此不能在其名字前使用&。类似的，如果隐式捕获采用的是值方式（使用了=），则显式捕
获命名变量必须采用引用方式，即，在名字前使用&。
[&，identifier_list]
vector<string>：：size_typesz，
ostream&os=cout，charc
[=，identifier_list]
//其他处理与前例一样
//os隐式捕获，引用捕获方式；c显式捕获，值捕获方式
for_each（words。begin（），words。end（），
[&，c]（conststring&s）{os<<s<<c；}）；
//os显式捕获，引用捕获方式；c隐式捕获，值捕获方式
for_each（words。begin（），words。end（），
[=，&os]（conststring&s）{os<<s<<c；}）；
}
"
"）
=
第10章泛型算法
表10。1：lambda捕获列表
空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕
获变量后才能使用它们
names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的
局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使
用了&，则采用引用捕获方式
隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函
数的实体都采用引用方式使用
隐式捕获列表，采用值捕获方式。lambda体将拷贝所使用的来自所在
函数的实体的值
identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数
的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引
用方式捕获。identifier_list中的名字前面不能使用&
可变lambda
默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变
一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda
能省略参数列表：
voidfcn3（）
{
identifier_list中的变量都采用引用方式捕获，而任何隐式捕获的变量都
采用值方式捕获。identifier_list中的名字不能包括this，且这些名字
之前必须使用&
size_tv1=42；//局部变量
//f可以改变它所捕获的变量的值
autof=[v1]（）mutable{return++v1；}；
v1=0；
autoj
f（）；//j为43

Page379
10。3定制操作
一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const
类型还是一个非const类型：
voidfcn4（）
{
}
sizetv1=42；//局部变量
//v1是一个非const变量的引用
//可以通过f2中的引用来改变它
autof2=[&v1]{return++v1；}；
v1=0；
autojf2（）；//j为1
指定lambda返回类型
到目前为止，我们所编写的lambda都只包含单一的return语句。因此，我们还未
遇到必须指定返回类型的情况。默认情况下，如果一个lambda体包含return之外的任
何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回
void的lambda不能返回值。
下面给出了一个简单的例子，我们可以使用标准库transform算法和一个lambda
来将一个序列中的每个负数替换为其绝对值：
transform（vi。begin（），vi。end（），vi。begin（），
[]（inti）{returni<0?-i：i；}）；
函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三
个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的
位置。如本例所示，目的位置迭代器与表示输入序列开始位置的迭代器可以是相同的。当
输入迭代器和目的迭代器相同时，transform将输入序列中每个元素替换为可调用对象
操作该元素得到的结果。
在本例中，我们传递给transform一个lambda，它返回其参数的绝对值。lambda
体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可
以根据条件运算符的类型推断出来。
但是，如果我们将程序改写为看起来是等价的if语句，就会产生编译错误：
//错误：不能推断lambda的返回类型
transform（vi。begin（），vi。end（），vi。begin（），
[]（inti）{if（i<0）return-i；elsereturni；}）；
编译器推断这个版本的lambda返回类型为void，但它返回了一个int值。
当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型（参见6。3。3节，
第206页）：
transform（vi。begin（），vi。end（），vi。begin（），
[]（inti）->int
{if（i<0）return-i；elsereturni；}）；
在此例中，传递给transform的第四个参数是一个lambda，它的捕获列表是空的，接受
单一int参数，返回一个int值。它的函数体是一个返回其参数的绝对值的if语句。
353
396
C++
11

Page380
354
397
398
第10章泛型算法
10。3。3节练习
练习10。20：标准库定义了一个名为count_if的算法。类似find_if，此函数接受
一对迭代器，表示一个输入范围，还接受一个谓词，会对输入范围中每个元素执行。
count_if返回一个计数值，表示谓词有多少次为真。使用count_if重写我们程序中
统计有多少单词长度超过6的部分。
练习10。21：编写一个lambda，捕获一个局部int变量，并递减变量值，直至它变为0。
一旦变量变为0，再调用lambda应该不再递减变量。lambda应该返回一个bool值，指
出捕获的变量是否为0。
10。3。4参数绑定
对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要
在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表
达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。
如果lambda的捕获列表为空，通常可以用函数来代替它。如前面章节所示，既可以
用一个lambda，也可以用函数isShorter来实现将vector中的单词按长度排序。类似
的，对于打印vector內容的lambda，编写一个函数来替换它也是很容易的事情，这个函
数只需接受一个string并在标准输出上打印它即可。
但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。例如，我们
用在find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易地编
写一个完成同样工作的函数：
boolcheck_size（conststring&s，string：：size_typesz）
{
returns。size（）>=sz；
}
但是，我们不能用这个函数作为find_if的一个参数。如前文所示，find_if接受一个
一元谓词，因此传递给find_if的可调用对象必须接受单一参数。biggies传递给
find_if的lambda使用捕获列表来保存sz。为了用check_size来代替此lambda，必
须解决如何向sz形参传递一个参数的问题。
标准库bind函数
我们可以解决向check_size传递一个长度参数的问题，方法是使用一个新的名为
C++bind的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用
的函数适配器（参见9。6节，第329页），它接受一个可调用对象，生成一个新的可调用对
象来“适应”原对象的参数列表。
调用bind的一般形式为：
autonewCallable=bind（callable，arg_list）；
其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给
定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传
递给它arg_list中的参数。
arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，

Page381
10。3定制操作
表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示
生成的可调用对象中参数的位置：1为newCallable的第一个参数，2为第二个参数，依
此类推。
绑定check_size的sz参数
作为一个简单的例子，我们将使用bind生成一个调用check_size的对象，如下
所示，它用一个定值作为其大小参数来调用check_size：
//check6是一个可调用对象，接受一个string类型的参数
//并用此string和值6来调用check_size
autocheck6=bind（check_size，_1，6）；
此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的
第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个
conststring&。因此，调用check6必须传递给它一个string类型的参数，check6
会将此参数传递给check_size。
strings="hello"；
boolb1=check6（s）；//check6（s）会调用check_size（s，6）
使用bind，我们可以将原来基于lambda的find_if调用：
autowc=find_if（words。begin（），words。end（），
[sz]（conststring&a）
替换为如下使用check_size的版本：
autowc=find_if（words。begin（），words。end（），
bind（check_size，1，sz））；
此bind调用生成一个可调用对象，将check_size的第二个参数绑定到sz的值。当
find_if对words中的string调用这个对象时，这些对象会调用check_size，将给
定的string和sz传递给它。因此，find_if可以有效地对输入序列中每个string
调用check_size，实现string的大小与sz的比较。
使用placeholders名字
名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义
在std命名空间（参见3。1节，第74页）中。为了使用这些名字，两个命名空间都要写
上。与我们的其他例子类似，对bind的调用代码假定之前已经恰当地使用了using声
明。例如，1对应的using声明为：
usingstd：：placeholders：：_1；
此声明说明我们要使用的名字_1定义在命名空间placeholders中，而此命名空间又定
义在命名空间std中。
对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦
人，也很容易出错。可以使用另外一种不同形式的using语句（详细内容将在18。2。2节
（第702页）中介绍），而不是分别声明每个占位符，如下所示：
usingnamespacenamespace_name；
这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。例
如：
355
399

Page382
356
400
usingnamespacestd：：placeholders；
使得由placeholders定义的所有名字都可用。与bind函数一样，placeholders命
名空间也定义在functional头文件中。
bind的参数
如前文所述，我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可
调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，
则下面对bind的调用：
//g是一个有两个参数的可调用对象
autog=bind（f，a，b，_2，c，1）；
第10章泛型算法
生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用
对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参
数分别被绑定到给定的值a、b和c上。
传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到
_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参
数将被传递给f作为第三个参数。实际上，这个bind调用会将
g（_1，_2）
映射为
f（a，b，_2，c，1）
即，对g的调用会调用f，用g的参数代替占位符，再加上绑定的参数a、b和c。例如，
调用g（X，Y）会调用
f（a，b，Y，c，X）
用bind重排参数顺序
下面是用bind重排参数顺序的一个具体例子，我们可以用bind颠倒isShroter
的含义：
//按单词长度由短至长排序
sort（words。begin（），words。end（），isShorter）；
//按单词长度由长至短排序
sort（words。begin（），words。end（），bind（isShorter，2，1））；
在第一个调用中，当sort需要比较两个元素A和B时，它会调用isShorter（A，B）。
在第二个对sort的调用中，传递给isShorter的参数被交换过来了。因此，当sort
比较两个元素时，就好像调用isShorter（B，A）一样。
绑定引用参数
默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。
但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参
数的类型无法拷贝。
例如，为了替换一个引用方式捕获ostream的lambda：
//os是一个局部变量，引用一个输出流
//c是一个局部变量，类型为char
for_each（words。begin（），words。end（），

Page383
10。4再探迭代器
[&os，c]（conststring&s）{OS<<s<<c；}）；
可以很容易地编写一个函数，完成相同的工作：
ostream&print（ostream&os，conststring&s，charc）
{
returnos<<s<<c；
}
但是，不能直接用bind来代替对os的捕获：
//错误：不能拷贝os
for_each（words。begin（），words。end（），bind（print，os，_1，'））；
原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind
一个对象而又不拷贝它，就必须使用标准库ref函数：
for_each（words。begin（），words。end（），
bind（print，ref（os），_1，'））；
函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref
函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文
件functional中。
向后兼容：参数绑定
旧版本C++提供的绑定函数参数的语言特性限制更多，也更复杂。标准库定义了两个分
别名为bindlst和bind2nd的函数。类似bind，这两个函数接受一个函数作为参数，
生成一个新的可调用对象，该对象调用给定函数，并将绑定的参数传递给它。但是，这
些函数分别只能绑定第一个或第二个参数。由于这些函数局限太强，在新标准中已被弃
用（deprecated）。所谓被弃用的特性就是在新版本中不再支持的特性。新的C++程序应
该使用bind。
10。3。4节练习
练习10。22：重写统计长度小于等于6的单词数量的程序，使用函数代替lambda。
练习10。23：bind接受几个参数?
练习10。24：给定一个string，使用bind和check_size在一个int的vector
中查找第一个大于string长度的值。
练习10。25：在10。3。2节（第349页）的练习中，编写了一个使用partition的biggies
版本。使用checksize和bind重写此函数。
10。4再探迭代器
除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几
种迭代器。这些迭代器包括以下几种。
•插入迭代器（insertiterator）：这些迭代器被绑定到一个容器上，可用来向容器插入
元素。
•流迭代器（streamiterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所
357
401

Page384
358
402
关联的IO流。
‧反向迭代器（reverseiterator）：这些迭代器向后而不是向前移动。除了
forward_list之外的标准库容器都有反向迭代器。
●移动迭代器（moveiterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它
们。我们将在13。6。2节（第480页）介绍移动迭代器。
10。4。1插入迭代器
插入器是一种迭代器适配器（参见9。6节，第329页），它接受一个容器，生成一个迭
代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调
用容器操作来向给定容器的指定位置插入一个元素。表10。2列出了这种迭代器支持的操作。
it=t
*it，++it，it++
命。
第10章泛型算法
插入器有三种类型，差异在于元素插入的位置：
•back_inserter（参见10。2。2节，第341页）创建一个使用push_back的迭代
表10。2：插入迭代器操作
在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插
入迭代器的不同种类，此赋值会分别调用c。push_back（t）、
c。push_front（t）或c。insert（t，p），其中p为传递给inserter
的迭代器位置
这些操作虽然存在，但不会对it做任何事情。每个操作都返回it
Note
•front_inserter创建一个使用push_front的迭代器。
•inserter创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必
须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。
只有在容器支持push_front的情况下，我们才可以使用front_inserter。
类似的，只有在容器支持push_back的情况下，我们才能使用
back_inserter。
理解插入器的工作过程是很重要的：当调用inserter（c，iter）时，我们得到一个
迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如
果it是由inserter生成的迭代器，则下面这样的赋值语句
*it=val；
其效果与下面代码一样
it=c。insert（it，val）；//it指向新加入的元素
++it；//递增it使它指向原来的元素
front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当
我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给
inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素
就不再是容器的首元素了：
list<int>1st={1，2，3，4}；
list<int>lst2，1st3；//空list

Page385
10。4再探迭代器
//拷贝完成之后，1st2包含4321
copy（lst。cbegin（），1st。cend（），front_inserter（1st2））；
//拷贝完成之后，1st3包含1234
copy（1st。cbegin（），1st。cend（），inserter（1st3，1st3。begin（）））；
当调用front_inserter（c）时，我们得到一个插入迭代器，接下来会调用
push_front。当每个元素被插入到容器c中时，它变为c的新的首元素。因此，
frontinserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和
backinserter则不会。
10。4。1节练习
练习10。26：解释三种插入迭代器的不同之处。
练习10。27：除了unique（参见10。2。3节，第343页）之外，标准库还定义了名为
unique_copy的函数，它接受第三个迭代器，表示拷贝不重复元素的目的位置。编写
一个程序，使用unique_copy将一个vector中不重复的元素拷贝到一个初始为空的
list中。
练习10。28：个vector中保存1到9，将其拷贝到三个其他容器中。分别使用
inserter、back_inserter和front_inserter将元素添加到三个容器中。对每
种inserter，估计输出序列是怎样的，运行程序验证你的估计是否正确。
10。4。2iostream迭代器
虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器
（参见8。1节，第278页）。istream_iterator（参见表10。3）读取输入流，
ostream_iterator（参见表10。4节，第361页）向一个输出流写数据。这些迭代器将
它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型
算法从流对象读取数据以及向其写入数据。
istream_iterator1
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个
istream_iterator使用>>来读取流。因此，istream_iterator要读取的类型必须
定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。
当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。
istream_iterator<int>int_it（cin）；//从cin读取int
istream_iterator<int>int_eof；
//尾后迭代器
ifstreamin（"afile"）；
istream_iterator<string>str_it（in）；//从"afile"读取字符串
下面是一个用istream_iterator从标准输入读取数据，存入一个vector的例子：
istream_iterator<int>in_iter（cin）；//从cin读取int
//istream尾后迭代器
//当有数据可供读取时
istreamiterator<int>eof；
while（initer!=eof）
//后置递增运算读取流，返回迭代器的旧值
//解引用迭代器，获得从流读取的前一个值
vec。push_back（*in_iter++）；
359
403

Page386
360
404
405
此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter
是否等于eof。eof被定义为空的istream_iterator，从而可以当作尾后迭代器來使
用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的
值就与尾后迭代器相等。
此程序最困难的部分是传递给push_back的参数，其中用到了解引用运算符和后置
递增运算符。该表达式的计算过程与我们之前写过的其他结合解引用和后置递增运算的表
达式一样（参见4。5节，第131页）。后置递增运算会从流中读取下一个值，向前推进，但
返回的是迭代器的旧值。迭代器的旧值包含了从流中读取的前一个值，对迭代器进行解引
用就能获得此值。
我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方：
istream_iterator<int>in_iter（cin），eof；//从cin读取int
vector<int>vec（in_iter，eof）；//从迭代器范围构造vec
本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是
istream_iterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构
造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中
读取的数据被用来构造vec。
第10章泛型算法
istreamiterator<T>in（is）；
istreamiterator<T>end；
in1==in2
inl!=in2
*in
表10。3：istream_iterator操作
in->mem
++in，in++
in从输入流is读取类型为T的值
读取类型为T的值的istreamiterator迭代器，
表示尾后位置
in和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同
的输入，则两者相等
返回从流中读取的值
与（*in）。mem的含义相同
使用元素类型所定义的>>运算符从输入流中读取下一个值。与以往一样，
前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值
使用算法操作流迭代器
由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此
我们至少可以用某些算法来操作流迭代器。我们在10。5。1节（第365页）会看到如何分辨
哪些算法可以用于流迭代器。下面是一个例子，我们可以用一对istream_iterator来
调用accumulate：
istreamiterator<int>in（cin），eof；
cout<<accumulate（in，eof，0）<<endl；
此调用会计算出从标准输入读取的值的和。如果输入为：
23109458963412903423562388923
则输出为664。
istream_iterator允许使用懒惰求值
当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从
流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标

Page387
10。4再探迭代器
准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经
完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建
了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步
读取同一个流，那么何时读取可能就很重要了。
ostream_iterator1
我们可以对任何具有输出运算符（<<运算符）的类型定义ostream_iterator。当
创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串，
在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符
串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator
绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。
ostreamiterator<T>out（os）；
ostream_iterator<T>out（os，d）；
out=val
*out，++out，out++
表10。4：ostream_iterator操作
out将类型为T的值写到输出流os中
out将类型为T的值写到输出流os中，每个值
后面都输出一个dd指向一个空字符结尾的字
符数组
用<<运算符将val写入到out所绑定的ostream中。val的类
型必须与out可写的类型兼容
这些运算符是存在的，但不对out做任何事情。每个运算符都返回
out
我们可以用ostream_iterator来输出值的序列：
ostream_iterator<int>out_iter（cout，
for（autoe：vec）
*out_iter++=e；//赋值语句实际上将元素写到cout
cout<<endl；
for（autoe：vec）
"）；
此程序将vec中的每个元素写到cout，每个元素后加一个空格。每次向out_iter赋值
时，写操作就会被提交。
值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环
可以重写成下面的样子：
out_iter=e；//赋值语句将元素写到cout
361
cout<<endl；
运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的
程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代
器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，406
对于读者来说，此循环的行为也更为清晰。
可以通过调用copy来打印vec中的元素，这比编写循环更为简单：
copy（vec。begin（），vec。end（），out_iter）；
cout<<endl；

Page388
362
407
使用流迭代器处理类类型
我们可以为任何定义了输入运算符（>>）的类型创建istream_iterator对象。类
似的，只要类型有输出运算符（<<），我们就可以为其定义ostream_iterator。由于
Sales_item既有输入运算符也有输出运算符，因此可以使用IO迭代器重写1。6节（第
21页）中的书店程序：
istreamiterator<Salesitem>item_iter（cin），eof；
ostream_iterator<Sales_item>out_iter（cout，"\n"）；
//将第一笔交易记录存在sum中，并读取下一条记录
Sales_itemsum=*item_iter++；
while（itemiter!=eof）{
//如果当前交易记录（存在itemiter中）有着相同的ISBN号
if（itemiter->isbn（）
else{
}
sum+=*itemiter++；
outiter=sum；

sum=
==

*item_iter++；
}
outiter=sum；
sum。isbn（））
第10章泛型算法
//将其加到sum上并读取下一条记录
//输出sum当前值
//读取下一条记录
//记得打印最后一组记录的和
此程序使用
it从cin读取。
es_item交易记录，并将和写入cout，每个结
果后面都跟一个换行符。定义了自己的迭代器后，我们就可以用item_iter读取第一条
交易记录，用它的值来初始化s
sum：
//将第一条交易记录保存在sum中，并读取下一条记录
Sales_itemsum=*item_itex++；
此处，我们对item_iter执行后置递增操作，对结果进行解引用操作。这个表达式读取
下一条交易记录，并用之前保存在item_iter中的值来初始化sum。
while循环会反复执行，直至在cin上遇到文件尾为止。在while循环体中，我们
检查sum与刚刚读入的记录是否对应同一本书。如果两者的ISBN不同，我们将sum赋
予out_iter，这将会打印sum的当前值，并接着打印一个换行符。在打印了前一本书的
交易金额之和后，我们将最近读的交易记副本赋予sum，并递增迭代器，这将读取
下一条交易记录。循环会这样持续下去，直至遇到错误或文件尾。在退出之前，记住要打
印输入中最后一本书的交易金额之和。
10。4。2节练习
练习10。29：编写程序，使用流迭代器读取一个文本文件，存入一个vector中的string
里。
练习10。30：使用流迭代器、sort和copy从标准输入读取一个整数序列，将其排序，
并将结果写到标准输出。
练习10。31：修改前一题的程序，使其只打印不重复的元素。你的程序应使用
unique_copy（参见10。4。1节，第359页）。
练习10。32：重写1。6节（第21页）中的书店程序，使用一个vector保存交易记录，
使用不同算法完成处理。使用sort和10。3。1节（第345页）中的compareIsbn函数
来排序交易记录，然后使用find和accumulate求和。

Page389
10。4再探迭代器
练习10。33：编写程序，接受三个参数：一个输入文件和两个输出文件的文件名。输入
文件保存的应该是整数。使用istream_iterator读取输入文件。使用
ostream_iterator将奇数写入第一个输出文件，每个值之后都跟一个空格。将偶数
写入第二个输出文件，每个值都独占一行。
10。4。3反向迭代器
反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递
增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个
元素；递减一个迭代器（――it）会移动到下一个元素。
除了forward_list之外，其他容器都支持反向迭代器｡我们可以通过调用rbegin、
rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾
元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非
const版本。
图10。1显示了一个名为vec的假设的vector上的4种迭代器：
vec。cbegin（）
vec。cend（）
↓
↓
1
vec。crend（）
vec。crbegin（）
图10。1：比较cbegin/cend和crbegin/crend
下面的循环是一个使用反向迭代器的例子，它按逆序打印vec中的元素：
vector<int>vec={0，1，2，3，4，5，6，7，8，9}；
//从尾元素到首元素的反向迭代器
for（autor_iter=vec。crbegin（）；//将riter绑定到尾元素
r_iter!=vec。crend（）；
++r_iter）
//crend指向首元素之前的位置
//实际是递减，移动到前一个元素
//#TEP9，8，7，。。。0
cout<<*riter<<endl；
虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法
透明地向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector
整理为递减序：
sort（vec。begin（），vec。end（））；//按“正常序”排序vec
//按逆序排序：将最小元素放在vec的末尾
sort（vec。rbegin（），vec。rend（））；
反向迭代器需要递减运算符
不必惊讶，我们只能从既支持++也支持――的迭代器来定义反向迭代器。毕竟反向迭代
器的目的是在序列中反向移动。除了forward_list之外，标准容器上的其他迭代器都
既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流
中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。
反向迭代器和其他迭代器间的关系
假定有一个名为line的string，保存着一个逗号分隔的单词列表，我们希望打印
363
408

Page390
364
409
line中的第一个单词。使用find可以很容易地完成这一任务：
//在一个逗号分隔的列表中查找第一个元素
autocomma=find（line。cbegin（），line。cend（），'，'）；
cout<<string（line。cbegin（），comma）<<endl；
如果line中有逗号，那么comma将指向这个逗号；否则，它将等于line。cend（）。当
我们打印从line。cbegin（）到comma之间的内容时，将打印到逗号为止的字符，或者打
印整个string（如果其中不含逗号的话）。
如果希望打印最后一个单词，可以改用反向迭代器：
//在一个逗号分隔的列表中查找最后一个元素
autorcomma=find（line。crbegin（），line。crend（），
由于我们将crbegin（）和crend（）传递给find，find将从line的最后一个字符开
始向前搜索。当find完成后，如果line中有逗号，则rcomma指向最后一个逗号
即，它指向反向搜索中找到的第一个逗号。如果line中没有逗号，则rcomma指向
line。crend（）。
当我们试图打印找到的单词时，最有意思的部分就来了。看起来下面的代码是显然的
方法
//错误：将逆序输出单词的字符
cout<<string（line。crbegin（），rcomma）<<endl；
但它会生成错误的输出结果。例如，如果我们的输入是
FIRST，MIDDLE，LAST
则这条语句会打印TSAL!
图10。2说明了问题所在：我们使用的是反向迭代器，会反向处理string。因此，上
述输出语句从crbegin开始反向打印line中内容。而我们希望按正常顺序打印从
rcomma开始到line末尾间的字符。但是，我们不能直接使用rcomma。因为它是一个
反向迭代器，意味着它会反向朝着string的开始位置移动。需要做的是，将rcomma转
换回一个普通迭代器，能在line中正向移动。我们通过调用reverse_iterator的
base成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：
//正确：得到一个正向迭代器，从逗号开始读取字符直到line末尾
cout<<string（rcomma。base（），line。cend（））<<endl；
给定和之前一样的输入，这条语句会如我们的预期打印出LAST。
第10章泛型算法
cbegin（）comma
↓
↓
FIRSTMIDDLELAST
"
rcomma。base（）cend（）
，
t
rcommacrbegin（）
图10。2：反向迭代器和普通迭代器间的关系
图10。2中的对象显示了普通迭代器与反向迭代器之间的关系。例如，rcomma和
rcomma。base（）指向不同的元素，line。crbegin和line。cend（）也是如此。这些不同
保证了元素范围无论是正向处理还是反向处理都是相同的。

Page391
10。5泛型算法结构
从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间（参见9。2。1节，第
296页）的特性。关键点在于[line。crbegin（），rcomma）和[rcomma。base（），
line。cend（））指向line中相同的元素范围。为了实现这一点，rcomma和
rcomma。base（）必须生成相邻位置而不是相同位置，crbegin（）和cend（）也是如此。
Note
反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要
的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭
代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。
10。4。3节练习
练习10。34：使用reverseiterator逆序打印一个vector。
练习10。35：使用普通迭代器逆序打印一个vector。
练习10。36：使用find在一个int的list中查找最后一个值为0的元素。
练习10。37：给定一个包含10个元素的vector，将位置3到7之间的元素按逆序拷
贝到一个list中。
10。5泛型算法结构
任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只
要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些
算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分
为5个迭代器类别（iteratorcategory），如表10。5所示。每个算法都会对它的每个迭代器
参数指明须提供哪类迭代器。
输入迭代器
输出迭代器
前向迭代器
双向迭代器
随机访问迭代器
表10。5：迭代器类别
只读，不写；单遍扫描，只能递增
只写，不读；单遍扫描，只能递增
可读写；多遍扫描，只能递增
可读写；多遍扫描，可递增递减
可读写，多遍扫描，支持全部迭代器运算
第二种算法分类的方式（如我们在本章开始所做的）是按照是否读、写或是重排序列
中的元素来分类。附录A按这种分类方法列出了所有算法。
算法还共享一组参数传递规范和一组命名规范，我们在介绍迭代器类别之后将介绍这
些内容。
10。5。15类迭代器
类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只
有特定类别的迭代器才支持。例如，ostream_iterator只支持递增、解引用和赋值。
vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算术运算。
迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代
365
410

Page392
366
411
器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。
C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在
一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace
函数需要一对迭代器，至少是前向迭代器。类似的，replace_copy的前两个迭代器参
数也要求至少是前向迭代器。其第三个迭代器表示目的位置，必须至少是输出迭代器。其
他的例子类似。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法
传递一个能力更差的迭代器会产生错误。
WARNING
第10章泛型算法
对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告
或提示。
迭代器类别
输入迭代器（inputiterator）：可以读取序列中的元素。一个输入迭代器必须支持
•用于比较两个迭代器的相等和不相等运算符（==､!=）
●用于推进迭代器的前置和后置递增运算（++）
•用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧
•箭头运算符（->），等价于（*it）。member，即，解引用迭代器，并提取对象的成
员
输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能
导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下
来并用来访问元素｡因此，输入迭代器只能用于单遍扫描算法｡算法find和accumulate
要求输入迭代器；而istream_iterator是一种输入迭代器。
输出迭代器（outputiterator）：可以看作输入迭代器功能上的补集——只写而不读元素。输
出迭代器必须支持
用于推进迭代器的前置和后置递增运算（++）
●
解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器
赋值，就是将值写入它所指向的元素）
我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算
法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输
出迭代器。ostream_iterator类型也是输出迭代器。
。
前向迭代器（forwarditerator）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。
前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我
们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法
replace要求前向迭代器，forward_list上的迭代器是前向迭代器。
412双向迭代器（bidirectionaliterator）：可以正向/反向读写序列中的元素。除了支持所有前向
迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法reverse要求
双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代
現
随机访问迭代器（random-accessiterator）：提供在常量时间内访问序列中任意元素的能力。
此类迭代器支持双向迭代器的所有功能，此外还支持表3。7（第99页）中的操作：

Page393
10。5泛型算法结构
●用于比较两个迭代器相对位置的关系运算符（<、<=､>和>=）
•迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前
进（或后退）给定整数个元素后的位置
●用于两个迭代器上的减法运算符（-），得到两个迭代器的距离
•下标运算符（iter[n]），与*（iter[n]）等价
算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随
机访问迭代器，用于访问内置数组元素的指针也是。
10。5。1节练习
练习10。38：列出5个迭代器类别，以及每类迭代器所支持的操作。
练习10。39：list上的迭代器属于哪类?vector呢?
练习10。40：你认为copy要求哪类迭代器?reverse和unique呢?
10。5。2算法形参模式
在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有
帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具
有如下4种形式之一：
alg（beg，end，otherargs）；
alg（beg，end，dest，otherargs）；
alg（beg，end，beg2，otherargs）；
alg（beg，end，beg2，end2，otherargs）；
-dest、
其中alg是算法的名字，beg和end表示算法所操作的输入范围。几乎所有算法都接受一
个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种
beg2和end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承413
担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非
迭代器的特定参数。
接受单个目标迭代器的算法
dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定（assume）；按其
需要写入数据，不管写入多少个元素都是安全的。
向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。
367
WARNING
如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的
元素内。更常见的情况是，dest被绑定到一个插入迭代器（参见10。4。1节，第358页）
或是一个ostream_iterator（参见10。4。2节，第359页）。插入迭代器会将新元素添加
到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，
同样不管要写入多少个元素都没有问题。

Page394
368
414
接受第二个输入序列的算法
接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。
这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。
如果一个算法接受beg2和end2，这两个迭代器表示第二个范围。这类算法接受两
个完整指定的范围：[beg，end）表示的范围和[beg2end2）表示的第二个范围。
只接受单独的beg2（不接受end2）的算法将beg2作为第二个输入范围中的首元素。
此范围的结束位置未指定，这些算法假定从beg2开始的范围与beg和end所表示的范
围至少一样大。
WARNING
第10章泛型算法
接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围
至少一样大。
10。5。3算法命名规范
除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个
操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位
置等问题。
一些算法使用重载形式传递一个谓词
接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都
是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额
外谓词参数，来代替<或==：
unique（beg，end）；
//使用运算符比较元素

unique（beg，end，comp）；//使用comp比较元素
==

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==
运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的
函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义（参见6。4节，第208页）。
find（beg，end，val）；
find_if（beg，end，pred）；
_if版本的算法
接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个
谓词（参见10。3。1节，第344页）代替元素值。接受谓词参数的算法都有附加的_if前缀：
//查找输入范围中val第一次出现的位置
//查找第一个令pred为真的元素
这两个算法都在输入范围中查找特定元素第一次出现的位置｡算法find查找一个指定值；
算法find_if查找使得pred返回非零值的元素。
这两个算法提供了命名上差异的版本，而非重载版本，因为两个版本的算法都接受相
同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准
库选择提供不同名字的版本而不是重载。
区分拷贝元素的版本和不拷贝的版本
默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提
供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的

Page395
10。6特定容器算法
算法都在名字后面附加一个_copy（参见10。2。2节，第341页）：
reverse（beg，end）；
//反转输入范围中元素的顺序
reverse_copy（beg，end，dest）；//将元素按逆序拷贝到dest
一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：
//从v1中删除奇数元素
remove_if（v1。begin（），vl。end（），
//将偶数元素从v1拷贝到v2；v1不变
[]（inti）{returni%2；}）；
remove_copy_if（v1。begin（），v1。end（），back_inserter（v2），
[]（inti）{returni%2；}）；
两个算法都调用了lambda（参见10。3。2节，第346页）来确定元素是否为奇数。在第一个
调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（亦即偶数）
元素从输入范围拷贝到v2中。
10。5。3节练习
练习10。41：仅根据算法和参数的名字，描述下面每个标准库算法执行什么操作：
replace（beg，end，old_val，new_val）；
replace_if（beg，end，pred，new_val）；
replace_copy（beg，end，dest，old_val，new_val）；
replace_copy_if（beg，end，dest，pred，new_val）；
10。6特定容器算法
与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算
法，如表10。6所示。特别是，它们定义了独有的sort、merge、remove、reverse和
unique｡通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，
因为这两个类型分别提供双向迭代器和前向迭代器。
链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换
输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速
“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。
Best
对于list和forward_list，应该优先使用成员函数版本的算法而不是通用
Practices算法。
表10。6：list和forward_list成员函数版本的算法
这些操作都返回void
lst。merge（1st2）
1st。merge（1st2，comp）。
lst。remove（val）
lst。remove_if（pred）
lst。reverse（）
将来自1st2的元素合并入lstolst和1st2都必须是有序的。
元素将从1st2中删除。在合并之后，1st2变为空。第一个版
本使用<运算符：第二个版本使用给定的比较操作
调用erase删除掉与给定值相等（==）或令一元谓词为真的每
个元素
反转1st中元素的顺序
369
415

Page396
370
416
lst。sort（）
lst。sort（comp）
lst。unique（）
lst。unique（pred）
使用<或给定比较操作排序元素
（p，1st2，p2）
第10章泛型算法
splice成员
链表类型还定义了splice算法，其描述见表10。7。此算法是链表数据结构所特有的，
因此不需要通用版本。
lst。splice（args）或flst。splice_after（args）
（p，1st2）
（p，1st2，b，e）
调用erase删除同一个值的连续拷贝。第一个版本使用==；第
二个版本使用给定的二元谓词
表10。7：list和forward_list的splice成员函数的参数
续表
p是一个指向1st中元素的迭代器，或一个指向flst首前位
置的迭代器。函数将1st2的所有元素移动到1st中p之前的
位置或是flst中p之后的位置。将元素从1st2中删除。lst2
的类型必须与1st或flst相同，且不能是同一个链表
p2是一个指向1st2中位置的有效的迭代器。将p2指向的元
素移动到1st中，或将p2之后的元素移动到flst中。1st2
可以是与1st或flst相同的链表
b和e必须表示1st2中的合法范围。将给定范围中的元素从
1st2移动到1st或flst。lst2与1st（或flst）可以是相
同的链表，但p不能指向给定范围中元素
链表特有的操作会改变容器
多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版
本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove的链表版本会
删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。
merge
类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列
写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本
会销毁
给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在
merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。
10。6节练习
练习10。42：使用list代替vector重新实现10。2。3节（第343页）中的去除重复单
词的程序。

Page397
小结
小结
标准库定义了大约100个类型无关的对序列进行操作的算法。序列可以是标准库容器
类型中的元素、一个内置数组或者是（例如）通过读写一个流来生成的。算法通过在迭代
器上进行操作来实现类型无关。多数算法接受的前两个参数是一对迭代器，表示一个元素
范围。额外的迭代器参数可能包括一个表示目的位置的输出迭代器，或是表示第二个输入
范围的另一个或另一对迭代器。
根据支持的操作不同，迭代器可分为五类：输入、输出、前向、双向以及随机访问迭
代器。如果一个迭代器支持某个迭代器类别所要求的操作，则属于该类别。
如同迭代器根据操作分类一样，传递给算法的迭代器参数也按照所要求的操作进行分
类。仅读取序列的算法只要求输入迭代器操作。写入数据到目的位置迭代器的算法只要求
输出迭代器操作，依此类推。
算法从不直接改变它们所操作的序列的大小。它们会将元素从一个位置拷贝到另一个
位置，但不会直接添加或删除元素。
（371
虽然算法不能向序列添加元素，但插入迭代器可以做到。一个插入迭代器被绑定到一
个容器上。当我们将一个容器元素类型的值赋予一个插入迭代器时，迭代器会将该值添加
到容器中。
148007
容器forward_list和list对一些通用算法定义了自己特有的版本。与通用算法
不同，这些链表特有版本会修改给定的链表。
术语表
back_inserter这是一个迭代器适配器，它
接受一个指向容器的引用，生成一个插入
迭代器，该插入迭代器用push_back向
指定容器添加元素。
双向迭代器（bidirectionaliterator）支持
前向迭代器的所有操作，还具有用--在序
列中反向移动的能力。
二元谓词（binarypredicate）接受两个参
数的谓词。
bind标准库函数，将一个或多个参数绑定
到一个可调用表达式。bind定义在头文件
functional中。
可调用对象（callableobject）可以出现
在调用运算符左边的对象。函数指针、
lambda以及重载了函数调用运算符的类的
对象都是可调用对象。
捕获列表（capturelist）lambda表达式的
作
一部分，指出lambda表达式可以访问所在
上下文中哪些变量。
cref标准库函数，返回一个可拷贝的对象，
其中保存了一个指向不可拷贝类型的
const对象的引用。
前向迭代器（forwarditerator）可以读写
元素，但不必支持--的迭代器。
front_inserter迭代器适配器，给定一个容
器，生成一个用push_front向容器开始
位置添加元素的插入迭代器。
泛型算法（genericalgorithm）类型无关
的算法。
输入迭代器（inputiterator）可以读但不
能写序列中元素的迭代器。
插入迭代器（insertiterator）迭代器适配
器，生成一个迭代器，该迭代器使用容器
操作向给定容器添加元素。
417
418

Page398
372
插入器（inserter）迭代器适配器，接受
一个迭代器和一个指向容器的引用，生成
一个插入迭代器，该插入迭代器用insert
在给定迭代器指向的元素之前的位置添加
元素。
istream_iterator读取输入流的流迭代
現
命。
迭代器类别（iteratorcategory）根据所支
持的操作对迭代器进行的分类组织。迭代
器类别形成一个层次，其中更强大的类别
支持更弱类别的所有操作。算法使用迭代
器类别来指出迭代器参数必须支持哪些操
只要迭代器达到所要求的最小类别，
它就可以用于算法。例如，一些算法只要
求输入迭代器。这类算法可处理除只满足
输出迭代器要求的迭代器之外的任何迭代
器。而要求随机访问迭代器的算法只能用
于支持随机访问操作的迭代器。
lambda表达式（lambdaexpression）可
调用的代码单元。一个lambda类似一个未
命名的内联函数。一个lambda以一个捕获
列表开始，此列表允许lambda访问所在函
数中的变量。类似函数，lambda有一个（可
能为空的）参数列表、一个返回类型和一
个函数体。lambda可以忽略返回类型。如
果函数体是一个单一的return语句，返
回类型就从返回对象的类型推断。否则，
忽略的返回类型默认定为void。
第10章泛型算法
移动迭代器（moveiterator）迭代器适配
器，生成一个迭代器，该迭代器移动而不
是拷贝元素。移动迭代器将在第13章中进
行介绍。
ostream_iterator写输出流的迭代器。
输出迭代器（outputiterator）可以写元素，
但不必具有读元素能力的迭代器。
谓词（predicate）返回可以转换为bool
类型的值的函数。泛型算法通常用来检测
元素。标准库使用的谓词是一元（接受一
个参数）或二元（接受两个参数）的。
随机访问迭代器（random-accessiterator）
支持双向迭代器的所有操作再加上比较迭
代器值的关系运算符、下标运算符和迭代
器上的算术运算，因此支持随机访问元素。
ref标准库函数，从一个指向不能拷贝的类
型的对象的引用生成一个可拷贝的对象。
反向迭代器（reverseiterator）在序列中
反向移动的迭代器。这些迭代器交换了++
和——的含义。
流迭代器（streamiterator）可以绑定到
一个流的迭代器。
一元谓词（unarypredicate）接受一个参
数的谓词。
