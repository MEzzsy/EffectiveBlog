这一章主要介绍执行期所发生的一些转换。

# 对象的构造和析构

析构函数的调用需要放在对象构造之后且返回之前，因为有多个返回，所以生成的代码可能有多个析构函数调用。

## 全局对象

C++程序中所有的global objects都被放置在程序的data segment中。C++的全局对象会设定初值，而C不自动设定初值。在C语言中一个global object只能够被一个常量表达式（可在编译时期求其值）设定初值。而constructor并不是常量表达式。虽然class object在编译时期可以被放置于data segment中并且内容为 0，但constructor一直要到程序启动时才会实施。必须对一个“放置于 program data segment 中的 object 的初始化表达式”做评估（evaluate），这正是为什么一个
object需要静态初始化的原因。

C++全局对象构造和析构的方案：

1.  为每一个需要静态初始化的文件产生一个_sti()函数，内含必要的constructor调用操作或inline expansions。
2.  类似情况，在每一个需要静态的内存释放操作（static deallocation）的文件中，产生一个_std()函数，内含必要的 destructor 调用操作，或是其 inline expansions。
3.  提供一组runtime library函数：一个`_main()`函数（用以调用可执行文件中的所有`_sti()`函数），以及一个`exit()`函数（以类似方式调用所有的`_std()`函数）。


不同编译器有不同的优化手段，但大致思路是这样的。在我的编译器下，只看看到了初始化操作，而看到析构操作，等汇编能力高了一点之后再看。TODO。

## 局部静态对象

```cpp
const Matrix& identity() {
	static Matrix mat_identity;
	return mat_identity;
}
```

-   mat_identity的constructor必须只能施行一次，虽然上述函数可能会被调用多次。
-   mat_identity的destructor必须只能施行一次，虽然上述函数可能会被调用多次。

只在 identity()被调用时才把mat_identity构造起来，是比较好的做法（现在的C++ Standard 已经强制要求这一点）。

一个做法：

首先，导入一个临时性对象以保护mat_identity的初始化操作。第一次处理identity()时，这个临时对象被评估为false，于是 constructor会被调用，然后临时对象被改为true。这样就解决了构造的问题。
而在相反的那一端， destructor也需要有条件地施行于mat_identity身上，但只有在mat_identity已经被构造起来才算数。要判断mat_identity是否被构造起来，很简单，如果那个临时对象为true，就表示构造好了。

```cpp
/**
 * 测试局部静态函数
 */
class B {
public:
    B() { my_log("B构造函数"); }

    ~B() { my_log("B析构函数"); }
};

class A {
public:
    B& fun(){
        static B b;
        return b;
    }
};

void test1();
```

```cpp
void runtime::test() {
    if (NEED_TEST) {
        my_log("----执行期语意学----start------");

        test1();

        my_log("----执行期语意学----end--------");
    }
}

void runtime::test1() {
    A a;
    a.fun();
}
```

```
----执行期语意学----start------
B构造函数
----执行期语意学----end--------
B析构函数
```

```
//这是当注释掉fun函数调用的结果
----执行期语意学----start------
----执行期语意学----end--------
```

## 对象数组

```cpp
/**
 * 测试对象数组
 */
class C {
public:
    C() { my_log("C构造函数"); }

    ~C() { my_log("C析构函数"); }
};
```

```cpp
void runtime::test2() {
    C array[2];
}

C构造函数
C构造函数
C析构函数
C析构函数
```

```cpp
void runtime::test2() {
    C *new_array = new C[2];
}

C构造函数
C构造函数
```

```cpp
void runtime::test2() {
    C *new_array = new C[2];
    delete [] new_array;
}

C构造函数
C构造函数
C析构函数
C析构函数
```

从Demo里可以看出，C++的对象数组和Java的不太一样，定义之后便会初始化所有的对象，而Java的对象数组声明之后，内容是空的。

cfront的做法是用一些runtime library函数。如，创建数组的函数：

```cpp
void* vec_new ( 
	void *array,
    size_t elem_size,
    int elem_count,
	void (*constructor) (void*),
	void (*destructor) (void*,char)
) {}
```

>   C++标准规定不能获取构造函数的指针，这里的构造函数指针是从编译器的角度获取的。

其中的constructor和destructor参数是这一class之default constructor和default destructor的函数指针。

这里取函数地址获取的是默认构造函数，无参数的构造函数，如果存在只有多参数的构造函数且全部具有默认值，这种情况见下。

## Default Constructors和数组

```cpp
class A {
public:
    A(int aa = 0) {
        a = aa;
    };
    int a;
};
```

>   个人验证，只有一个构造函数且没有默认值，反汇编发现有2个构造函数。加上默认值，还是只有2个。

如果类只有多参数的构造函数且每个参数具有默认值，这时取默认函数地址是获取不到的，但是在语法上这是可行。所以cfront的一个做法是这样的：

cfront所采用的方法是产生一个内部的stub constructor，没有参数。在其函数内调用由程序员提供的constructor，并将default参数值显式地指定过去。

然而，编译器自己违反了一个明显的语言规则：class如今支持了两个没有带参数的constructors。当然，只有当class objects数组真正被产生出来时，stub实例オ会被产生以及被使用。

# new和delete运算符

运算符new的使用，看起来似乎是个单一运算，像这样：
int*pi
=newint（5）;
但事实上它是由两个步骤完成的：
1.通过适当的new运算符函数实例，配置所需的内存：
1/调用函数库中的new运算符
int*pi=
new（sizeof（int））;

2.将配置得来的对象设立初值：
*pi
=5;
更进一步地说，初始化操作应该在内存配置成功（经由new运算符）后才
执行：
1/new运算符的两个分离步骤
//given：int*pi=
newint（5）;
1/重写声明
int*pi;
if（pi
new（sizeof（int）））
//译注：成功了才初始化
*pi
5;
%3D
delete运算符的情况类似。当程序员写下：
deletepi;
时，如果pi的值是0，C++语言会要求delete运算符不要有操作。因此编译器必须
为此调用构造一层保护膜：
if（pi!=0）
delete（pi）;
请注意pi并不会因此被自动清除为0，因此像这样的后继行为：
254


Page288
第6章执行期语意学
1/喔欧：没有良好的定义，但是合法
if（pi&&*pi==5）...
虽然没有良好的定义，但是可能（也可能不）被评估为真。这是因为对于pi所指
向之内存的变更或再使用，可能（也可能不）会发生。
pi所指对象的生命会因delete而结束。所以后继任何对pi的参考操作就不再
保证有良好的行为，并因此被视为是一种不好的程序风格。然而，把pi继续当做
一个指针来用，仍然是可以的（虽然其使用受到限制），例如：
1/ok：pi仍然指向合法空间
1/甚至即使存储于其中的object已经不再合法
if（pi
==sentinel）
...
在这里，使用指针pi，和使用pi所指的对象，其差别在于哪一个的生命已经
结束了。虽然该地址上的对象不再合法，地址本身却仍然代表一个合法的程序空间。
因此pi能够继续被使用，但只能在受限制的情况下，很像一个void*指针的情况。
以constructor来配置一个classobject，情况类似。例如：
Point3d*origin
newPoint3d;
被转换为：
Point3d*origin;
//C++伪码
if（origin
new（sizeof（Point3d）））
Point3d：：Point3d（origin）;
%3D
origin
如果实现出exceptionhandling，那么转换结果可能会更复杂些：
1/C++伪码
if（origin
new（sizeof（Point3d）））{
try{
origin
=Point3d：：Point3d（origin）;
}
catch（..
）{
255


Page289
深度探索C++对象模型（InsideTheC++ObjectModel）
//Wdeletelibraryfunctionl
1/释放因new而配置的内存
delete（origin）;
1/将原来的exception上传
throw;
}
在这里，如果以new运算符配置object，而其constructor抛出一个exception，
配置得来的内存就会被释放掉。然后exception再被抛出去（上传）。
Destructor的应用极为类似。下面的式子：
deleteorigin;
会变成：
if（origin!=0）{
1/C++伪码
Point3d：：-Point3d（origin）;
delete（origin）;
一
如果在exceptionhandling的情况下，destructor应该被放在一个try区段中。
exceptionhandler会调用delete运算符，然后再一次抛出该exception。
一般的library对于new运算符的实现操作都很直截了当，但有两个精巧之处
值得斟酌（请注意，以下版本并未考虑exceptionhandling）：
externvoid*
operatornew（size_tsize）
{
if（size==0）
size=1;
void*lastalloc;
ile（!（lastalloc=malloc（size）））
{
if（
newhandler）
256


Page290
第6章执行期语意学
newhandler）（）;
else
return0;
一
returnlast_alloc;
}
虽然这样写是合法的：
newT[0）;
但语言要求每一次对new的调用都必须传回一个独一无二的指针。解决此问题的传
统方法是传回一个指针，指向一个默认为1-byte的内存区块（这就是为什么程序代、
码中的size被设为1的原因）。这个实现技术的另一个有趣之处是，它允许使用者
提供一个属于自己的_new_handler）函数。这正是为什么每一次循环都调用
_new_handler（）Z.
new运算符实际上总是以标准的Cmalloc0完成，虽然并没有规定一定得这么
做不可。相同情况，delete运算符也总是以标准的Cfree0完成：
externvoid
operatordelete（void*ptr）
{
if（ptr）
free（（char*）ptr）;
针对数组的new语意
当我们这么写：
int*p_array
newint[5];
时，vec_new0不会真正被调用，因为它的主要功能是把defaultconstructor施行于
classobjects所组成的数组的每一个元素身上。倒是new运算符函数会被调用：
int*parray=
（int*）
new（5*sizeof（int））;
257


Page291
深度探索C++对象模型（InsideTheC++ObjectModel）
相同情况，如果我们写：
//structsimple_aggr{floatf1，f2;};
newsimple_aggr[5];
simple_aggr*p_aggr=
vec_new0也不会被调用。为什么?simple_aggr并没有定义一个constructor或
destructor，所以配置数组以及清除P_aggr数组的操作，只是单纯地获得内存和释
放内存而已。这些操作由new和delete运算符来完成就绰绰有余了。
然而如果class定义了一个defaultconstructor，某些版本的vec_new0就会被调
用，配置并构造classobjects所组成的数组。例如这个算式：
Point3d*p_array=newPoint3d[10];
通常会被编译为：
Point3d*p_array;
p_array=vec_new（0，sizeof（Point3d），10，
&Point3d：：Point3d，
&Point3d：：-Point3d）;
还记得吗，在个别的数组元素构造过程中，如果发生exception，destructor就
会被传递给vec_new0。只有已经构造妥当的元素才需要destructor的施行，因为它
们的内存已经被配置出来了，vec_new0有责任在exception发生的时机把那些内存
释放掉。
在C+2.0版之前，将数组的真正大小提供给程序的delete运算符，是程序员
的责任。因此如果我们原先写下：
intarray_size
Point3d*p_array=newPoint3d[array_size];
=10;
那么我们就必须对应地写下：
delete[array_size]p_array;
258


Page292
第6章执行期语意学
在2.1版中，这个语言有了一些修改，程序员不再需要在delete时指定数组元
素的个数，因此我们现在可以这样写：
delete[]P_array;
然而为了回溯兼容，两种形式都可以接受。支持此种新形式的第一个编译器当
然就是cfront，由JonathanShopiro完成任务。这项技术支持需要知道的首先是指
针所指的内存空间，然后是其中的元素个数。
寻找数组维度，对于delete运算符的效率带来极大的冲击，所以才导致这样的
妥协：只有在中括号出现时，编译器才寻找数组的维度，否则它便假设只有单独一
个objects要被删除。如果程序员没有提供必须的中括号，像这样：
deletep_array;
1/喔欧
那么就只有第一个元素会被析构。其他的元素仍然存在一虽然其相关的内存已经
被要求归还了。
各家编译器之间存在一个有趣的差异，那就是元素个数如果被显式指定，是否
会被拿去利用。在Jonathan的原始版本中，他优先采用使用者（程序员）显式指定
的值。下面是他所写的原始码的虚拟版本（pseudo-version），附带注释：
1/首先检查是否最后一个被配置的项目
1/是目前要被delete的项目。
cache_key）
//
1/如果是，就不需要做搜寻操作了
//如果不是，就寻找元素个数。
intelem_count
?（（_cache_key
：//取出元素个数
cache_key
pointer

%3D
==

cache_cout）
1/numelem：元素个数，将传递给vec_new（）。
//对于配置于heap中的数组，只有面对以下形式，才会设定一个值：
//delete[10]ptr;
//否则cfront会传-1以表示取出。
if（numelem==-1）
//preferexplicitusersizeifchoice!
numelem=ans;
259


Page293
深度探索C++对象模型（InsideTheC++ObjectModel）
然而几乎新近所有的C++编译器都不考虑程序员的显式指定（如果有的话）：
x.c"，line3：warning（467）
deletearraysizeexpressionignored（anachronism）
foo（）{delete[12]pi;}
为什么Jonathan优先采用程序员所指定的值，而新近的编译器却不这么做呢?
因为此一性质刚被导入的时候，没有任何程序代码会不“显式指定数组大小”。时
代演化到cfront4.0的今天，我们已经把此习惯贴上“落伍”的标记，并且产生一
个类似的警告消息。
应该如何记录元素个数?一个明显的方法就是为vec_newO所传回的每一个内
存区块配置一个额外的word，然后把元素个数包藏在那个word之中。通常这种被
包藏的数值称为所谓的cookie（小甜饼）。然而，Jonathan和Sun编译器决定维护
一个“联合数组（associativearray）”，放置指针及大小。Sun也把destructor的地
址维护于此数组之中，请看[CLAM93]。
cookie策略有一个普遍引起忧虑的话题就是，如果一个坏指针应该被交给
delete_vec），取出来的cookie自然是不合法的。一个不合法的元素个数和一个坏
的起始地址，会导致destructor以非预期的次数被施行于一段非预期的区域。然
而在“联合数组”的政策之下，坏指针的可能结果就只是取出错误的元素个数而
己。
在原始编译器中，有两个主要函数用来存储和取出所谓的cookie：
7/array_key是新数组的地址
//mustn'teitherbe0oralreadyentered
//elemcountisthecount;itmaybe0
typedefvoid*PV;
externint
insert_new_array（PVarraykey，intelemcount）;
1/从表格中取出（并去除）array_key
260


Page294
第6章执行期语意学
//若不是传回elem_count，就是传回-1
externint
remove_old_array（PVarray_key）;
下面是cfront中的vec_new0原始内容经过修润后的一份呈现，并附加注释：
PV
vecnew（PVptr_array，intelem_count，
intsize，PVconstruct）
{
7/如果ptr_array是0，从heap之中配置数组。
1/如果ptr_array不是0，表示程序员写的是：
//
Tarray[count]
//E
//
new（ptr_array）T[10];
intalloc
=0;
//我们要在vec_new中配置吗?
intarray_sz
elem_count*size;
if（alloc
1/全局运算符new
ptr_array
0）
%3!
ptr_array=PV（newchar[array_sz]）;
//EexceptionhandlingZF，
//*exceptionbad_alloc

if（ptr_array
==

return0;
1/把数组元素个数放到cache中
intstatus
insert_new_array（ptr_array，elem_count）;
%3D
if（status==-1）{
//ÉexceptionhandlingF%exception
//*exceptionbad_alloc
if（alloc）
deleteptr_array;
return0;
if（construct）{
registerchar*elem=
（char*）ptr_array;
registerchar*lim
elem+array_sz;
%3D
1/PF是一个typedef，代表一个函数指针
PF（constructor）;
registerPFfp
I3!
while（elem<lim）{
//通过fp调用constructor作用于
1/'this'元素上（由elem指出）
261


Page295
深度探索C++对象模型（InsideTheC++ObjectModel）
（*fp）（（void*）elem）;
1/前进到下一个元素
elem+=size;
一
returnPV（ptr_array）;
一
vec_deleteO的操作差不多，但其行为并不总是C++程序员所预期或需求的。例
如，已知下面两个class声明：
classPoint{
public：
Point（）;
virtual-Point（）;
//
};
classPoint3d：publicPoint{
public：
Point3d（）;
virtual~Point3d（）;
//
};
如果我们配置一个数组，内含10个Point3dobjects，我们会预期Point和Point3d
的constructor被调用各10次，每次作用于数组中的一个元素：
//完全不是个好主意
Point*ptr=newPoint3d[10）;
而当我们delete“由ptr所指向的10个Point3d元素”时，会发生什么事情?
很明显，我们需要虚拟机制的帮助，以获得预期的Pointdestructor和Point3d
destructor各10次的调用（每一次作用于数组中的一个元素）：
//喔欧：这并不是我们所要的
//只有Point：：~Point被调用…
delete[]ptr;
262


Page296
第6章执行期语意学
施行于数组上的destructor，如我们所见，是根据交给vec_delete）函数的“被
删除之指针类型的destructor”一本例中正是Pointdestructor。这很明显并非我们
所希望。此外，每一个元素的大小也一并被传递过去。这就是vec_delete（）如何迭
代走过每一个数组元素的方式。本例中被传递过去的是Pointclassobject的大小而
不是Point3dclassobject的大小。整个运作过程非常不幸地失败了，不只是因为执
行了错误的destructor，而且自从第一个元素之后，该destructor即被施行于不正确
的内存区块中（译注：因为元素的大小不对）。
程序员应该怎么做才好?最好就是避免以一个baseclass指针指向一个
derivedclassobjectsTtderivedclassobjectEbaseA
（译注：通常如此）。如果你真的一定得这样写程序，解决之道在于程序员层面，
而非语言层面：
for（intix
0;ix<elem_count;++ix）
%3D
{
Point3d*p
=&（（Point3d*）ptr）[ix];
1/译注：原书为Point*p=
deletep;
//
恐为笔误
}
基本上，程序员必须迭代走过整个数组，把delete运算符实施于每一个元素身
上。以此方式，调用操作将是virtual，因此，Point3d和Point的destructor都会施
行于数组中的每一个objects身上。
PlacementOperatornew89
有一个预先定义好的重载的（overloaded）new运算符，称为placementoperator
new。它需要第二个参数，类型为void*。调用方式如下：
Point2w*ptw
new（arena）Point2w;
其中arena指向内存中的一个区块，用以放置新产生出来的Point2wobject。
这个预先定义好的placementoperatornew的实现方法简直是出乎意料的平凡。
它只要将“获得的指针（译注：上例的arena）”所指的地址传回即可：
263


Page297
深度探索C++对象模型（InsideTheC++ObjectModel）
void*
operatornew（size_t，void*p）
{
returnp;
如果它的作用只是传回其第二个参数，那么它有什么价值呢?也就是说，为什
么不简单地这么写算了（这不就是实际所发生的操作吗）：
Point2w*ptw
（Point2w*）arena;
%3D
唔，事实上这只是所发生的操作的一半而已。另外一半无法由程序员产生出来。
想想这些问题：
1.什么是使placementnewoperator能够有效运行的另一半扩充（而且是
'arena的显式指定操作（explicitassignment）”所没有提供的）?
2.什么是arena指针的真正类型?该类型型暗示了什么?
Placementnewoperator所扩充的另一半是将Point2wconstructor自动实施于
arena所指的地址上：
7/C++伪码
Point2w*ptw
（Point2w*）arena;
%3D
if（ptw!=0）
ptw->Point2w：：Point2w（）;
这正是使placementoperatornew威力如此强大的原因。这一份代码决定
objects被放置在哪里;编译系统保证object的constructor会施行于其上。
然而却有一个轻微的不良行为。你看得出来吗?下面是一个有问题的程序片
段：
//让arena成为全局性定义
voidfooBar（）{
Point2w*p2w
=new（arena）Point2w;
//
doit...
..
//
nowmanipulateanewobject
p2w
new
（arena）Point2w;
264


Page298
第6章执行期语意学
如果placementoperator在原已存在的一个object上构造新的object，而该既存
的object有个destructor，这个destructor并不会被调用。调用该destructor的方法
之一是将那个指针delete掉。不过在此例中如果你像下面这样做，绝对是个错误：
1/以下并不是实施destructor的正确方法
deletep2w;
p2w
=new（arena）Point2w;
是的，delete运算符会发生作用，这的确是我们所期待的。但是它也会释放由
p2w所指的内存，这却不是我们所希望的，因为下一个指令就要用到p2w了。因此，
我们应该显式地调用destructor并保留存储空间以便再使用1：
1/施行destructor的正确方法
p2w->~Point2w;
p2w
=new（arena）Point2w;
剩下的唯一问题是一个设计上的问题：在我们的例子中对placementoperator
的第一次调用，会将新object构造于原已存在的object之上吗?还是会构造于全新
地址上?也就是说，如果我们这样写：
Point2w*p2w
new（arena）Point2w;
我们如何知道arena所指的这块区域是否需要先析构?这个问题在语言层面上
并没有解答。一个合理的习俗是令执行new的这一端也要负起执行destructor的
责任。
另一个问题关系到arena所表现的真正指针类型。C++Standard说它必须指向
相同类型的class，要不就是一块“新鲜”内存，足够容纳该类型型的obiject。注意，
1
StandardC++以一个placementoperatordelete矫正了这个错误，它会对object实施destructor，
但不释放内存。所以就不必再直接调用destructor了。
265


Page299
深度探索C++对象模型（InsideTheC++ObjectModel）
derivedclass很明显并不在被支持之列。对于一个derivedclass，或是其他没有关联
的类型，其行为虽然并非不合法，却也未经定义。
“新鲜”的存储空间可以这样配置而来：
char*arena
=newchar[sizeof（Point2w）1;
相同类型的object则可以这样获得：
Point2w*arena=
newPoint2w;
不论哪一种情况，新的Point2w的存储空间的确是覆盖了arena的位置，而此
行为已在良好控制之下。然而，一般而言，placementnewoperator并不支持多态
（polymorphism）。被交给new的指针，应该适当地指向一块预先配置好的内存。
tuderivedclassELbaseclass*，BI：
Point2w*p2w
=new（arena）Point3w;
Point3w的constructor将会导致严重的破坏。
Placementnewoperator被引入C++2.0时，最晦涩隐暗的问题就是下面这个由
JonathanShopiro提出的问题：
structBase{intj;virtualvoidf（）;};
structDerived：
Base{voidf（）;};
voidfooBar（）{
Baseb;
b.f（）;
//Base：：f（）被调用
b.-Base（）;
new（&b）Derived;//1
b.f（）;
//哪一个f（）被调用?
由于上述两个classes有相同的大小，把derivedobject放在为baseclass而配置
的内存中是安全的。然而，欲支持这一点，或许必须放弃对于“经由objects静态
调用所有virtualfunctions（像是b.f0）”通常都会有的优化处理。结果，placement
266


Page300
第6章执行期语意学
newoperator的这种使用方式在StandardC++中未能获得支持（请看C++Standard
3.8节）。于是上述程序的行为没有明确定义：我们不能够斩钉截铁地说哪一个f0
函数实例会被调用。尽管大部分使用者可能以为调用的是Derived：f0，但大部分编
译器调用的却是Base：f0。
6.3
临时性对象（TemporaryObjects）
如果我们有一个函数，形式式如下：
Toperator+（constT&，constT&）;
以及两个Tobjects，a和b，那么：
a+b;
可能会导致一个临时性对象，以放置传回的对象。是否会导致一个临时性对象，视
编译器的进取性（aggressiveness）以及上述操作发生时的程序语境（programcontext）
而定。例如下面这个片段：
та，b;
TC=a+b;
编译器会产生一个临时性对象，放置a+b的结果，然后再使用T的copyconstructor，
把该临时性对象当做c的初始值。然而比较更可能的转换是直接以拷贝构造的方
式，将atb的值放到c中（2.3节对于加法运算符的转换曾有讨论），于是就不需
要临时性对象，以及对其constructor和destructor的调用了。
此外，视operator+（）的定义而定，namedreturmvalue（NRV）优化（请看2.3
节）也可能实施起来。这将导致直接在上述c对象中求表达式结果，避免执行copy
constructorF（namedobject）destructor.
三种方式所获得的c对象，结果都一样。其间的差异在于初始化的成本。一个
编译器可能给我们任何保证吗?严格地说是没有。C++Standard允许编译器对于临
267


Page301
深度探索C++对象模型（InsideTheC++ObjectModel）
时性对象的产生有完全的自由度：
在某些环境下，由processor产生临时性对象是有必要的，或是比较方便的。
如此的临时性对象由编译器来定义（C++Standard，12.2节）。
理论上，C++Standard允许编译器厂商有完全的自由度。但实际上，由于市场
的竞争，几乎保证任何表达式（expression）如果有这种形式：
TC=a+b;
而其中的加法运算符被定义为：
Toperator+（constT&，constT&）;
或
TT：：operator+（constT&）;
那么实现时根本不产生一个临时性对象。
然而请你注意，意义相当的assignment叙述句（statement）：
C=a+b;
不能够忽略临时性对象。反而，它会导致下面的结果：
1/C++伪码
//Ttemp=a+b;
Ttemp;
temp.operator+（a，b）;//（1）：a.operator+（temp，b）;!
//c=temp
c.operator=（temp）;
//（2）
temp.T：：T（）;
标示为（1）的那一行，未构造的临时对象被赋值给operator+（）。这意思是不是
“表达式的结果被copyconstructed至临时对象中”，就是“以临时对象取代NRV”。
在后者中，原本要施行于NRV的constructor，现在将施行于此临时对象。
268


Page302
第6章执行期语意学
不管是哪一种情况，直接传递c（上例赋值操作的目标对象）到运算符函数中
都是有问题的。由于运算符函数并不为其外加参数调用一个destructor（它期望一
块“新鲜的”内存），所以必须在此调用之前先调用destructor。然而，“转换”
语意将被用来将下面的assignment操作：
c=a+b;//c.operator=（a+b）;
取代为其copyassignment运算符的隐式调用操作，以及一系列的destructor和copy
construction：
//C++伪码
c.T：：~T（）;
c.T：：T（a+b）;
copyconstructor，destructorDXcopyassignmentoperatorJAaaaaas
所以不能够保证上述两个操作会导致相同的语意。因此以一连串的destruction和
copyconstruction来取代assignment一般而言是不安全的，而且会产生临时对象。
所以这样的初始化操作：
TC=a+b;
总是比下面的操作更有效率地被编译器转换：
C=a+b;
第三种运算形式是，没有出现目标对象：
a+b;
//notarget
这时候有必要产生一个临时对象以放置运算后的结果。虽然看起来有点怪异，
但这种情况实际上在子表达式（subexpressions）中十分普遍，例如，如果我们这样
写：
Strings（"hello"），t（"world"），u（"!"）;
那么不论：
269


Page303
深度探索C++对象模型（InsideTheC++ObjectModel）
Stringv;
v=s+t+u;
或
printf（"%s\n"，s+t）;
都会导致产生一个临时对象，与s十1相关联。
最后一个表达式带来一些秘教式的论题，那就是“临时对象的生命期”。这个
论题颇值得深入探讨。在StandardC++之前，临时对象的生命（也就是说它的
destructor何时实施）并没有显式指定，而是由编译厂商自行决定。换句话说，上
述的printf0并不保证安全，因为它的正确性和s+t何时被摧毁有关。
（本例的一个可能性是，Stringclass定义了一个cor
ersion运算符如下：
String：：operatorconstchar*（）{return
str;}
**str-privatememberaddressingstorage，EStringobjectI，
在其destructor中被释放。）
因此如果临时对象在调用printf0之前就被摧毀了，经由convertion运算符交给
它的地址就是不合法的。真正的结果视底部的delete运算符在释放内存时的进取性
而定。某些编译器可能会把这块内存标示为free，不以任何方式改变其内容。在这
块内存被其他地方宣称“主权”之前，只要它还没有被deleted掉，它就可以被使
用。虽然对于软件工程而言这不足以作为模范，但像这样，在内存被释放之后又再
被使用，并非罕见。事实上malloc（的许多编译器会提供一个特殊的调用操作：
malloc（0）;
它正是用来保证上述行为的。
例如，下面是对于该算式的一个可能的pre-Standard转换。虽然在pre-Standard
语言定义中是合法的，却可能造成重大灾难：
270


Page304
第6章执行期语意学
1/C++伪码：pre-standard的合法转换
//临时性对象被摧毀得太快（太早）了。
Stringtemp1=operator+（s，t）;
constchar*temp2=
templ.operatorconstchar*（）;
1/喔欧：合法但是有欠考虑，太过轻率。
templ.~String（）;
1/这时候并未定义temp2指向何方
printf（"%s\n"，temp2）;
另一种（比较被喜欢的）转换方式是在调用printf0之后实施Stringdestructor。
在C++Standard之下，这正是该表达式的必须转换方式。标准规格上这么说：
临时性对象的被推毁，应该是对完整表达式（full-expression）求值过程中的最
后一个步骤。该完整表达式造成临时对象的产生（Section12.2）
什么是一个完整表达式（full-expression）?非正式地说，它是被涵括的表达式
中最外围的那个。下面这个式子：
//tertiaryfullexpressionwith5sub-expressions
（（objA>1024）
?objA+objB：foo（objA，objB）;
&&（objB>1024））
一共有五个子算式（subexpressions），内含在一个“?：完整表达式”中。任何一个
子表达式所产生的任何一个临时对象，都应该在完整表达式被求值完成后，才可以
毁去。
当临时性对象是根据程序的执行期语意，有条件地被产生出来时，临时性对象
的生命规则就显得有些复杂了。举个例子，像这样的表达式：
if（s+t||u+v）
其中的utv子算式只有在stt被评估为false时，才会开始被评估。与第二个子算
271


Page305
深度探索C++对象模型型（InsideTheC++ObjectModel）
式有关的临时性对象必须被摧毁，但是，很明显地，不可以被无条件地摧毁。也就
是说，我们希望只有在临时性对象被产生出来的情况下，才去摧毁它。
在讨论临时对象的生命规则之前，标准编译器将临时对象的构造和析构附着于
第二个子算式的评估程序。例如，对于以下的class声明：
classX{
public：
X（）;
-X（）;
operatorint（）;
Xfoo（）;
private：
intval;
};
以及对于classX的两个objects的条件测试：
main（）{
XxX;
Xyy;
if（xx.foo（）||yy.foo（））
return0;
}
cfront对于main）产生出以下的转换结果（已经过轻微的修润和注释）：
intmain（void）
一
structX
1xx;
structX
_lyy：
int
0result;
//namemangleddefaultconstructor：
//X：X（X*this）
1xFv（&
1XFV（&
ct
1xx）;
ct
1yy）;
{
272


Page306
第6章执行期语意学
1/被产生出来的临时性对象
0_Q1;
Q2B
structX
structX
int
0Q3B
/*每一端变成一个附逗点的表达式，
有着下列顺序：

*tempQ1
=xx.foo（）;
*tempQ3
tempQ1.operatorint（）;
*tempQ1.X：：~X（）;
*tempQ3;
*/
opi
if（（（（
//
1xFv==>X：：operatorint（）
Q3
opi
1XFV（（（
%3D
Q1=
foo
1xFv（&
Q1）））），
1xx）），（&0
Q3）
dt
1xFv（&0
Q1，2）），
||（（（
Q3
opi
1xFv（（（
1yy）），（&
Q2，2）），_0__Q3））
Q2
foo
1xFv（&
Q2）））），
dt
1XFV（&
{
0result=0;
1yу，2）;
1хх，2）;
dt1xFv（&
dt1xFv（&
}
return
0result;
}
}
把临时性对象的destructor放在每一个子算式的求值过程中，可以免除“努力
追踪第二个子算式是否真的需要被评估”。然而在C++Standard的临时对象生命规
则中，这样的策略不再被允许。临时性对象在完整表达式尚未评估完全之前，不得
被摧毁。也就是说某些形式的条件测试现在必须被安插进来，以决定是否要摧毀和
第二算式有关的临时对象。
临时性对象的生命规则有两个例外。第一个例外发生在表达式被用来初始化一
个object时。例如：
273


Page307
深度探索C++对象模型（InsideTheC++ObjectModel）
boolverbose;
StringprogNameVersion
%3D
!verbose
?0
：progName+progVersion;
其中progName和progVersion都是Stringobjects。这时候会生出一个临时对象，
放置加法运算符的运算结果：
Stringoperator+（constString&，constString&）;
临时对象必须根据对verbose的测试结果，有条件地析构。在临时对象的生命
规则之下，它应该在完整的“?：表达式”结束评估之后尽快被摧毁。然而，如果
progNameVersion的初始化需要调用一个copyconstructor：
1/C++伪码
progNameVersion.String：：String（temp）;
那么临时性对象的析构（在“?：完整表达式”之后）当然就不是我们所期望的。
C++Standard要求说：
……凡持有表达式执行结果的临时性对象，应该存留到object的初始化操作完
...
成为止。
甚至即使每一个人都坚守C++Standard中的临时对象生命规则，程序员还是
有可能让一个临时对象在他们的控制中被摧毁。其间的主要差异在于这时候的行为
有明确的定义。例如，在新的临时对象生命规则中，下面这个初始化操作保证失败：
1/喔欧：不是个好主意
constchar*progNameVersion
%3D
progName+progVersion;
其中progName和progVersion都是Stringobjects。产生出来的程序代码看起来
像这样：
274


Page308
第6章执行期语意学
//C++pseudoCode
Stringtemp;
operator+（temp，progName，progVersion）;
progNameVersion=
temp.String：：operatorchar*（）;
temp.String：：-String（）;
此刻progNameVersion指向未定义的heap内存!
临时性对象的生命规则的第二个例外是“当一个临时性对象被一个reference
绑定”时，例如：
constString&space
%3D
";
产生出像这样的程序代码：
//C++pseudoCode
Stringtemp;
temp.String：：String（
constString&space=temp;
%3D
"）;
很明显，如果临时性对象现在被推毁，那个reference也就差不多没什么用了。
所以规则上说：
如果一个临时性对象被绑定于一个reference，对象将残留，直到被初始化之
reference的生命结束，或直到临时对象的生命范畴（scope）结束一一视哪一种情
况先到达而定。
临时性对象的迷思（神话、传说）
有一种说法是，由于目前的C++编译器会产生临时性对象，导致程序的执行比
较低效，因此在工程界或科学界，C++只能成为FORTRAN以外可怜的第二选择。
更有人认为，这种效率上的不彰足以掩盖C++在“抽象化”上的贡献（例如
[BUDGE92]。相反的论点则请参考[NACK94]）。发表于TheJournalofCLanguage
上的[BUDGE94]对此有过一份有趣的研究。
275


Page309
深度探索C++对象模型（InsideTheC++ObjectModel）
在FORTRAN-77和C++的一场比较之中，KentBudge和其助手分别以两种语
言写了一个复数测试程序（在FORTRAN中复数是内建类型;在C++中它是一个
具体类，有两个members，一个代表实数，一个代表虚数。StandardC+已经把复
数类放在标准链接库中）。C++程序实现inline运算符如下：
friendcomplexoperator+（complex，complex）;
请注意，被传递的classobjects（内含有constructors和destructors）是以byvalue
而非byreference的方式传递，像这样：
friendcomplexoperator+（constcomplex&，constcomplex&）;
一般而言并非是一种好的C++程序风格。除了“copybyvaluepossiblylargeclass
objects”这个主题之外，每一个正式参数的局部实例都被copyconstructed和
destructed，并且可能导致临时对象的诞生。在这个测试实例中，作者声称把正式
参数转换为constreference并不会明显改变效率。这只是因为每一个函数是inline
之故。
测试程序看起来像这样：
voidfunc（complex*a，constcomplex*b，
constcomplex*c，intN）
{
for（inti=0;i<N;i++）
a[i]
b[i]+c[i]
b[i]*c[i];
%3D
}
其中对于复数的加法、减法、乘法和assignment运算符，都是inline函数。C++
代码产生出五个临时对象：
1.一个临时对象，用来放置b[i]+c[i]。
2.一个临时对象，用来放置b[i]*c[i]。
3.一个临时对象，用来放置上述两个临时对象的相减结果。

4.两个临时对象，分别用来放置上述第一个临时对象和第二个临时对象，
276


Page310
第6章执行期语意学
为的是完成第三个临时对象。
测试结果发现，FORTRAN-77的代码果然快达两倍。他们的第一个假设是把
责任归咎于临时对象。为了验证，他们以手工方式，把cfront中介输出码中的所有
临时对象一一消除。一如预期，效率增加了两倍，几乎和FORTRAN-77相当。
测试并没有就此停下来，Budge和其助手以另一个方法来实验。这一次他们采
用反聚合（disaggregated）手法。也就是说他们把那些临时对象拆开为一对一对的
临时性double变量。结果发现，这种做法对于效率的提升，和先前“消除所有临
时对象”一样。于是他们写下这样的心得：
我们所测试的编译系统很明显能够消除内建（build-in）类型的局部变量，但
对于class类型的局部变量就行不通。这是C++back-ends（而不是C++front-end）
的限制。这似乎是很普遍的情况，因为在SunCC、GNUg++以及HPCC等编译器
中都会发生。[BUDGE94]
这篇文章分析了被产生出来的assembly代码，并表示效率降低的原因是由于
程序中大量的堆栈存取操作（以读写个别的classmembers）。经过反聚合
（disaggregated），并将个别的members放到寄存器中，就能够达到几乎两倍的效
率。这使他们写下这样的结论：
加上适度的努力，反聚合（disaggregation）大有可为。但是一般的C++编译器
并没有把它视为一个重要的优化关键。
这份研究对于良好的优化提供了一个具有说服力的证明。目前存在有一些优化
工具，的确把临时对象的一些成分放进了寄存器中。当编译器厂商把他们的焦点从
语言特性的支持（与StandardC++比较）移转到实现技术的优劣上时，如反聚合
（disaggregation）这般的优化操作就会更普遍了。
277


Page311


Page312
第7章站在对象模型的尖端
第7章
站在对象模型的尖端
（OntheCuspoftheObjectModel）
译注：本章大量沿用两个原文词汇：instantiate（动词）和instantiation（名词）。
你不容易在一般的字典上查到这两个词。《牛津计算机词典》上对于instantiation
的解释是：

1.Thecreationofaparticularinstanceofanobjectclass，genericunit，ortemplate.
2.Theapplicationofaparameterizedabstractdatatypetoaparticularsetof
parameters.
在本章中应采用第一个解释。有些时候我会把instantiation译为“实例化”或
实现：“具体实现出一个实例（instance）”的意思。
这一章我要讨论三个著名的C++语言扩充性质，它们都会影响C++对象。它们
HAtemplate，exceptionhandling（EH）#lruntimetypeidentification（RTTI）.
EH（以及RTTI-一可想象成是EH的一个副作用）对于这本书所谈到的其他语言性
质而言，算是一个特例，因为我没有机会真正实现它。我的讨论，是以[CHASE94]、
[LAJOIE94a]、[LAJOIE945]、[LENKOV92]以及[SUN94a]为基础的。
279


Page313
深度探索C++对象模型（InsideTheC++ObjectModel）
7.1
Template
C++程序设计的风格及习惯，自从1991年的cfront3.0引入templates之后就深
深地改变了。原本template被视为是对containerclasses如Lists和Arrays的一项支
持，但现在它已经成为标准模板库（也就是StandardTemplateLibrary，STL）的基
础。它也被用于属性混合（如内存配置策略，[BOOCH93]）或互斥（mutualexclusion）
机制（使用于线程同步化控制）的参数化技术之中。它甚至被使用于一项所谓的
templatemetaprograms*：classexpressiontemplates*Eaaaae
评估（evaluated），因而带来重大的效率提升（请参考[VELD95]）。
然而，如果我说，template是最令程序员挫败的一个主题，恐怕也是真的。错
误消息可能远在真正问题的十万八千里处就产生了，编译时间提高了不少，而程序
员开始极端害怕修改一个内有多重相依关系的.H文件，特别是如果他正在和“臭
虫”奋战的时候。程序大小像气球一样地膨胀也是常有的事。而且template的所有
行为都超越了一般程序人员的理解能力，那些人但求能够完成手上的工作就好。如
果上述问题持续存在，他们可能会认为template是一个障碍而不是一个助力。你很
容易看到一个被称为template专家的人，被一群项目成员团团围住，要求解决问题
并将产生出来的template优化。
这一节的焦点放在template的语意上面，我们将讨论templates在编译系统中
“何时”、“为什么”以及“如何”发挥其功能。下面是有关template的三个主要
讨论方向：

1.template的声明。基本来说就是当你声明一个templateclass、templateclass
memberfunction等等时，会发生什么事情。
（instantiates）
classobject，inlinenonmemberRmember
templatefunctions。这些是“每一个编译单位都会拥有一份实例”的东西。
280


Page314
第7章站在对象模型的尖端
3.如何“实例化（instantiates）
nonmember，membertemplatefunctions
以及statictemplateclassmembers。这些都是“每一个可执行文件中只需
要一份实例”的东西。这也就是一般而言template所带来的问题。
我使用“实例化”（instantiation）这个字眼来表示“进程（process）将真正的
类型和表达式绑定到template相关形式参数（formalparameters）上头”的操作。
举个例子，下面是一个templatefunction：
template<classType>
Туре
min（constType&t1，constType&t2）{
...}
用法如下：
min（1.0，2.0）;
于是进程就把Type绑定为double并产生min）的一个程序文字实例（并适
当施以“mangling”手术，给它一个独一无二的名称），其中11和12的类型都
是double。
TemplateBJ“Ht"f5J（TemplateInstantiation）
考虑下面的templatePointclass：
template<classType>
classPoint
{
public：
enumStatus{unallocated，normalized};
Point（Typex=0.0，Typey=0.0，Typez=
-Point（）;
0.0）;
void*operatornew（size_t）;
voidoperatordelete（void*，size_t）;
281


Page315
深度探索C++对象模型（InsideTheC++ObjectModel）
//...
private：
staticPoint<Type>*freeList;
staticintchunkSize;
Туре_х，_у，_z;
};
首先，当编译器看到templateclass声明时，它会做出什么反应?在实际程序
中，什么反应也没有!也就是说，上述的staticdatamembers并不可用。nestedenum
或其enumerators也一样。
虽然enumStatus的真正类型在所有的Pointinstantiations中都一样，其
enumerators也是，但它们每一个都只能够通过templatePointclass的某个实例来存
取或操作。因此我们可以这样写：
//ok：
Point<float>：：Statuss;
但不能这样写：
//error：
Point：：Statuss;
即使两种类型抽象地来说是一样的（而且，最理想的情况下，我们希望这个
enum只有一个实例被产生出来。如果不是这样，我们可能会想要把这个enum抽
出到一个nontemplatebaseclass中，以避免多份拷贝）。
同样道理，freeList和chunkSize对程序而言也还不可用。我们不能够写：
//error：
Point：：freeList;
我们必须显式地指定类型，才能使用freeList：
//ok：
Point<float
：：freeList;
282


Page316
第7章站在对象模型的尖端
像上面这样使用staticmember，会使其一份实例与Pointclass的float
instantiation在程序中产生关联。如果我们写：
1/ok：另一个实例（instance）
Point<double>：：freeList;
就会出现第二个freeList实例，与Pointclass的doubleinstantiation产生关联。
如果我们定义一个指针，指向特定的实例，像这样：
Point<float>*ptr=0;
再一次，程序中什么也没有发生。为什么呢?因为一个指向classobject的指针，
本身并不是一个classobject，编译器不需要知道与该class有关的任何members的
数据或object布局数据。所以将“Point的一个float实例”实例化也就没有必要了。
在C++Standard完成之前，“声明一个指针指向某个templateclass”这件事情并未
被强制定义，编译器可以自行决定要或不要将template“实例化”。cfront就是这
么做的（这使得某些程序员大感困窘）!如今C++Standard已经禁止编译器这么做。
如果不是pointer而是reference，又如何?假设：
constPoint<float>&ref=0;
是的，它真的会实例化一个“Point的float实例”。这个定义的真正语意会被扩展
为：
//内部扩展
Point<float>temporary（float（0））;
constPoint<float>&ref
temporary;
%3D
为什么?因为reference并不是无物（noobject）的代名词。0被视为整数，必
须被转换为以下类型的一个对象：
Point<float>
283


Page317
深度探索C++对象模型（InsideTheC++ObjectModel）
如果没有转换的可能，这个定义就是错误的，会在编译时被挑出来。
所以，一个classobject的定义，不论是由编译器暗中地做（像稍早程序代码
中出现过的temporary），或是由程序员像下面这样显式地做：
constPoint<float>origin;
都会导致templateclass的“实例化”，也就是说，floatinstantiation的真正对象布
局会被产生出来。回顾先前的template声明，我们看到Point有三个nonstatic
members，每一个的类型型都是7ype。Type现在被绑定为float，所以origin的配置空
间必须足够容纳三个float成员。
然而，memberfunctions（至少对于那些未被使用过的）不应该被“实例化”。
只有在memberfunctions被使用的时候，C++Standardオ要求它们被“实例化”。
目前的编译器并不精确遵循这项要求。之所以由使用者来主导“实例化”
（instantiation）规则，有两个主要原因：
1.空间和时间效率的考。如果class中有100个memberfunctions，但你
的程序只针对某个类型使用其中两个，针对另一个类型使用其中五个，
那么将其他193个函数都“实例化”将会花费大量的时间和空间。

2.尚未实现的机能。并不是一个template实例化的所有类型就一定能够完
：符。如果只“实例化”
那些真正用到的memberfunctions，template就能够支持那些原本可能会
整支持一组memberfunctions所需要的所有
造成编译时期错误的类型型（types）。
举个例子，origin的定义需要调用Point的defaultconstructor和destructor，那
么只有这两个函数需要被“实例化”。类似的道理，当程序员写：
Point<float>*p
newPoint<float>;
时，只有（1）Pointtemplate的float实例、（2）new运算符、（3）defaultconstructor
需要被“实例化”。有趣的是，虽然new运算符是这个class的一个implicitlystatic
member，以至于它不能够直接处理其任何一个nonstaticmembers，但它还是依赖真
284


Page318
第7章站在对象模型的尖端
正的template参数类型，因为它的第一参数size_t代表class的大小。
这些函数在什么时候“实例化”?目前流行两种策略：
|在编译的时候。那么函数将“实例化”于origin和p存在的那个文件中。
|在链接的时候。那么编译器会被一些辅助工具重新激活。template函数实
例可能被放在这一文件中、别的文件中或一个分离的存储位置。
稍后的小节将对函数的“实例化”做更详细的讨论。
[CARGILL95]曾经提到有趣的一点，在“int和long一致”（或“double和long
double一致”）的架构之中，两个类型实例化操作：
Point<int>pi;
Point<long>pl;
应该产生一个还是两个实例呢?目前我知道的所有编译器都产生两个实例（可能有
两组完整的memberfunctions）
C++Standard并未对此有什么强制规定。
TemplateBJRs（ErrorReportingwithinaTemplate）
考虑下面的template声明：
（1）
template<classT>
（2）
classMumble
（3）
{
（4）
public$：
（5）
Mumble（Tt=1024）
（6）
：t（t）
（7）
{
（8）
if（tt!=t）
（9）
throwexex;
（10）
}
（11）private：
（12）
Ttt;
（13）
}
这个Mumbletemplateclass的声明内含一些既露骨又潜沉的错误：
285


Page319
深度探索C++对象模型（InsideTheC++ObjectModel）

1.L4：使用$字符是不对的。这项错误有两方面。第一，%$并不是一个可以
合法用于标识符的字符;第二，class声明中只允许有public、protected、
private三个标签（labels），$的出现使public$不成为public。第一点是
语汇（lexical）上的错误，第二点则是造句/解析（syntactic/parsing）上
的错误。
2.L5：t被初始化为整数常量1024，或许可以，也或许不可以，视T的真
实类型而定。一般而言，只有template的各个实例才诊断得出来。
3.L6：1并不是哪一个member的名称，t才是。这种错误一般会在“类型
检验”这个阶段被找出来。是的，每一个名称必须绑定于一个定义身上，
要不就会产生错误。
4.L8：!=运算符可能已定义好，但也可能还没有，视T的真正类型而定。
和第二点一样，只有template的各个实例才诊断得出来。
5.L9：我们意外地键入ex两次。这个错误会在编译时期的解析（parsing）
阶段被发现。C++语言中一个合法的句子不允许一个标识符紧跟在另一
个标识符之后。
6.L13：我们忘记以一个分号作为class声明的结束。这项错误也会在编译
时期的语句分析（parsing）阶段被发现。
在一个nontemplateclass声明中，这6个既露骨又潜沉的错误会被编译器挑出
来。但templateclass却不同。举个例子，所有与类型有关的检验，如果牵涉到
template参数，都必须延迟到真正的实例化操作（instantiation）发生，オ得为之。也
就是说，LS和L8的潜在错误（上述2、4两项）会在每个实例化操作（instantiation）
发生时被检查出来并记录之，其结果将因不同的实际类型而不同。于是如果：
Mumble<int>mi;
则LS和L8是正确的，而如果：
Mumble<int*>pmi;
286


Page320
第7章站在对象模型的尖端
那么L8正确而LS错误，因为你不能够将一个整数常量（除了0）指定给一个指针。
面对这样的声明：
classSmallInt
public：
SmallInt（int）;
//...
一
由于其!=运算符并未定义，所以下面的句子：
Mumble<SmallInt>smi;
会造成L8错误，而LS正确。当然，下面的例子：
Mumble<SmallInt*>psmi;
又造成L8正确而LS错误。
那么，什么样的错误会在编译器处理template声明时被标示出来?这有一部分
和template的处理策略有关。cfront对template的处理是完全解析（parse）但不做
类型检验;只有在每一个实例化操作（instantiation）发生时才做类型检验。所以在
一个parsing策略之下，所有语汇（lexing）错误和解析（parsing）错误都会在处理
template声明的过程中被标示出来。
语汇分析器（lexicalanalyzer）会在L4捕捉到一个不合法的字符，解析器
（parser）会这样标示它：
public$：//caught
表示这是一个不合法的标签（label）。解析器（parser）不会把“对一个未命名的
member做出参考操作”视为错误：
_t（t）//notcaught
287


Page321
深度探索C++对象模型（InsideTheC++ObjectModel）
但它会抓出L9“ex出现两次”以及L13“缺少一个分号”这两种错误。
在一个十分普遍的替代策略中（例如[BALL92a]中所记录），template的声明
被收集成为一系列的“lexicaltokens”，而parsing操作延迟直到真正有实例化操作
（instantiation）发生时才开始。每当看到一个instantiation发生，这组token就被推
往parser，然后调用类型检验，等等。面对先前出现的那个template声明，“lexical
tokenizing”会指出什么错误吗?事实上很少，只有L4所使用的不合法字符会被指
出。其余的template声明都被解析为合法的tokens并被收集起来。
目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只
能施行以有限的错误检查。template中那些与语法无关的错误，程序员可能认为十
分明显，编译器却让它通过了，只有在特定实例被定义之后，才会发出抱怨。这是
目前实现技术上的一个大问题。
NonmemberFlmembertemplatefunctions#511ŁI（instantiation）EŻ
前也一样没有做到完全的类型型检验。这导致某些十分露骨的template错误声明竟然
得以通过编译。例如下面的template声明：
template<classtype>
classFoo
{
public：
Foo（）;
typeval（）;
voidval（typev）;
private：
type
val;
};
不论是cfront或Sun编译器，还是Borland编译器，都不会对以下程序代码产生怨
言：
288


Page322
第7章站在对象模型的尖端
1/目前各家编译器都不会显示出以下定义的语句合法而语意错误：
（a）bogusmemberTEclass-memberfunction
（b）dbx不是class的一个datamember
//
//
template<classtype>
doubleFoo<type>：：bogus_member（）{returnthis->dbx;}
再说一次，这是编译器设计者自己的决定。Templatefacility并没有说不允许对
template声明的类型部分有更严酷的检验。当然，像这样的错误是可以被发现并标
示出来的，只不过是没有人去做罢了。
Template8JZa（NameResolutionwithinaTemplate）
你必须能够区分以下两种意义。一种是C++Standard所谓的“scopeofthe
templatedefinition”，也就是“定义出template"的程序端。另一种是C++Standard
所谓的“scopeofthetemplateinstantiation"，也就是“实例化template”的程序
端。第一种情况举例如下：
//scopeofthetemplatedefinition
externdoublefoo（double）;
template<classtype>
classScopeRules
{
public：
voidinvariant（）{
member=foo（
val）;
}
typetype_dependent（）{
returnfoo（
member）;
}
//
private：
int
val;
type_member;
};
第二种情况举例如下：
//scopeofthetemplateinstantiation
289


Page323
深度探索C++对象模型（InsideTheC++ObjectModel）
externintfoo（int）;
//...
ScopeRules<int>sr0;
EScopeRulestemplatefoo0.E“scopeoftemplatedefinition"
中，只有一个foo0函数声明位于scope之内。然而在“scopeoftemplateinstantiation"
中，两个foo0函数声明都位于scope之内。如果我们有一个函数调用操作：
//scopeofthetemplateinstantiation
sr0.invariant（）;
那么，在invariant0中调用的究竟是哪一个foo0函数实例呢?
1/调用的是哪一个foo（）函数实例?
member=foo（
val）;
在调用操作的那一点上，程序中的两个函数实例是：
//scopeofthetemplatedeclaration
externdoublefoo（double）;
//scopeofthetemplateinstantiation
externintfoo（int）;
而_val的类型是int。那么你认为选中的是哪一个呢?（提示：除了瞎猜之外，唯
一能够正确回答的办法，就是知道正确答案@）。结果，被选中的是直觉以外的那
一个：
//scopeofthetemplatedeclaration
externdoublefoo（double）;
Template之中，对于一个nonmembername的决议结果，是根据这个name的
使用是否与“用以实例化该template的参数类型型”有关而决定的。如果其使用互不
相关，那么就以“scopeofthetemplatedeclaration”来决定name。如果其使用互有
关联，那么就以“scopeofthetemplateinstantiation”来决定name。在第一个例子
290


Page324
第7章站在对象模型的尖端
中，foo0与用以实例化ScopeRules的参数类型无关：
//theresolutionoffoo（）isnot
//dependentonthetemplateargument
member
foo（
val）;
%3D
这是因为_val的类型是int;_val是一个“类型不会变动”的templateclass
member。也就是说，被用来实例化这个template的真正类型，对于_val的类型并
没有影响。此外，函数的决议结果只和函数的原型（signature）有关，和函数的返
回值没有关系。因此_member的类型并不会影响哪一个foo0实例被选中。foo0的
调用与template参数毫无关系!所以调用操作必须根据“scopeofthetemplate
declaration”来决议。在此scope中，只有一个foo0候选者（注意，这种行为不能
够以一个简单的宏扩展一一像是使用一个#define宏一重现之）。
让我们另外看看“与类型相关”（type-dependent）的用法：
sr0.type_dependent（）;
这个函数的内容如下：
returnfoo（
member）;
它究竟会调用哪一个foo0呢?
这个例子很清楚地与template参数有关，因为该参数将决定_member的真正类
型。所以这一次foo0必须在“scopeofthetemplateinstantiation”中决议，本例中这
个scope有两个foo0函数声明。由于_member的类型在本例中为int，所以应该是
int版的foo0出线。如果ScopeRules以double类型实例化，那么就应该是double
版的foo0出线。如果ScopeRules是以unsignedint或long类型实例化化，那么foo0
调用操作就暖味不明。最后，如果ScopeRules以某一个class类型实例化，而该class
没有针对int或double实现出convertion运算符，那么foo0调用操作会被标示为错
291


Page325
深度探索C++对象模型（InsideTheC++ObjectModel）
误。不管如何演变，都是由“scopeofthetemplateinstantiation”来决定，而不是由
"scopeofthetemplatedeclaration"AE.
这意味着一个编译器必须保持两个scopecontexts：

1.“scopeofthetemplatedeclaration"，#Dtemplateclass.
2.
"scopeofthetemplateinstantiation"
用以专注于特定的实例。
编译器的决议（resolution）算法必须决定哪一个才是适当的scope，然后在其
中搜寻适当的name。
MemberFunctionBIT15）ŁIJMemberFunctionInstantiation）
对于template的支持，最因难的莫过于templatefunction的实例化
（instantiation）。目前的编译器提供了两个策略：一个是编译时期策略，程序代码
必须在programtextfile中备妥可用;另一个是链接时期策略，有一些
meta-compilation工具可以导引编译器的实例化行为（instantiation）。
下面是编译器设计者必须回答的三个主要问题：
1.编译器如何找出函数的定义?
答案之一是包含templateprogramtextfile，就好像它是一个header文件一样。
Borland编译器就遵循这个策略。另一种方法是要求一个文件命名规则，例如，我
们可以要求，在Point.h文件中发现的函数声明，其templateprogramtext一定要放
置于文件Point.C或Point.cpp中，依此类推。cfront就遵循这个策略。EdisonDesign
Group编译器对这两种策略都支持。
2.编译器如何能够只实例化程序中用到的memberfunctions?
解决办法之一就是，根本忽略这项要求，把一个已经实例化的class的所有
memberfunctions都产生出来。Borland就是这么做的一一虽然它也提供#pragmas
292


Page326
第7章站在对象模型的尖端
让你压制（或实例化）特定实例。另一种策略就是模拟链接操作，检测看看哪一个
函数真正需要，然后只为它（们）产生实例。cfront就是这么做的。EdisonDesign
Group编译器对这两种策略都支持。
3.编译器如何阻止memberdefinitions在多个.o文件中都被实例化呢?
解决办法之一就是产生多个实例，然后从链接器中提供支持，只留下其中一个
实例，其余都忽略。另一个办法就是由使用者来导引“模拟链接阶段”的实例化策
略，决定哪些实例（instances）才是所需求的。
目前，不论是编译时期还是链接时期的实例化（instantiation）策略，均存在以
下弱点：当template实例被产生出来时，有时候会大量增加编译时间。很显然，这
将是templatefunctions第一次实例化时的必要条件。然而当那些函数被非必要地再
次实例化，或是当“决定那些函数是否需要再实例化”所花的代价太大时，编译器
的表现令人失望!
C++支持template的原始意图可以想见是一个由使用者导引的自动实例化机制
（use-directedautomaticinstantiationmechanism），Eaaa，E
要相同文件有多次的实例化行为。但是这已被证明是非常难以达成的任务，比任何
人此刻所能想象的还要难（请参考[STROUP94]）。ptlink，随着cfront3.0版所附
的原始实例化工具，提供了一个由使用者驱动的自动实例化机制（use-driven
automaticinstantiationmechanism），但它实在太复杂了，即使是久经世故的人也没
法一下子了解。
EdisonDesignGroup开发出一套第二代的directed-instantiation机制，非常接近
于（我所知的）templatefacility原始含义。它主要运作如下：
1.一个程序的原始码被编译时，最初并不会产生任何“template实例化”。
然而，相关信息已经被产生于objectfiles之中。
2.当objectfiles被链接在一块儿时，会有一个prelinker程序被执行起来。
它会检查objectfiles，寻找template实例的相互参考以及对应的定义。
293


Page327
深度探索C++对象模型（InsideTheC++ObjectModel）

3.对于每一个“参考到template实例”而“该实例却没有定义”的情况，
prelinker将该文件视为与另一个实例化（在其中，实例已经实例化）等
同。以这种方法，就可以将必要的程序实例化操作指定给特定的文件。
这些都会注册在prelinker所产生的.i文件中（放在磁盘目录ii_file）。
4.prelinker重新执行编译器，重新编译每一个“.ii文件曾被改变过”的文
件。这个过程不断重复，直到所有必要的实例化操作都已完成。
5.所有的objectfiles被链接成一个可执行文件。
这种directed-instantiation体制的主要成本在于，程序第一次被编译时的.ii文件
设定时间。次要成本则是必须针对每一个“compileafterwards”执行prelinker，以
确保所有被参考到的templates都存在着定义。在最初的设定以及成功地第一次链
接之后，重新编译操作包含以下程序：
5.对于每一个将被重新编译的programtextfile，编译器检查其对应的.ii文
件。
2.如果对应的.ii文件列出一组要被实例化（instantiated）的templates，那
些templates（而且也只有那些templates）会在此次编译时被实例化。
6.prelinker必须执行起来，确保所有被参考到的templates已经被定义妥当。
以我的观点，出现某种形式的automatedtemplate机制，是“对程序员友善的
C++编译系统”的一个必要组件。虽然大家也公认，目前没有任何一个系统是完美
的。作为一个程序开发者，我不会使用（也不会推荐）一个没有此种机制的编译系
统。
不幸的是，没有任何一个机制是没有bugs的。EdisonDesignGroup的编译器
使用了一个由cfront2.0引入的算法[KOENIG90a]，针对程序中的每一个class自动
产生virtualtable的单一实例（在大部分情况下）。例如下面的class声明：
294


Page328
第7章站在对象模型的尖端
classPrimitiveObject：publicGeometry
一
public：
virtual-PrimitiveObject（）;
virtualvoiddraw（）;
};
如果它被含入于15个或45个程序源码中，编译器如何能够确保只有一个
virtualtable实例被产生出来呢?产生15份或45份实例倒还容易些!
AndyKoenig以下面的方法解决这个问题：每一个virtualfunction的地址都被
放置于activeclasses的virtualtable中1。如果取得函数地址，表示virtualfunction
的定义必定出现在程序的某个地点：否则程序就无法链接成功。此外，此函数只能
有一个实例，否则也是链接不成功。那么，就把virtualtable放在定义了该class之
第一个non-inline、nonpurevirtualfunction的文件中吧。以我们的例子而言，编译
器会将virtualtable产生在存储着virtualdestructor的文件之中。
不幸的是，在template之中，这种单一定义并不一定为真。在template所支持
的“将模块中的每一样东西都编译”的模型下，不只是多个定义可能被产生，而且
链接器也放任让多个定义同时出现，它只要选择其中一个而将其余都忽略，也就是
了。
好吧，真是有趣，但EdisonDesignGroup的automaticinstantiation机制做什么
事呢?考虑下面这个library函数：
voidfoo（constPoint<float>*ptr）
{
ptr->virtualfunc（）;
virtualfunctioncall被转换为类似这样的东西：
1
C++Standard已经放松了对这一点的要求。
295


Page329
深度探索C++对象模型（InsideTheC++ObjectModel）
7/C++伪码
//ptr->virtualfunc（）;
（*ptr->
vtbl
Point<float>[2]）（ptr）;
于是导致实例化（instantiated）Pointclass的一个float实例及其virtualfunc（）。
由于每一个virtualfunction的地址被放置于table之中，如果virtualtable被产生出
来，每一个virtualfunction也都必须被实例化（instantiated）。这就是为什么C++
Standard有下面的文字说明的缘故：
如果一个virtualfunction被实例化（instantiated），其实例化点紧跟在其class
的实例化点之后。
然而，如果编译器遵循cfront的virtualtable实现体制，那么在“Point的float
实例有一个virtualdestructor定义被实例化”之前，这个table不会被产生。除非，
在这一点上，并没有显式使用virtualdestructor以担保其实例化行为（instantiation）。
EdisonDesignGroup的automatictemplate机制并不明白它自己的编译器对于
第一个non-inline、nonpurevirtualfunction的隐式使用，所以并没有把它标示于.ii
文件中。结果，链接器反而回头抱怨下面这个符号没有出现：
vtbl
Point<float>
并拒绝产生一个可执行文件。噢，真是麻烦!Automaticinstantiation在此失效!程
序员必须显式地强迫将destructor实例化。目前的编译系统以#pragma指令来支
持此需求。然而C+Standard也已经扩充了对template的支持，允许程序员显式地
要求在一个文件中将整个classtemplate实例化：
templateclassPoint3d<float>;
或是针对一个templateclass的个别memberfunction：
templatefloatPoint3d<float>：：X（）const;
296


Page330
第7章站在对象模型的尖端
或是针对一个个别templatefunction：
templatePoint3d<float>operator+（
constPoint3d<float>&，constPoint3d<float>&）;
实际上，templateinstantiation似乎拒绝全面自动化。甚至虽然每一件工作都做
对了，产生出来的objectfiles的重新编译成本仍然可能太高一一如果程序十分巨大
的话!以手动方式先在个别的objectmodule中完成预先实例化操作
（pre-instantiation），虽然沉问，却是唯一有效率的方法。
7.2
异常处理（ExceptionHandling）
欲支持exceptionhandling，编译器的主要工作就是找出catch子句，以处理
被抛出来的exception。这多少需要追踪程序堆栈中的每一个函数的目前作用区域
（包括追踪函数中localclassobjects当时的情况）。同时，编译器必须提供某种查
询exceptionobjects的方法，以知道其实际类型（这直接导致某种形式的执行期类
型识别，也就是RTTI）。最后，还需要某种机制用以管理被抛出的object，包括
它的产生、存储、可能的析构（如果有相关的destructor）、清理（cleanup）以及
一般存取。也可能有一个以上的objects同时起作用。一般而言，exceptionhandling
机制需要与编译器所产生的数据结构以及执行期的一个exceptionlibrary紧密合作。
在程序大小和执行速度之间，编译器必须有所块择：
|为了维护执行速度，编译器可以在编译时期建立起用于支持的数据结构。
这会使程序的大小发生膨服，但编译器可以几乎忽略这些结构，直到有
个exception被抛出来。
■为了维护程序大小，编译器可以在执行期建立起用于支持的数据结构。
这会影响程序的执行速度，但意味着编译器只有在必要的时候才建立那些
数据结构（并且可以抛弃之）。
根据[CHASE94]所言，Modula-3Report竟然将一个原本为了维护执行速度而
偏好的做法变成了一个制度，它赞成“在exceptionalcase上花费10000个指令，
297


Page331
深度探索C++对象模型（InsideTheC++ObjectModel）
以节省正常情况中的一个指令”。但这样的交易并非永远畅行无碍。最近在TelAviv
的一场研讨会中，我与ShayBushinsky交谈，他是“Junior”项目的开发者。“Junior”
是一个国际象棋程序，在1994年冬季的全球计算机国际象棋程序大赛中与IBM的
深蓝（DeepBlue）得分相同，并列第三。令人惊讶的是，这个程序在一部Pentium
个人计算机上运行（DeepBlue则使用了256颗CPU）。他告诉我当他们在并有
exceptionhandling的Borland编译器上重新编译“Junior”之后，程序虽然没有任
何改变，内存却不够用了。结果，他们只好回头找一套旧版的Borland编译器。
对于“Junior”而言，它并不需要一个体积庞大但是没有增加多少攻击能力的新
版本。
过去还有一种错误的看法，认为由于exceptionhandling的出现才导致cfront
的灭绝，因为不可能提供一个既可接受而又强固的exceptionhandling机制，却没
有支持程序代码产生器（和链接器）。UNIXSoftwareLaboratory（USL）当初搁置
IEHP#H*iexceptionhandlingC-generatingimplementation*#¬EZA
（请看[LENKOV92]）。USL最后终于一致赞成取消掉cfront4.0（及任何更高版本）
的开发计划。
ExceptionHandling快速检阅
C++的exceptionhandling由三个主要的语汇组件构成：
1.一个throw子句。它在程序某处发出一个exception。被抛出去的
exception可以是内建类型型，也可以是使用者自定类型。
2.一个或多个catch子句。每一个catch子句都是一个exceptionhandler.
它用来表示说，这个子句准备处理某种类型的exception，并且在封闭的
大括号区段中提供实际的处理程序。
3.一个try区段。它被围绕以一系列的叙述句（statements），这些叙述句
可能会引发catch子句起作用。
当一个exception被抛出去时，控制权会从函数调用中被释放出来，并寻找一
298


Page332
第7章站在对象模型的尖端
个吻合的catch子句。如果都没有吻合者，那么默认的处理例程terminate0会被调
用。当控制权被放弃后，堆栈中的每一个函数调用也就被推离（poppedup）。这
个程序称为unwindingthestack.在每一个函数被推离堆栈之前，函数的
localclassobjectsdestructorAa.
Exceptionhandling中比较不那么直觉的就是它对于那些似乎没什么事做的函
数所带来的冲击。例如下面这个函数：
#0001
Point*
#0002
mumble（）
#0003
{
#0004
Point*pt1，*pt2;
#0005
ptl=foo（）;
if（!pt1）
#0006
#0007
return0;
#0008
#0009
Pointp;
#0010
#0011
pt2
=foo（）;
#0012
if（!pt2）
#0013
returnpt1;
#0014
#0015
#0016
如果有一个exception在第一次调用foo0（LS）时被抛出，那么这个mumble（）
函数会被推出程序堆栈。由于调用foo0的操作并不在一个try区段之内，也就不需
要尝试和一个catch子句吻合。这里也没有任何localclassobjects需要析构。然而
如果有一个exception在第二次调用foo0（L11）时被抛出，exceptionhandling机制
就必须在“从程序堆栈中“unwinding”这个函数”之前，先调用p的destructor。
在exceptionhandling之下，L4~L8和L9~L16被视为两块语意不同的区域，因
为当exception被抛出来时，这两块区域有不同的执行期语意。而且，欲支持
exceptionhandling，需要额外的一些“簿记”操作与数据。编译器的做法有两种：
299


Page333
深度探索C++对象模型（InsideTheC++ObjectModel）
一种是把两块区域以个别的“将被摧毁之localobjects”链表（已在编译时期设妥）
联合起来;另一种做法是让两块区域共享同一个链表，该链表会在执行期扩大或
缩小。
在程序员层面，exceptionhandling也改变了函数在资源管理上的语意。例如，
下面的函数中含有对一块共享内存的locking和unlocking操作，虽然看起来和
exceptions没有什么关系，但在exceptionhandling之下并不保证能够正确运行：
void
mumble（void*arena）
{
Point*p=newPoint;
smLock（arena）;
//functioncall
//如果有一个exception在此发生，问题就来了
//...
smUnLock（arena）;
//functioncall
deletep;
一
本例之中，exceptionhandling机制把整个函数视为单一区域，不需要操心“将
函数从程序堆栈中‘unwinding"
的事情。然而从语意上来说，在函数被推出堆
栈之前，我们需要unlock共享内存，并deletep。让函数成为“exceptionproof"的
最明确（但不是最有效率）方法就是安插一个defaultcatch子句，像这样：
void
mumble（void*arena）
{
Point*p;
p=newPoint;
try{
smLock（arena）;
//...
一
）{
smUnLock（arena）;
catch（
..
deletep;
throw;
300


Page334
第7章站在对象模型的尖端
smUnLock（arena）;
deletep;
一
这个函数现在有了两个区域：

1.tryblock以外的区域，在那里，exceptionhandling机制除了“pop”程序
堆栈之外，没有其他事情要做。
2.tryblock以内的区域（以及它所联合的defaultcatch子句）。
请注意，new运算符的调用并非在try区段内。这是我的错误吗?如果new运
算符或是Pointconstructor在配置内存之后发生一个exception，那么内存既不会被
unlocking，p也不会被delete（这两个操作都在catch区段内）。这是正确的语意吗?
是的，它是。如果new运算符抛出一个exception，那么就不需要配置heap中
的内存，Pointconstructor也不需要被调用。所以也就没有理由调用delete运算符。
然而如果是在Pointconstructor中发生exception，此时内存已配置完成，那么Point
之中任何建构好的合成物或子对象（subobject，也就是一个memberclassobject或
baseclassobject）都将自动被析构掉，然后heap内存也会被释放掉。不论哪种情况，
都不需要调用delete运算符。
类似的道理，如果一个exception是在new运算符执行过程中被抛出的，arena
пew
所指向的内存就绝不会被locked，因此，也没有必要unlock之。
处理这些资源管理问题，我的一个建议办法就是，将资源需求封装于一个class
object体内，并由destructor来释放资源（然而如果资源必须被索求、被释放、再
被索求、再被释放……许多次的时候，这种风格会变得有点累赞）：
301


Page335
深度探索C++对象模型（InsideTheC++ObjectModel）
void
mumble（void*arena）
{
auto_ptr<Point>ph（newPoint）;
SMLocksm（arena）;
//如果这里抛出一个exception，现在就没有问题了
//...
1/不需要显式地unlock和delete
//localdestructorsEia
//sm.SMLock：：~SMLock（）;
//ph.auto_ptr<Point>：：~auto_ptr<Point>（）
一
从exceptionhandling的角度看，这个函数现在有三个区段：

1.第一区段是auto_ptr被定义之处。
2.第二区段是SMLOC被定义之处。
3.上述两个定义之后的整个函数。
如果exception是在auto_ptrconstructor中被抛出的，那么就没有activelocal
objects需要被EH机制摧毁。然而如果SMLockconstructor中抛出一个exception，
auto_ptrobject必须在“unwinding”之前先被摧毁。至于在第三个区段中，两个local
objects当然都必须被摧毁。
*#EH，ARmemberclasssubobjectsbaseclasssubobjects（#H
它们也都有constructors）的classes的constructor更复杂。一个class如果被部分构
造，其destructor必须只施行于那些已被构造的subobjects和（或）memberobjects
身上。例如，假设classX有memberobjectsA，B和C，都各有一对constructor和
destructor，如果A的constructor抛出一个exception，不论A、B或C都不需要调
用其destructor。如果B的constructor抛出一个exception，A的destructor必须被调
用，但C不用。处理所有这些意外事故，是编译器的责任。
302


Page336
第7章站在对象模型的尖端
同样的道理，如果程序员写下：
//classPoint3d：publicPoint2d{...
};
Point3d*cvs=
newPoint3d[512];
会发生两件事：

1.从heap中配置足以给512个Point3dobjects所用的内存。
2.如果成功，先是Point2dconstructor，然后是Point3dconstructor，会施行
于每一个元素身上。
如果#27元素的Point3dconstructor抛出一个exception，会怎样?对于#27元素，
只有Point2ddestructor需要调用执行。对于前26个元素，Point3ddestructor和
Point2ddestructor都需要调用执行。然后内存必须被释放回去。
对ExceptionHandling的支持
当一个exception发生时，编译系统必须完成以下事情：
1.检验发生hrow操作的函数。
2.决定throw操作是否发生在try区段中。
2.若是，编译系统必须把exceptiontype拿来和每一个catch子句进行比较。
4.如果比较后吻合，流程控制应该交到catch子句手中。
5.如果throw的发生并不在try区段中，或没有一个catch子句吻合，那么系
统必须（a）摧毁所有activelocalobjects，（b）从堆栈中将目前的函数
“unwind”掉，（c）进行到程序堆栈的下一个函数中去，然后重复上述
步骤2~5。
决定throw是否发生在一个try区段中
还记得吗，一个函数可以被想象为好几个区域：
■try区段以外的区域，而且没有activelocalobjects。
303


Page337
深度探索C++对象模型（InsideTheC++ObjectModel）
|try区段以外的区域，但有一个（或以上）的activelocalobjects需要析构。
|try区段以内的区域。
编译器必须标示出以上各区域，并使它们对执行期的exceptionhandling系统
有所作用。一个很棒的策略就是构造出programcounter-range表格。
回忆一下，programcounter（译注：在IntelCPU中为EIP寄存器）内含下一
个即将执行的程序指令。好，为了在一个内含ry区段的函数中标示出某个区域，可
以把programcounter的起始值和结束值（或是起始值和范围）存储在一个表格中。
当throw操作发生时，目前的programcounter值被拿来与对应的“范围表格”
进行比对，以决定目前作用中的区域是否在一个try区段中。如果是，就需要找出
相关的catch子句（稍后我们再来看这一部分）。如果这个exception无法被处理（或
者它被再次抛出），目前的这个函数会从程序堆栈中被推出（popped），而program
counter会被设定为调用端地址，然后这样的循环再重新开始。
将exception的类型和每一个catch子句的类型做比较
对于每一个被抛出来的exception，编译器必须产生一个类型描述器，对
exception的类型进行编码。如果那是一个derivedtype，编码内容必须包括其所有
baseclass的类型信息。只编进publicbaseclass的类型是不够的，因为这个exception
可能被一个memberfunction捕捉，而在一个memberfunction的范围（scope）之中，
derivedclasslnonpublicbaseclassZa.
类型描述器（typedescriptor）是必要的，因为真正的exception是在执行期被
处理的，其object必须有自己的类型信息。RTTI正是因为支持EH而获得的副产
品。我将在7.3节讨论RTTI。
编译器还必须为每一个catch子句产生一个类型描述器。执行期的exception
handler会将“被抛出之object的类型描述器”和“每一个cause子句的类型描述器”
304


Page338
第7章站在对象模型的尖端
进行比较，直到找到吻合的一个，或是直到堆栈已经被“unwound”而terminate（）
已被调用。
每一个函数会产生出一个exception表格，它描述与函数相关的各区域、任何
必要的善后处理代码（cleanupcode，被localclassobjectdestructors调用）以及catch
子句的位置（如果某个区域是在try区段之中的话）。
当一个实际对象在程序执行时被抛出，会发生什么事?
当一个exception被抛出时，exceptionobject会被产生出来并通常放置在相同
形式的exception数据堆栈中。从throw端传给catch子句的，是exceptionobject
的地址、类型描述器（或是一个函数指针，该函数会传回与该exceptiontype有关
的类型描述器对象）以及可能会有的exceptionobject描述器（如果有人定义它的
话）。
考虑一个catch子句如下：
catch（exPointp）
{
//dosomething
throw;
以及一个exceptionobject，类型为exVertex，派生自exPoint。这两种类型都吻合，
于是catch子句会作用起来。那么p会发生什么事?
■p将以exceptionobject作为初值，就像是一个函数参数一样。这意味着
如果定义有（或由编译器合成出）一个copyconstructor和一个destructor
的话，它们都会实施于local
сору
身上。
■由于p是一个object而不是一个reference，当其内容被拷贝的时候，这
个exceptionobject的non-exPoint部分会被切掉（slicedoff）。此外，如
果为了exception的继承而提供virtualfunctions，那么p的vptr会被设为exPoint
Éivirtualtable;exceptionobjectJvptr7
305


Page339
深度探索C++对象模型（InsideTheC++ObjectModel）
当这个exception被再抛出一次时，会发生什么事情?p现在是繁殖出来的
object?还是从throw端产生的原始exceptionobject?p是一个localobject，在catch
子句的末端将被推毁。抛出p需得产生另一个临时对象，并意味着丧失原来的
exception的exVertex部分。原来的exceptionobject被再一次抛出;任何对p的修
改都会被抛弃。
像下面这样的一个catch子句：
catch（exPoint&rp）
一
//dosomething
throw;
一
则是参考到真正的exceptionobject。任何虚拟调用都会被决议（resolved）为instances
activeforexVertex，也就是exceptionobject的真正类型。任何对此object的改变都
会被繁殖到下一个catch子句。
最后，这里提出一个有趣的谜题。如果我们有下面的throw操作：
exVertexerrVer;
//...
mumble（）
一
//...
if（mumblecond）
{
errVer.fileName（"mumble（）"）;
throwerrVer;
一
究竟是真正的exceptionerrVer被繁殖，还是errVer的一个复制品被构造于
exceptionstack之中并被繁殖?答案是一个复制品被构造出来，全局性的errVer并
没有被繁殖。这意味着在一个catch子句中对于exceptionobject的任何改变都是局
部性的，不会影响errVer。只有在一个catch子句评估完毕并且知道它不会再抛出
306


Page340
第7章站在对象模型的尖端
exception之后，真正的exceptionobjectオ会被摧毁。
在某一次对PCC++编译器的评论当中（请参考[HORST95]），CayHorstmann
测量了EH所带来的效率和大小的额外负担。Cay编译并执行一个测试程序，产生
并摧毁大量的1ocalobjects-它们有自己的constructors和destructors。两个程序
都不发生实际的exceptions，它们之间的差异只在于其中一个的main（0内有个
catch（..）子句。下面是他测试了Microsoft、Borland、Symantec编译器后的结果。
首先，程序大小有异（参见表7.1）：
表7.1
对象大小（两种情况：有或没有exceptionhandling）
没有EH
有EH
百分比
Borland
86822
89510
3号
Microsoft
60146
67071
13%
Symantec
69786
74826
其次，执行速度也有异（参见表7.2）：
表7.2执行速度（两种情况：有或没有exceptionhandling）
没有EH
有EH
百分比
78秒
83秒
94秒
83秒
87秒
96秒
Borland
6%
Microsoft
5%
Symantec
4号
与其他语言特性进行比较，C++编译泽器支持EH机制所付出的代价最大。某种
程度上是由于其执行期的天性以及对底层硬件的依赖，以及UNIX和PCc两种平台
对于执行速度和程序大小有着不同的取舍优先状态之故。
307
H00


Page341
深度探索C++对象模型（InsideTheC++ObjectModel）
7.3
执行期类型识别（RuntimeTypeldentification，RTTI）
在cfront中，用以表现出一个程序的所谓“内部类型体系”，看起来像这样：
1/程序层次结构的根类（rootclass）
classnode{
...};
//rootofthe'type'subtree：basictypes，
//
'derived'types：pointers，arrays，
//
functions，classes，enums
..
classtype：publicnode{
};
..
//tworepresentationsforfunctions
classfct：publictype{
classgen：publictype{
};
...
};
其中gen是generic的简写，用来表现一个overloadedfunction。
于是只要你有一个变量，或是类型为ope*的成员（并知道它代表一个函数），
你就必须决定其特定的derivedtype是否为fct或是gen。在2.0之前，除了destructor
之外唯一不能够被overloaded的函数就是conversion运算符，例如：
classString{
public：
operatorchar*（）;
//...
};
在2.0导入constmemberfunctions之前，conversion运算符不能够被overloaded，
因为它们不使用参数。直到引进了constmemberfunctions，情况オ有所变化。现在，
像下面这样的声明就有可能了：
classString{
public：
//okwithRelease2.0
operatorchar*（）;
operatorchar*（）const;
//
..
};
308


Page342
第7章站在对象模型的尖端
也就是说，在2.0版之前，以一个explicitcast来存取derivedobject总是安全
（而且比较快速）的，像下面这样：
typedeftype*ptype;
typedeffct*pfct;
simplify_conv_op（ptypept）
{
//ok：conversionoperatorscanonlybefcts
pfctpf
pfct（pt）;
//
..
一
在constmemberfunctions引入之前，这份代码是正确的。请注意其中甚至有
一个注释，说明这样的转换的安全性。但是在constmemberfunctions引进之后，
不论程序注释还是程序代码就都不对了。程序代码之所以失败，非常不幸是因为
Stringclass声明的改变。因为char*conversion运算符现在被内部视为一个gen而
不是一个fet。
下面这样的转换形式：
pfctpf=
pfct（pt）;
被称为downcast（向下转换），因为它有效地把一个baseclass转换至继承架构的
末端，变成其derivedclasses中的某一个。Downcast有潜在性的危险，因为它過制
了类型系统的作用，不正确的使用可能会带来错误的解释（如果它是一个read操
作）或腐蚀掉程序内存（如果它是一个write操作）。在我们的例子中，一个指向
genobject的指针被不正确地转换为一个指向fctobject的指针pf。所有后续对pf
的使用都是不正确的（除非只是检查它是否为0，或只是把它拿来和其他指针进行
比较）。
309


Page343
深度探索C++对象模型（InsideTheC++ObjectModel）
Type-SafeDowncast（保证安全的向下转换操作）
C++被吹毛求疵的一点就是，它缺乏一个保证安全的downcast（向下转换操
作）。只有在“类型真的可以被适当转换”的情况下，你才能够执行downcast（请
看[BUDD91]）。一个type-safedowncast必须在执行期对指针有所查询，看看它是
否指向它所展现（表达）之object的真正类型。因此，欲支持type-safedowncast，
在object空间和执行时间上都需要一些额外负担：
需要额外的空间以存储类型信息（typeinformation），通常是一个指针，
指向某个类型信息节点。
■需要额外的时间以决定执行期的类型（runtimetype），因为，正如其名
所示，这需要在执行期才能决定。
这样的机制面对下面这样平常的C结构，会如何影响其大小、效率以及链接
兼容性呢?
char*winnie_tbl[]
={"rumblyinmytummy"，"oh，bother"};
很明显，它所导致的空间和效率上的不良后果甚为可观。
冲突发生在两组使用者之间：

1.程序员大量使用多态（polymorphism），并因而需要正统而合法的大量
downcastE.
2.程序员使用内建数据类型以及非多态设备，因而不受各种额外负担所带
来的不良后果。
理想的解决方案是，为两派使用者提供正统而合法的需要一一虽然或许得牺牲
一些设计上的纯度与优雅性。你知道要怎么做吗?
C++的RTTI机制提供了一个安全的downcast设备，但只对那些展现“多态（也
就是使用继承和动态绑定）”的类型有效。我们如何分辨这些?编译器能否光看
310


Page344
第7章站在对象模型的尖端
class的定义就决定这个class用以表现一个独立的ADT还是一个支持多态的可继
承子类型（subtype）?当然，策略之一就是导入一个新的关键词，优点是可以清
楚地识别出支持新特质的类型，缺点则是必须翻新旧程序。
另一个策略是通过声明一个或多个virtualfunctions来区别class声明。其优点
是透明化地将旧有程序转换过来，只要重新编译就好。缺点则是可能会将一个其实
并非必要的virtualfunction强迫导入继承体系的baseclass身上。毫无疑问你还可
以想出更多策略，不过，目前所说的这一个正是RTTI机制所支持的策略。在C++
中，一个具备多态性质的class（所谓的polymorphicclass），正是内含着继承而来
（或直接声明）的virtualfunctions。
从编译器的角度来看，这个策略还有其他优点，就是大量降低额外负担。所有
polymorphicclassesiobjects-at（vptr），virtualfunctiontable.
只要我们把与该class相关的RTTIobject地址放进virtualtable中（通常放在第一
个slot），那么额外负担就降低为：每一个classobject只多花费一个指针。这一指
针只需被设定一次，它是被编译器静态设定的，而非在执行期由classconstructor
设定（vptrオ是这么设定的）。
Type-SafeDynamicCast（保证安全的动态转换）
dynamic_cast运算符可以在执行期决定真正的类型。如果downcast是安全
的（也就是说，如果basetypepointer指向一个derivedclassobject），这个运算符
会传回被适当转换过的指针。如果downcast不是安全的，这个运算符会传回0。下
面就是我们如何重写我们原本的cfrontdowncast（当然啦，现在的pt实际类型可
能是fct，也可能是gen。比较受欢迎的程序方法是使用virtualfunction。在此法
中，参数的真正类型被封装起来。程序比较清晰，也比较容易扩充，得以处理更
多类型）：
311


Page345
深度探索C++对象模型（InsideTheC++ObjectModel）
typedeftype*ptype;
typedeffct*pfct;
simplify_conv_op（ptypept）
{
if（pfctpf
dynamic_cast<pfct>（pt））{
//...
processpf
一
else{...
什么是dymamic_cast的真正成本呢?pfet的一个类型描述器会被编译器产生出
来。由pt所指向的classobject类型描述器必须在执行期通过vptr取得。下面就是
可能的转换：
//取得pt的类型描述器
（（type_info*）（pt->vptr[0->_type_descriptor;
りpe_info是C++Standard所定义的类型描述器的class名称，该class中放置着
待索求的类型信息。virtualtable的第一个slot内含ype_infoobject的地址;此
りpe_infoobject与pt所指的classtype有关（请看1.1节的图1.3）。这两个类型型描
述器被交给一个runtimelibrary函数，比较之后告诉我们是否吻合。很显然这比static
cast昂贵得多，但却安全得多（如果我们把一个fet类型“downcast”为一个gen
类型的话）。
最初对runtimecast的支持提议中，并未引进任何关键词或额外的语法。下面
这样的转换操作：
1/最初对runtimecast的提议语法
pfctpf
pfct（pt）;
究竟是static还是dynamic，必须视pt是否指向一个多态classobject而定。贝尔实
验室中的我们这一伙认为这样很棒，但是C++标准委员会想的却是另一套。他们的
评论，就我所知，认为这么一来一个代价昂贵的runtime操作与一个简单的staticcast
太相像了。也就是说，当我们看到这个cast操作时，无法知道pt是否指向多态对
312


Page346
第7章站在对象模型的尖端
象（polymorphicobject），也就无法知道这个cast操作是执行于编译时期，还是执
行期。这当然是事实，然而，virtualfunctioncall不也同样吗?或许C++标准委员
也应该引进一种新语法和关键词，以便区分：
pt->foobar（）;
是一个静态决议的functioncall，还是一个通过虚拟机制的调用操作!
References#T2Pointers
程序执行中对一个class指针类型施以dynamic_cast运算符，会获得true或
false：
|如果传回真正的地址，则表示这一object的动态类型被确认了，一些与
类型有关的操作现在可以施行于其上。
■如果传回0，则表示没有指向任何object，意味着应该以另一种逻辑施行
于这个动态类型未确定的object身上。
dynamic_cast运算符也适用于reference身上。然而对于一个non-type-safecast，
其结果不会与施行于指针的情况相同。为什么?一个reference不可以像指针那样
“把自己设为0便代表了‘noobject'”;若将一个reference设为0，会引起一个
临时性对象（拥有被参考到的类型）被产生出来，该临时对象的初值为0，这个
reference然后被设定成为该临时对象的一个别名（alias）。因此当dynamic_cast运
算符施行于一个reference时，不能够提供对等于指针情况下的那一组true/false。
取而代之的是，会发生下列事情：
■如果reference真正参考到适当的derivedclass（包括下一层或下下一层，
或下下下一层或……），downcast会被执行而程序可以继续进行。
■如果reference并不真正是某一种derivedclass，那么，由于不能够传回0，
因此抛出一个bad_castexception。
下面是重新实现后的simplify_comvop函数，参数改为一个reference：
313


Page347
深度探索C++对象模型（InsideTheC++ObjectModel）
simplify_conv_op（consttype&rt）
{
try{
fct&rf=
dynamic_cast<fct&>（rt）;
//
}
catch（bad_cast）
{
//...mumble
}
}
其中执行的操作十分理想地表现出某种exceptionfailure，而不只是简单（一如
从前）的控制流程。
Typeid运算符
使用りpeid运算符，就有可能以一个reference达到相同的执行期替代路线
（runtime“alternativepathway"）：
66
simplify_conv_op（consttype&rt）
{
if（typeid（rt）
typeid（fct））
{
fct&rf=
static_cast<fct&>（rt）;
//
}
else{
..
}
虽然显而易见，但我也必须要说，在这里，一个明显的较好实现策略是在gen
F1fctelasses#virtualfunction.
ypeid运算符传回一个constreference，类型为ype_info。在先前测试中出现的
equality（等号）运算符，其实是一个被overloaded的函数：
bool
type_info：：
operator==（consttype_info&）const;
314


Page348
第7章站在对象模型的尖端
如果两个ype_infoobjects相等，这个equality运算符就传回true。
type_infoobjectHtt4C++Standard（Section18.5.1）type_info）
定义如下（译注：你可以在VisualC++的typeinfo.h中找到类似的定义）：
classtype_info{
public：
virtual-type_info（）;
booloperator==（consttype_info&）const;
booloperator!=（consttype_info&）const;
boolbefore（consttype_info&）const;
constchar*name（）const;
//译注：传回class原始名称
private：
//preventmemberwiseinitandcopy
type_info（consttypeinfo&）;
type_info&operator=（consttype_info&）;
//datamembers
};
编译器必须提供的最小量信息是class的真实名称和在ope_infoobjects之间的
某些排序算法（这就是before）函数的目的），以及某些形式的描述器，用来表现
explicitclasstype和这一class的任何subtypes。在描述exceptionhandling的原始文
章（[KOENIG906]）中，曾建议实现出一种描述器：编码后的字符串（译注）。其
他策略请见[SUN94a]和[LENKOV92]。
译注：Microsoft的VisualC++就是采用编码后的字符串作为描述器。所以
VisualC++的typeinfo.h中对于がype_info的定义，就比上述的C++Standard所定义
的还多一个member：
classtypeinfo{
public：
//传回class原始名称
1/传回class名称的编码字符串
constchar*name（）const;
constchar*rawname（）const;
};
315


Page349
AahttahansideTheC++ObjectModel）
下面是以VisualC++完成的一个小范例，用以检验编码后的class名称：
//building：
cl-GRtypeid.cpp
#include<iostream.h>
#include<typeinfo.h>
classB{
};
...
classD
：publicB{...
};
voidmain（）
{
B*pb
=newB;
D*pd
newD;
%3D
"<<typeid（pb）.name（）<<endl;
<<typeid（pd）.name（）<<endl;
"<<typeid（pb）.rawname（）<<endl;
"<<typeid（pd）.rawname（）<<endl;
cout<<"pb'stypename
cout<<"pd'stypename
cout<<"pb'styperawname
%3D
cout<<"pd'styperawname=
}
执行结果为：
（classB的原始名称）
（classD的原始名称）
（classB的编码名称）
（classD的编码名称）
pb'stypename
=classB
pd'stypename
classD
%3D
pb'styperawname=
.PAVB@@
pd'styperawname
PAVD@@
虽然RTTI提供的りpe_info对于exceptionhandling的支持来说是必要的，但对
于exceptionhandling的完整支持而言，还不够。如果再加上额外的一些bype_info
derivedclasses，就可以在exception发生时提供关于指针、函数、类等等的更详细
信息。例如MetaWare就定义了以下的额外类：
classPointer_type_info：publictype_info{
classMember_pointer_info：publictype_info{...
classModified_type_info：publictype_info{
};
};
};
..
};
};
classArray_type_info：publictype_info
classFunc_type_info：publictype_info{
classClass_type_info：publictype_info{
..
..
};
并允许使用者取用它们。不幸的是，那些derivedclasses的大小以及命名习惯都没
316


Page350
第7章站在对象模型的尖端
有一个标准，各家编译器差异较大。
虽然我早说过RTTI只适用于多态类（polymorphicclasses），事实上りpe_info
objects也适用于内建类型，以及非多态的使用者自定类型。这对于exception
handling的支持是有必要的。例如：
intexerrno;
throwexerrno;
其中int类型也有它自己的ype_infoobject。下面就是使用方法：
int*ptr;
...
if（typeid（ptr）
typeid（int*））
=%=
在程序中使用かpeid（expression），像这样：
intival;
typeid（ival）
...;
或是使用peid（type），像这样：
typeid（double）...;
会传回一个consttype_info&。这与先前使用多态类型（polymorphictypes）的差异
在于，这时候的かpe_infoobject是静态取得，而非执行期取得。一般的实现策略是
在需要时才产生bpe_infoobject，而非程序一开头就产生之。
317


Page351
深度探索C++对象模型（InsideTheC++ObjectModel）
7.4效率有了，弹性呢?
传统的C++对象模型提供有效率的执行期支持。这份效率，再加上与C之间
的兼容性，造成了C++的广泛被接受度。然而，在某些领域方面，像是动态共享函
数库（dynamicallysharedlibraries）、共享内存（sharedmemory）以及分布式对象
（distributedobject）方面，这个对象模型的弹性还是不够。
aDynamicSharedLibraries）
理想中，一个动态链接的sharedlibrary应该像“突然造访”一样。也就是说，
当应用程序下一次再执行时，会透明化地取用新的library版本。新的library问世
不应该对旧的应用程序产生侵略性，应用程序不应该需要为此重新建造（building）
一次。然而，在目前的C++对象模型中，如果新版library中的classobject布局有
所变更，上述的“library无侵略性”说法便有待商榷了。这是因为class的大小及
其每一个直接（或继承而来）的members的偏移位置（offset）都在编译时期就已
经固定（虚拟继承的members除外）。这虽然带来了效率，却在二进制层面（binary
level）阻碍了弹性。如果object布局改变，应用程序就必须重新编译。[GOLD94]
和[PALAY92]两篇文章描述了前人的许多有趣的努力，希望把C++对象模型推至更
具有“突然造访”的能力。当然，这会丧失部分的执行期速度优势和大小优势。
共享内存（SharedMemory）
当一个sharedlibrary被加载时，它在内存中的位置由runtimelinker决定，
般而言与执行中的进程（process）无关。然而，在C++对象模型中，当一个动态的
sharedlibrary#-↑classobject，irtualfunctions（tEshared
memory
中）时，上述说法便不正确。问题并不在于“将此object放置于sharedmemory中”
的那个进程，而在于“想要经由这个sharedobject附着并调用一个virtualfunction”
的第二个或更后继的进程。除非dynamicsharedlibrary被放置于完全相同的内存位
318


Page352
第7章站在对象模型的尖端
置上，就像当初加载这个sharedobject的进程一样，否则virtualfunction会死得很
难看，可能的错误包括segmentfault或buserror。病灶在于每一个virtualfunction
在virtualtable中的位置已经被写死了。目前的解决方法属于程序层面，程序员必
须保证让跨越进程的sharedlibraries有相同的坐落地址（在SGI中，使用者可以根
据所谓的so-location文件，指定每一个sharedlibrary的精确位置）。至于编译系统
层面上的解决方法，势必得牺性原本的virtualtable实现模型所带来的高效率。
CommonObjectRequestBrokerArchitecture（CORBA），ComponentObject
Model（COM）以及SystemObjectModel（SOM）都企图定义出分布式、二进制层
面的对象模型，并且与任何程序语言无关（请见[MOWBRAY95]对CORBA的详细
讨论，以及对SOM和COM的次要讨论。至于C++导向的讨论，请见[HAM95]的
SOM、[BOX95]的COM，以及[VINOS93]和[VINOS94]的CORBA）。这些努力有
可能在未来将C++对象模型推往更高的弹性（经由更多的间接性），但我们也知道
那需要赔上更多的执行期速度与效率。
当我们的计算环境的需求更加进化（试想想Webprogramming、Javaapplets）
时，传统的C++对象模型，带着它那“高效率”和“与C兼容”的特性，可能会
不断累加束缚。然而，到了那个时候，对象模型（ObjectModel）将证明C++的全
面适用性，不论在各式各样的操作系统、各式各样的硬件驱动程序、基因工程上，
还是在我自己目前专注的3D计算机绘图和动画上。
319


Page353
深度探索C++对象模型（InsideTheC++ObjectModel）
译注：如果您对于ComponentObjectModel（COM）感兴趣，我推荐两本理想

5.-*EssentialCOM（DonBox/AddisonWesley/1998）.A-Inside
COM（DaleRogerson/MicrosoftPress/1996）.EssentialCOM1，2E☆
件组件（components）的本质、问题所在以及COM的解决之道解释得非常好，带
着读者以一般的、纯粹的C++语言（不借助任何工具）完成一个COM程序架构：
第3章以后的内容略嫌艰涩，可辅以InsideCOM。InsideCOM全书清爽简易，但
最好必须先读过EssentialCOM的前两章，您才会有扎实深厚的基础去接受它。
320