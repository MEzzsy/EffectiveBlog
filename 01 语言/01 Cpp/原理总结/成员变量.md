```cpp
class X {};
class Y: public virtual X {};
class Z: public virtual X {};
class A: public Y, public Z {};

void test() {
    my_log(sizeof(X));
    my_log(sizeof(Y));
    my_log(sizeof(Z));
    my_log(sizeof(A));
    my_log(sizeof(int *));
}

1
8
8
16
8
```

从结果中看，指针的大小为8字节。

**X的大小**

X代码是空的，但事实上并不是空的，它有一个隐藏的1byte大小，那是被编译器安插进去的一个char。这使得这一class的两个objects得以在内存中配置独一无二的地址。

```cpp
class X {
};

class X2{
    char c;
    char c2;
};

//sizeof
1
2
```

**Y和Z的大小**

它们受三个因素影响：

1.  **语言本身所造成的额外负担**
    当语言支持virtuawl base classes时，就会导致一些额外负担。如：派生类会存有一份指向虚基类的指针。
2.  **编译器对于特殊情况所提供的优化处理**

3. **字节对齐**

Y和Z在代码上是空的，和X一样，编译器应该会安插一个char，那么就是1（char）+8（虚基类指针）+7（字节对齐）=16，但是结果是8。

这是因为一些编译器进行了优化。一个empty virtual base class被视为derived class object最开头的一部分，也就是说它并没有花费任何的额外空间。（因为既然有了members，就不需要原本为了empty class
而安插的一个char）。

<img src="assets/13.png" alt="13" style="zoom:30%;" />

```cpp
class Y : public virtual X {
};

class Z : public virtual X {
    char c;
};

//sizeof
8
16
```

**A的大小**

暂略。

# 成员变量的绑定

```cpp
extern float x;

class Point3D {
public:
    Point3D(float x, float y, float z);

    float X() const { return x; }

    void X(float new_x) { x = new_x; }

private:
    float x, y, z;
};
```

当调用X()函数时，回调的是class中的x。

早期的编译器不是这样，后来编译器这样更改：对member functions本体的分析，会直到整个class的声明都出现了才开始。因此在一个inline member function躯体之内的一个data member绑定操作，会在整个class声明完成之后才发生。

也就是说，X()函数虽然在class内部，但是对X函数的分析延迟到class声明的右大括号出现才开始，这时候成员变量x已经被绑定。

但是成员函数的参数列表没有用此规则，参数列表是在首次出现就被处理，如例子：

```cpp
typedef char length;

class Point3D {
public:
    void fun(length len) {
        cout << "方法参数：" << sizeof(len) << endl;
        cout << "成员变量：" << sizeof(l) << endl;
    }

private:
    typedef int length;
    length l;
};

void test() {
    Point3D p;
    p.fun(1);
}

方法参数：1
成员变量：4
```

函数体的分析延迟到声明结束，所以成员变量是int类型的，但是参数列表的分析没有延迟，所以是char类型的。

# 成员变量的布局

静态成员变量存放在程序的data segment中，和class对象无关。

C++ Standard要求，在同一个access section（也就是private、public、protected等区段）中，members的排列只需符合较晚出现的members在class object中有较高的地址这一条件即可。也就是说，各个members并不一定得连续排列。什么东西可能会介于被声明的members之间呢？members之间的字节填充。

# 成员变量的存取

## 静态成员变量的存取

每一个static data member只有一个实例，存放在程序的data segment之中。每次程序取用static member时，就会被内部转化为对该唯一extern实例的直接参考操作。如：

```cpp
x.staticVal = 100;
X::staticVal = 100;

xptr->staticVal = 100;
X::staticVal = 100;

x().staticVal = 100;
x();
X::staticVal = 100;
```

如果有2个class声明相同名称的静态成员变量，因为静态成员变量会放在程序的data segment中，这时会导致名称冲突。解决办法是编译器对静态成员变量进行编码，同时还能够解码。

## 非静态成员变量的存取

Nonstatic data members直接存放在每一个class object之中。除非经由显式的或隐式的class object，否则没有办法直接存取它们。

在class中存取成员变量，虽然没有显式的出现对象，但实际上用到了this指针。

欲对一个nonstast data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移位置(offset) 。

每一个nonstatic data member的偏移位置(offset)在编译时期即可获知，甚至如果member属于一个base class subobject（派生自单一或多重继承串链）也是一样的。因此，存取一个nonstatic data member，其效率和存取一个C struct member或一个nonderived class的member是一样的。

从对象存取和从指针存取有什么区别？
答案是当类是一个derived class，而其继承结构中有一个virtual base class，并且被存取的member是一个从该virtual base class继承而来的member时，就会有重大的差异。
因为不能确定指针指向哪一种class type（不知道编译时期这个member真正的offset位置），所以这个存取操作必须延迟至运行期，经由一个额外的间接导引，才能够解决。但如果使用对象，就不会有这些问题，其类型一定是对应的类，而即使它继承自virtual base class，members的offset位置也在编译时期就固定了。

# 继承与成员变量

在C++继承模型中，一个derived class object所表现出来的东西，是其自己的members加上base class(es) members的总和。

## 只要继承不要多态

书中介绍说，经过三层继承，类的大小变为16字节，但是经测试：

```cpp
class A {
    int val;
    char c1;
};

class B : public A {
    char c2;
};

class C : public B {
    char c3;
};


void test() {
    my_log(sizeof(A));
    my_log(sizeof(B));
    my_log(sizeof(C));
}

8
8
8
```

## 加上多态

多态指的是虚函数，和前面介绍的一样，虚函数的实现方式是添加一个虚函数指针。虚函数指针存放的位置视编译器决定，有些放在类的开头，有些放在类的末尾。

## 多重继承

```cpp
Point3d p3d;
Point2d *p = &p3d;
```

单一继承体系下，把一个derived class object指定给base class（不管继承深度有多深）的指针或reference。这个操作并不需要编译器去调停或修改地址。它很自然地可以发生，而且提供了最佳执行效率。

>   即，不管是基类还是派生类，它们地址都是对象的最低位地址。

如果把vptr放在class object的起始处并且如果base class没有virtual function而derived class有，那么单一继承的自然多态就会被打破。这种情况下，把一个derived object转换为其base类型，就需要编译器的介入，用以调整地址。

在既是多重继承又是虚拟继承的情况下，编译器的介入更有必要。

对一个多重派生对象，将其地址指定给最左端（也就是第一个）base class的指针，情况将和单一继承时相同，因为二者都指向相同的起始地址。需付出的成本只有地址的指定操作而已。至于第二个或后继的base class的地址指定操作，则需要将地址修改过：加上（减去）介于中间的base class subobject(s)大小。

![14](assets/14.jpg)

如果要存取第二个（或后继）base class中的一个data member，将会是怎样的情况？需要付出额外的成本吗？不，members的位置在编译时就固定了，因此存取members只是一个简单的offset运算，就像单一继承一样简单——不管是经由一个指针、一个reference或是一个object来存取。

## 虚拟继承

虚拟继承的实现方法如下所述。Class如果内含一个或多个virtual base class subobjects，将被分割为两部分：一个不变区域和一个共享区域。
不变区域中的数据，不管后继如何衍化，总是拥有固定的offset（从object的开头算起），所以这一部分数据可以被直接存取。
共享区域所表现的就是virtual base class subobject这一部分的数据，其位置会因为每次的派生操作而有变化，所以它们只可以被间接存取。

以下说明三种主流策略。

![15](assets/15.jpg)

cfront编译器会在每一个derived class object中安插一些指针，每个指针指向一个virtual base class。要存取继承得来的virtual base class members，可以通过相关指针间接完成。

这样的实现模型有两个主要的缺点：

1.  每一个对象必须针对其每一个virtual base class背负一个额外的指针。然而理想上我们却希望class object 有固定的负担，不因为其virtual base classes的个数而有所变化。想想看这该如何解决？
2.  由于虚拟继承串链的加长，导致间接存取层次的增加。这里的意思是，如果我有三层虚拟派生，我就需要三次间接存取(经由三个virtual base class指针)。然而理想上我们却希望有固定的存取时间，不因为虚拟派生的深度而改变。

MetaWare和其他编译器到今天仍然使用cfront的原始实现模型来解决第二个问题，它们经由拷贝操作取得所有的nestedvirtualbaseclass指针，放到derived class object之中。这就解决了“固定存取时间”的问题，虽然付出了一些空间上的代价。

![16](assets/16.jpg)

至于第一个问题，一般而言有两个解决方法。Microsoft 编译器引入所谓的virtual base class table。每一个class object如果有一个或多个virtual base classes，就会由编译器安插一个指针，指向virtual base class table。至于真正的virtual base class指针，当然是被放在该表格中。

第二个解决方法，是在virtual function table中放置virtual base class的offset (而不是地址)。图3.5b显示这种base class offset实现模型。

![17](assets/17.jpg)

# 成员对象的效率

# 指向成员变量的指针

