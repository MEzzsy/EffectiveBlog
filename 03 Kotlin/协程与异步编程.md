# 协程基础

协程（Coroutine）是一种**轻量级的线程**，由 Kotlin 语言层实现（而非操作系统），可以在单线程内实现多任务的 “并发” 执行，核心优势是：

- **低开销**：创建 10 万个协程的内存消耗远低于 10 万个线程。
- **简洁的异步代码**：用同步的代码风格写异步逻辑（避免回调地狱）。
- **精准的生命周期管理**：通过 `CoroutineScope` 控制协程的启动与取消。

# `CoroutineScope`—— 协程的 “管理者”

`CoroutineScope`（协程作用域）是协程的 “容器”，负责**跟踪协程的生命周期**（启动、取消），确保协程不会泄露（如页面销毁后仍在执行网络请求）。

## 核心作用

- 启动协程（通过 `launch`/`async` 等函数）。
- 统一管理协程的生命周期（调用 `scope.cancel()` 可取消其内部所有协程）。



## 如何创建 `CoroutineScope`

`CoroutineScope` 的创建需要一个 **`CoroutineContext`**（协程上下文，包含调度器、异常处理器等），最常用的方式：

```kotlin
// 1. 基础创建方式（指定上下文）
val myScope = CoroutineScope(
    context = Dispatchers.Main + CoroutineName("MyScope") + SupervisorJob()
)
```



## 关键注意点

- **禁止使用 `GlobalScope`**：它是一个全局作用域，生命周期与应用一致，容易导致协程泄露（如页面关闭后仍在运行）。
- **`Job` 是生命周期的核心**：`CoroutineScope` 通常包含 `Job`（如 `SupervisorJob()`），调用 `job.cancel()` 会取消所有子协程。



# `Dispatcher`—— 协程的 “调度员”

`Dispatcher`（调度器）决定了协程**在哪个线程上执行**，是控制协程 “并发” 的核心。



## 常用调度器

Kotlin 内置 4 种核心调度器，对应不同场景：

| 调度器                   | 作用                                           | 适用场景                           |
| ------------------------ | ---------------------------------------------- | ---------------------------------- |
| `Dispatchers.Main`       | 在主线程（UI 线程）执行                        | 更新 UI、处理用户交互              |
| `Dispatchers.IO`         | 在 IO 线程池执行（专门处理 IO 操作）           | 网络请求、文件读写、数据库操作     |
| `Dispatchers.Default`    | 在默认线程池执行（CPU 密集型任务）             | 复杂计算、数据解析（如 JSON 解析） |
| `Dispatchers.Unconfined` | 不指定线程（在当前线程执行，遇到挂起点后切换） | 特殊场景（谨慎使用）               |

 

## 如何切换调度器

通过 `withContext` 函数在协程内部切换线程，示例：

```kotlin
fun test1() = runBlocking {
    val myScope = CoroutineScope(
        context = Dispatchers.IO + CoroutineName("MyScope") + SupervisorJob()
    )
    myScope.launch {
        println("start launch")
        // 1. 切换到 IO 线程执行网络请求
        withContext(Dispatchers.Default) {
            delay(1000)
            println("IO")
        }
        println("Main")
    }
    println("End")
    delay(2000)
}
```

```
End
start launch
IO
Main
```

- **“哪里耗时，哪里切换”**：仅在需要执行耗时操作时切换到 `IO`/`Default`，避免不必要的线程切换。
- **`withContext` 是 “线程切换 + 等待结果”**：它会暂停当前协程，等待子任务完成后返回结果，并自动切回原调度器。



# Job

`Job`是协程的句柄，它有以下核心特性：

1. **生命周期管理**：包含活跃（Active）、完成（Completed）、取消中（Cancelling）、已取消（Cancelled）等状态，状态之间有明确的转换规则。
2. **父子关系**：协程可以有父`Job`和子`Job`，父`Job`取消时会递归取消所有子`Job`（结构化并发特性）。
3. **操作方法**：提供`cancel()`（取消协程）、`join()`（等待协程完成）等方法。



## 基本使用

通过`launch`构建器启动的协程会返回一个`Job`对象，我们可以通过它控制协程：

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    // 启动协程，返回Job对象
    val job = launch {
        delay(1000) // 模拟耗时操作
        println("协程执行完成")
    }
    
    println("等待协程完成...")
    job.join() // 等待协程执行完毕
    println("主线程继续执行")
}
```

输出：

```plaintext
等待协程完成...
协程执行完成
主线程继续执行
```

- `job.join()`会挂起当前协程（这里是`runBlocking`创建的主线程协程），直到目标协程执行完毕。
- 若调用`job.cancel()`，则会取消该协程，后续代码不再执行。



## job的取消

### 调用挂起函数时自动感知

Kotlin 标准库中的挂起函数（如 `delay()`、`withContext()`、`join()` 等）会主动检查协程的取消状态。如果协程已被取消，这些函数会立即抛出 `CancellationException`，从而中断协程执行。

```kotlin
fun test2() = runBlocking {
    val job = launch {
        try {
            println("协程启动")
            delay(1000) // 挂起函数，会检查取消状态
            println("这段代码不会执行（已被取消）")
        } catch (e: CancellationException) {
            println("捕获到取消异常：${e.message}")
        } finally {
            println("协程退出前的清理工作")
        }
    }

    delay(500) // 等待500ms后取消协程
    job.cancel()
    job.join() // 等待协程处理完取消逻辑
}
```

输出：

```plaintext
协程启动
捕获到取消异常：StandaloneCoroutine was cancelled
协程退出前的清理工作
```

- 当 `job.cancel()` 被调用后，协程的取消状态会被标记。
- 此时 `delay(1000)` 会检测到取消状态，抛出 `CancellationException`，协程进入异常处理流程。



### 通过 `isActive` 属性主动检查

协程内部可以通过 `CoroutineScope` 的 `isActive` 属性（布尔值）主动检查当前协程是否处于活跃状态。如果 `isActive` 为 `false`，说明协程已被取消，应主动退出。

`isActive` 是最常用的主动感知取消的方式，尤其适合在**没有调用挂起函数的循环或长时间任务**中使用。

示例：

```kotlin
fun test3() = runBlocking {
    val job = CoroutineScope(Dispatchers.IO).launch {
        println("开始长时间任务")
        var progress = 0
        while (isActive) { // 主动检查是否活跃
            progress++
            println("任务进度：$progress%")
            Thread.sleep(100) // 模拟CPU密集型任务（非挂起函数）
        }
        println("任务因取消而终止")
    }

    delay(500) // 运行500ms后取消
    job.cancel()
    job.join()
}
```

输出：

```plaintext
开始长时间任务
任务进度：1%
任务进度：2%
任务进度：3%
任务进度：4%
任务进度：5%
任务因取消而终止
```

- 循环条件 `while (isActive)` 确保：一旦协程被取消（`isActive` 变为 `false`），循环会退出，协程正常终止。
- 对于 CPU 密集型任务（没有调用挂起函数），`isActive` 是感知取消的关键。



### 使用 `ensureActive()` 强制检查

`ensureActive()` 是 `CoroutineScope` 的一个扩展函数，它会主动检查 `isActive` 状态：

- 如果 `isActive` 为 `true`，什么都不做；
- 如果 `isActive` 为 `false`，立即抛出 `CancellationException`。

它的作用类似于 “主动触发取消异常”，适合在关键步骤强制检查取消状态。

示例：

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        try {
            println("执行步骤1")
            ensureActive() // 检查是否被取消
            
            delay(300)
            println("执行步骤2")
            ensureActive() // 再次检查
            
            delay(300)
            println("执行步骤3")
        } catch (e: CancellationException) {
            println("在步骤中被取消")
        }
    }
    
    delay(500) // 步骤2执行后、步骤3前取消
    job.cancel()
    job.join()
}
```

输出：

```plaintext
执行步骤1
执行步骤2
在步骤中被取消
```

- `ensureActive()` 在步骤 2 之后、步骤 3 之前检测到取消状态，抛出异常，阻止了步骤 3 的执行。



### 取消后的清理工作（finally 块）

当协程被取消时，`finally` 块中的代码通常会执行，适合做资源释放（如关闭文件、断开连接等）。

但需注意：**如果在 finally 中调用挂起函数，必须使用 `withContext(NonCancellable)` 包装**，否则会因协程已取消而无法执行（挂起函数会立即抛出异常）。

示例：

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        try {
            delay(1000)
        } finally {
            // 普通清理操作（非挂起）可以直接执行
            println("释放普通资源")
            
            // 若需执行挂起操作，必须用NonCancellable
            withContext(NonCancellable) {
                delay(500) // 挂起函数，需在NonCancellable上下文中执行
                println("释放需要挂起的资源（如网络连接）")
            }
        }
    }
    
    delay(500)
    job.cancel()
    job.join()
}
```

输出：

```plaintext
释放普通资源
释放需要挂起的资源（如网络连接）
```

- `NonCancellable` 是一个特殊的上下文，在此上下文中，`isActive` 始终为 `true`，挂起函数可以正常执行。



## async 与 await

`async`是另一种协程构建器，它返回`Deferred<T>`对象（`Deferred`是`Job`的子类），用于获取协程的返回值。`await()`是`Deferred`的方法，用于获取异步任务的结果。

### 基本用法

```kotlin
fun test5() = runBlocking {
    // 启动异步任务，返回Deferred<Int>
    val deferred = async {
        delay(1000)
        100 // 协程的返回值
    }

    println("等待结果...")
    val result = deferred.await() // 等待结果，会挂起当前协程
    println("结果：$result")
}
```

输出：

```plaintext
等待结果...
结果：100
```

- `async`启动的协程会计算一个结果，通过`await()`获取（`await()`必须在协程体内调用）。
- `await()`会挂起当前协程，但不会阻塞线程，其他协程可以继续执行。



### 并行执行任务

`async`的典型场景是并行执行多个任务，提高效率：

```kotlin
import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

fun main() = runBlocking {
    // 并行启动两个异步任务
    val time = measureTimeMillis {
        val deferred1 = async { loadData1() }
        val deferred2 = async { loadData2() }
        
        // 等待两个任务完成并获取结果
        val result1 = deferred1.await()
        val result2 = deferred2.await()
        
        println("合并结果：${result1 + result2}")
    }
    
    println("总耗时：$time ms")
}

suspend fun loadData1(): Int {
    delay(1000)
    return 10
}

suspend fun loadData2(): Int {
    delay(1000)
    return 20
}
```

输出：

```plaintext
合并结果：30
总耗时：1028 ms
```

- 两个`async`任务并行执行，总耗时约为单个任务的时间（1000ms），而非两者之和。



### async延迟启动

`async`默认在调用时立即启动协程，若想延迟启动（直到`await()`或`start()`被调用），可使用`start = CoroutineStart.LAZY`：

```kotlin
val deferred = async(start = CoroutineStart.LAZY) {
    delay(1000)
    100
}
// 此时协程未启动，需调用start()或await()才会执行
deferred.start() // 手动启动
```



### Job 与 Deferred 的关系

- `Deferred<T>`继承自`Job`，因此它拥有`Job`的所有功能（如`cancel()`、`join()`）。
- `Job`仅表示 “任务”，无返回值；`Deferred<T>`表示 “有返回值的任务”，通过`await()`获取结果。
- 若`Deferred`对应的协程被取消，调用`await()`会抛出`CancellationException`。



# suspend

`suspend` 是 Kotlin 协程中的核心关键字，用于标记**可暂停的函数**。它允许函数在执行过程中暂停，并在稍后从暂停点恢复，而不会阻塞底层线程。这种特性是实现高效异步编程的基础。



## suspend 的核心作用

1. **标记可暂停函数**：被 `suspend` 修饰的函数只能在**协程体内**或**其他 suspend 函数**中调用。

   示例：

   ```kotlin
   // 定义 suspend 函数
   suspend fun fetchData(): String {
       delay(1000) // 模拟网络请求（挂起函数）
       return "数据结果"
   }
   
   // 错误示例：suspend 函数不能在普通函数中直接调用
   fun main() {
       fetchData() // 编译报错：Suspend function 'fetchData' should be called only from a coroutine or another suspend function
   }
   
   // 正确示例：在协程中调用
   fun main() = runBlocking {
       val result = fetchData() // 合法：runBlocking 创建的是协程作用域
       println(result)
   }
   ```

2. **实现非阻塞暂停**：`suspend` 函数在执行到**挂起点**（调用其他 suspend 函数时）会暂停，但不会阻塞当前线程。线程会被释放去执行其他任务，直到暂停的操作完成后再恢复执行。

   例如，`delay(1000)` 是一个 suspend 函数，它会暂停协程 1 秒，但期间线程可以去处理其他工作：

   ```kotlin
   import kotlinx.coroutines.*
   import kotlin.system.measureTimeMillis
   
   fun main() = runBlocking {
       val time = measureTimeMillis {
           // 启动两个协程，并行执行
           launch { delay(1000) }
           launch { delay(1000) }
       }
       println("总耗时：$time ms") // 输出约 1000 ms（非 2000 ms）
   }
   ```

> 可以这么理解**非阻塞暂停**
>
> 阻塞的是当前协程，但是不会阻塞协程所在的线程



## suspend 函数的工作原理

Kotlin 中的 `suspend` 函数之所以能实现**非阻塞暂停**，核心在于编译器对其进行的**代码转换**和协程运行时的**状态管理**。这个过程对开发者是透明的，但理解其底层原理有助于更好地使用协程。



### 核心原理：状态机与续体（Continuation）

`suspend` 函数的暂停和恢复依赖两个关键机制：

1. **编译器将 suspend 函数转换为状态机**
2. **通过续体（Continuation）保存和恢复执行状态**

#### 1. 续体（Continuation）：保存暂停状态的 “快照”

`Continuation` 是一个接口，本质是**暂停时的状态容器**，包含：

- 暂停时的局部变量值
- 下一次需要执行的代码位置（标签）
- 协程上下文（CoroutineContext）等信息

当 suspend 函数执行到挂起点（调用其他 suspend 函数）时，会将当前状态保存到 `Continuation` 中，然后释放线程。当挂起操作完成后，协程运行时会通过这个 `Continuation` 恢复执行。



#### 2. 状态机：将 suspend 函数拆分为可恢复的步骤

编译器会将 suspend 函数自动转换为**状态机代码**，大致流程如下：

- 把函数体按 “挂起点” 拆分成多个片段（状态）
- 每个状态对应一段可独立执行的代码
- 通过 `switch-case` 或类似逻辑根据当前状态决定执行哪段代码

例如，一个简单的 suspend 函数：

```kotlin
suspend fun example() {
    println("步骤1")
    delay(1000) // 挂起点1
    println("步骤2")
    delay(500)  // 挂起点2
    println("步骤3")
}
```

编译器会将其转换为类似状态机的结构（伪代码）：

```kotlin
// 编译器生成的状态机（简化版）
class ExampleStateMachine(
    private val continuation: Continuation<Unit>
) : Continuation<Unit> {
    // 保存局部变量和当前状态（0：初始，1：完成第一个delay后，2：完成第二个delay后）
    var state = 0
    
    override fun resumeWith(result: Result<Unit>) {
        when (state) {
            0 -> {
                println("步骤1")
                state = 1 // 更新状态
                // 调用delay，传入当前状态机作为续体
                delay(1000, this)
            }
            1 -> {
                println("步骤2")
                state = 2 // 更新状态
                delay(500, this)
            }
            2 -> {
                println("步骤3")
                // 全部完成，通知上级续体
                continuation.resumeWith(Result.success(Unit))
            }
        }
    }
}
```

- 初始状态为 `0`，执行到第一个 `delay` 时，状态更新为 `1`，然后暂停
- `delay` 完成后，通过 `resumeWith` 恢复执行，此时状态为 `1`，执行后续代码
- 直到所有步骤完成，状态机终止



#### 3. 非阻塞的关键：线程释放与恢复

当 suspend 函数在挂起点暂停时：

1. 状态机将当前状态保存到 `Continuation` 中
2. 协程运行时将该 `Continuation` 放入队列，等待挂起操作（如 `delay` 的时间到期）完成
3. 原线程被释放，可去执行其他任务（不会阻塞）

当挂起操作完成后：

1. 协程运行时从队列中取出 `Continuation`
2. 根据调度器（Dispatcher）的策略，选择一个线程（可能与之前不同）
3. 调用 `resumeWith` 方法，从保存的状态继续执行状态机的下一个步骤



### 为什么 suspend 函数不能在普通函数中调用？

编译器会为 suspend 函数自动添加一个 `Continuation` 参数（用于状态保存），其实际签名类似：

```kotlin
// 实际编译后的函数签名（简化）
fun example(continuation: Continuation<Unit>): Any? {
    // 状态机逻辑...
}
```

普通函数无法提供这个隐藏的 `Continuation` 参数，因此编译器会禁止在普通函数中直接调用 suspend 函数，确保状态机机制能正常工作。



### 总结

`suspend` 函数的暂停实现是**编译器转换**与**运行时协作**的结果：

1. 编译器将 suspend 函数转换为状态机，按挂起点拆分代码
2. 通过 `Continuation` 保存暂停时的状态（变量、执行位置）
3. 暂停时释放线程，恢复时从保存的状态继续执行，实现非阻塞

这种机制让开发者可以用同步的代码风格编写异步逻辑，同时保持高效的线程利用率。



## suspend 与普通函数的区别

| 特性         | 普通函数                          | suspend 函数                 |
| ------------ | --------------------------------- | ---------------------------- |
| 调用范围     | 任何地方                          | 仅协程或其他 suspend 函数中  |
| 线程阻塞     | 可能阻塞线程（如 `Thread.sleep`） | 非阻塞暂停（释放线程资源）   |
| 编译处理     | 直接编译为普通字节码              | 转换为带续体参数的状态机代码 |
| 与协程的关系 | 无直接关联                        | 协程的基本组成单元           |



## 常见使用场景

1. **异步操作封装**：将耗时操作（如网络请求、文件读写）封装为 suspend 函数，避免回调地狱。

   示例（伪代码）：

   ```kotlin
   // 封装网络请求为 suspend 函数
   suspend fun loadUserInfo(userId: String): User {
       return withContext(Dispatchers.IO) {
           // 实际网络请求（在 IO 线程池执行）
           apiService.getUser(userId)
       }
   }
   ```

2. **流程控制**：结合 `delay`、`withContext` 等 suspend 函数，实现复杂的异步流程控制。

3. **协作式取消**：suspend 函数内部可以响应协程取消（见前文 `Job` 取消机制），确保资源安全释放。



## 注意事项

1. **suspend 不代表 “异步执行”**：它仅标记函数可暂停，具体是否在后台线程执行，取决于协程的调度器（如 `Dispatchers.IO`、`Dispatchers.Main`）。

   例如，以下代码在主线程执行，不会开启新线程：

   ```kotlin
   suspend fun doWork() {
       println("当前线程：${Thread.currentThread().name}") // 可能是主线程
       delay(1000) // 暂停但不阻塞主线程
   }
   ```

2. **避免在 suspend 函数中阻塞线程**：如 `Thread.sleep()` 会阻塞线程，应改用 `delay()`（非阻塞的 suspend 函数）。

3. **suspend 函数的返回值是 “最终结果”**：与回调或 `Future` 不同，suspend 函数的返回值直接是异步操作的结果，无需手动处理 “未完成” 状态。



## 总结

`suspend` 是 Kotlin 协程的核心关键字，它通过**非阻塞暂停**和**状态恢复**机制，让异步代码可以像同步代码一样编写，同时保持高效的线程利用率。理解 `suspend` 的工作原理，是掌握协程编程的关键。



# `Flow`—— 响应式数据流

`Flow` 是 Kotlin 中处理**异步数据流**的工具（类似 RxJava，但更轻量、更贴合 Kotlin 语法），适合处理 “连续产生的数据”（如实时日志、状态变化、分页加载等）。

## 核心特点

- **冷流（Cold Stream）**：只有当有 “收集者”（调用 `collect`）时才会产生数据（不收集则不执行）。
  - 按需生产，避免 “无人消费时的资源浪费”（如无意义的网络请求、数据库查询）。
- **可取消**：收集过程可随协程作用域取消而终止。
  - 绑定生命周期，解决 “任务与页面 / 组件生命周期不匹配” 导致的内存泄漏和崩溃。
- **背压支持**：自动处理生产者与消费者速度不匹配的问题（如生产者太快，消费者处理不过来）。
  - 平衡生产与消费速度，在高频数据场景中防止系统过载（OOM、UI 卡顿、网络风暴）。



### 冷流（Cold Stream）：按需生产，避免资源浪费

#### 核心特点

`Flow` 是 “冷流”——**只有当存在收集者（调用 `collect`）时，才会执行数据生产逻辑；没有收集者时，生产逻辑完全不工作**。
（类比：冷流像 “按需播放的视频”，没人看就不加载；而热流像 “直播”，不管有没有观众都在播放。）

#### 实际项目中的意义

避免 “无意义的资源消耗”，尤其是在数据生产需要消耗 CPU、网络、内存等资源的场景。

**举例 1：网络请求流**

```kotlin
// 定义一个获取用户数据的 Flow（冷流）
fun getUserFlow(userId: String): Flow<User> = flow {
    println("开始发起网络请求...") // 生产逻辑
    val user = apiService.getUser(userId) // 耗时网络请求
    emit(user)
}.flowOn(Dispatchers.IO)
```

- 如果没有任何地方调用 `getUserFlow().collect { ... }`，则 `println` 和网络请求**完全不会执行**，避免浪费流量和服务器资源。
- 当用户离开页面（收集者被取消），再次进入页面时，会重新触发网络请求（按需生产），保证数据是最新的。



**举例 2：数据库查询流**

```kotlin
// 监听数据库中某个表的变化（冷流）
fun getRecentMessagesFlow(): Flow<List<Message>> = flow {
    val messages = db.messageDao().getRecent() // 数据库查询
    emit(messages)
    // 持续监听变化（假设用了 Room 的监听功能）
    db.messageDao().observeChanges().collect { emit(it) }
}
```

- 当 UI 页面销毁（没有收集者），数据库监听会自动停止，避免持续占用数据库连接和内存。



### 可取消（Cancellable）：跟随生命周期，防止内存泄漏

#### 核心特点

`Flow` 的收集过程运行在**协程作用域（`CoroutineScope`）** 中，当作用域被取消时，Flow 的收集会立即终止，且生产逻辑也会被中断。

#### 实际项目中的意义

解决 “异步任务生命周期不匹配” 导致的内存泄漏问题，尤其在 UI 场景中（如页面销毁后任务仍在运行）。

**举例 1：Android 页面销毁后终止任务**

```kotlin
// 在 Activity/Fragment 中收集 Flow
lifecycleScope.launch {
    // 收集用户数据 Flow
    getUserFlow("123").collect { user ->
        updateUI(user) // 更新 UI
    }
}
```

- 当页面销毁时，`lifecycleScope` 会自动取消，`getUserFlow` 的收集过程会立即终止：
  - 如果网络请求还在进行，会被中断（避免无效的网络消耗）；
  - 不会再调用 `updateUI`（避免因 UI 已销毁导致的崩溃）；
  - 相关资源（如网络连接、临时变量）会被及时释放，防止内存泄漏。



**举例 2：用户主动取消操作**

```kotlin
// 用户点击“取消下载”按钮
val downloadJob = viewModelScope.launch {
    downloadFileFlow().collect { progress ->
        updateProgress(progress)
    }
}

// 点击取消按钮时
cancelButton.setOnClickListener {
    downloadJob.cancel() // 取消协程，Flow 收集终止，下载停止
}
```

- 可取消性让用户可以主动中断耗时任务（如下载、大文件解析），提升交互体验。



### 背压支持（Backpressure）：平衡生产与消费速度，防止过载

#### 核心特点

背压是指 “数据生产者发送速度超过消费者处理速度” 的场景。`Flow` 内置背压处理机制，通过**缓冲、丢弃、暂停生产者**等策略，平衡生产与消费速度，避免内存溢出（OOM）或 UI 卡顿。

#### 实际项目中的意义

在 “高频数据生产” 场景中（如实时日志、传感器数据、高频网络更新），防止消费者被 “淹没”，保证系统稳定性。

**举例 1：传感器数据采集（高频生产）**
手机加速度传感器每秒产生 100 条数据（生产者很快），但 UI 每秒只能刷新 60 次（消费者较慢）：

```kotlin
// 传感器数据 Flow（高频生产）
fun getSensorDataFlow(): Flow<SensorData> = flow {
    while (isActive) {
        val data = sensorManager.read() // 每秒 100 条
        emit(data)
    }
}

// 收集并更新 UI（消费者较慢）
viewModelScope.launch {
    getSensorDataFlow()
        .buffer(60) // 缓冲 60 条数据
        .collect { data ->
            updateUISensor(data) // 每秒最多处理 60 条
        }
}
```

- `buffer(60)` 表示允许最多缓冲 60 条数据，超过则暂停生产者（等待消费者处理），避免数据堆积导致内存暴涨。



**举例 2：搜索输入防抖（丢弃多余数据）**
用户输入搜索关键词时，每秒可能触发 10 次输入事件（生产者），但网络请求不需要这么频繁（消费者）：

```kotlin
// 输入框文本变化 Flow（高频生产）
fun getSearchTextFlow(): Flow<String> = flow {
    // 监听输入框变化，每次输入都 emit
}

// 收集并发起搜索（消费者需节流）
viewModelScope.launch {
    getSearchTextFlow()
        .debounce(300) // 300ms 内连续输入，只保留最后一次
        .collect { text ->
            searchApi.query(text) // 消费者：300ms 内最多一次请求
        }
}
```

- `debounce(300)` 是背压策略的一种（丢弃短期高频数据），避免频繁发起网络请求（节省带宽，减轻服务器压力）。



**举例 3：大列表分页加载（暂停生产者）**
加载一个包含 1000 条数据的列表，UI 每次只能渲染 20 条（消费者），生产者不能一次性发送全部数据：

```kotlin
// 分页加载 Flow（生产者）
fun loadPagedDataFlow(): Flow<List<Item>> = flow {
    var page = 0
    while (hasMoreData(page)) {
        val items = api.loadPage(page) // 每次加载 20 条
        emit(items)
        page++
    }
}

// 收集并渲染（消费者）
viewModelScope.launch {
    loadPagedDataFlow()
        .collect { items ->
            // 渲染 20 条数据（耗时操作）
            uiList.addAll(items)
            delay(500) // 模拟 UI 渲染延迟
        }
}
```

- `Flow` 会自动暂停生产者，等待消费者处理完当前批次（20 条）后，再发送下一批，避免一次性加载 1000 条导致的内存溢出和 UI 卡顿。



## 冷流：`Flow` 基础用法

### 创建 `Flow`

```kotlin
// 方式 1：flow 构建器（最常用）
fun fetchUserFlow(): Flow<User> = flow {
    // 发送数据（可多次调用 emit）
    emit(apiService.getUser()) // 假设这是一个 suspend 函数
    delay(1000) // 模拟延迟
    emit(apiService.getUserUpdated()) // 发送更新后的数据
}.flowOn(Dispatchers.IO) // 指定流的生产在 IO 线程（数据发送线程）

// 方式 2：从集合/序列转换
val numbersFlow: Flow<Int> = listOf(1, 2, 3).asFlow()
```



### 收集 `Flow`

必须在**协程作用域**内通过 `collect` 收集数据：

```kotlin
viewModelScope.launch {
    // 收集数据流（会挂起当前协程，直到流结束或被取消）
    fetchUserFlow().collect { user ->
        // 处理数据（如更新 UI 状态）
        _uiState.value = user
    }
}
```



### 中间操作符

`Flow` 支持丰富的中间操作符（类似集合操作），常用的有：

```kotlin
fetchUserFlow()
    .map { user -> user.name } // 转换数据（User -> String）
    .filter { name -> name.length > 3 } // 过滤数据
    .debounce(300) // 防抖（300ms 内连续发送则只保留最后一个）
    .distinctUntilChanged() // 去重（只发送与上一个不同的数据）
    .collect { name -> 
        // 处理结果
    }
```



## 热流状态管理：`StateFlow` 与 `SharedFlow`

`Flow` 是冷流（无收集者则不工作），而 `StateFlow` 和 `SharedFlow` 是**热流（Hot Stream）**：无论是否有收集者，它们都可能处于活跃状态（数据可被缓存或持续产生）。

### `StateFlow`——“可观察的状态容器”

`StateFlow` 是一种**持有状态的热流**，适合存储和传递 “当前状态”（如 UI 状态、用户信息等），核心特点：

- 始终持有一个 “当前值”（初始值必须指定）。
- 新收集者会立即收到当前值（状态回放）。
- 只有当值发生变化时才会发送数据（自动去重）。

**用法示例**：

```kotlin
// 1. 定义 StateFlow（通常用 MutableStateFlow 作为实现）
private val _uiState = MutableStateFlow<UiState>(UiState.Loading) // 初始值
val uiState: StateFlow<UiState> = _uiState.asStateFlow() // 暴露不可变接口

// 2. 更新状态（在协程中）
viewModelScope.launch {
    val data = apiService.fetchData()
    _uiState.value = UiState.Success(data) // 更新值，自动通知收集者
}

// 3. 收集状态（在 UI 层）
@Composable
fun MyScreen(viewModel: MyViewModel) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle() // Compose 专用收集方式
    when (uiState) {
        is UiState.Loading -> Text("加载中...")
        is UiState.Success -> Text("数据：${uiState.data}")
    }
}
```

**适用场景**：

- UI 状态管理（加载中 / 成功 / 失败状态）。
- 全局状态共享（如用户登录状态）。



### `SharedFlow`——“多播数据流”

`SharedFlow` 是更通用的热流，支持**向多个收集者发送数据**（多播），核心特点：

- 无默认值，需要手动配置缓存策略（如缓存最近 3 条数据）。
- 可配置重放策略（新收集者是否接收历史数据）。

**用法示例**：

```kotlin
// 1. 定义 SharedFlow（用 MutableSharedFlow 实现）
private val _events = MutableSharedFlow<Event>(
    replay = 0, // 不重放历史数据
    extraBufferCapacity = 16 // 缓冲区大小
)
val events: SharedFlow<Event> = _events.asSharedFlow()

// 2. 发送数据
viewModelScope.launch {
    _events.emit(Event.ShowToast("操作成功")) // 发送事件
}

// 3. 多个收集者
viewModelScope.launch {
    events.collect { event -> /* 处理事件 1 */ }
}
viewModelScope.launch {
    events.collect { event -> /* 处理事件 2 */ }
}
```

**适用场景**：

- 一次性事件（如弹窗、Toast、导航指令）。
- 多组件共享的数据流（如实时消息）。



# `Channel`——任务队列

Kotlin 协程中的 `Channel` 是用于**协程间通信**的核心组件，它实现了生产者 - 消费者模式，允许一个或多个协程发送数据，另一个或多个协程接收数据，并且支持挂起操作，是协程间同步和传递信息的重要工具。



## Channel 的核心概念

`Channel` 本质上是一个**阻塞队列**，但专为协程设计，具有以下特点：

- **双向通信**：支持 `send()` 发送数据和 `receive()` 接收数据，两者都是挂起函数。
- **协作式阻塞**：当通道为空时，`receive()` 会挂起等待；当通道满时，`send()` 会挂起等待（取决于缓冲策略）。
- **生命周期管理**：支持关闭（`close()`），关闭后无法发送数据，但可接收剩余数据。



## 基本用法

**创建 Channel 并发送 / 接收数据**

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel

fun main() = runBlocking {
    // 创建一个通道（默认无缓冲，即 rendezvous 模式）
    val channel = Channel<Int>()
    
    // 启动生产者协程（发送数据）
    launch {
        for (i in 1..3) {
            channel.send(i) // 发送数据，若通道满则挂起
            println("发送: $i")
        }
        channel.close() // 发送完毕，关闭通道
    }
    
    // 启动消费者协程（接收数据）
    launch {
        // 循环接收，直到通道关闭且数据为空
        for (value in channel) {
            println("接收: $value")
        }
        println("接收完毕")
    }
}
```

输出：

```plaintext
发送: 1
接收: 1
发送: 2
接收: 2
发送: 3
接收: 3
接收完毕
```



**缓冲策略**

`Channel` 有多种缓冲策略（通过构造函数参数指定），决定了通道可缓存的数据量：

- **无缓冲（默认）**：`Channel<Int>()` 或 `Channel<Int>(0)`，发送和接收必须同时就绪（类似 “握手”）。
- **有界缓冲**：`Channel<Int>(3)`，最多缓存 3 个数据，满时 `send()` 挂起。
- **无界缓冲**：`Channel<Int>(Channel.UNLIMITED)`，可无限缓存数据，`send()` 永不挂起（可能导致内存溢出）。
- **conflated 缓冲**：`Channel<Int>(Channel.CONFLATED)`，只保留最新数据，旧数据被覆盖，`send()` 永不挂起。

示例（有界缓冲）：

```kotlin
val channel = Channel<Int>(2) // 最多缓存2个数据
launch {
    channel.send(1) // 成功（缓存1）
    channel.send(2) // 成功（缓存2）
    channel.send(3) // 通道满，挂起等待
}
```



## 常用操作

### 1. 关闭通道

- `channel.close()`：关闭通道，后续 `send()` 会抛出 `ClosedSendChannelException`。
- 接收方可以通过 `for (value in channel)` 自动感知关闭，循环会在通道空且关闭后退出。



### 2. 迭代接收

除了 `for` 循环，还可以用 `receiveCatching()` 安全接收（返回 `Result`）：

```kotlin
launch {
    while (true) {
        val result = channel.receiveCatching()
        if (result.isFailure) break
        println("接收: ${result.getOrNull()}")
    }
}
```



### 3. 多路复用（select）

结合 `select` 表达式，可以同时等待多个通道的事件（如接收或发送）：

```kotlin
import kotlinx.coroutines.selects.select

suspend fun selectChannel(ch1: Channel<Int>, ch2: Channel<Int>): Int = select {
    ch1.onReceive { it } // 若ch1有数据，接收并返回
    ch2.onReceive { it } // 若ch2有数据，接收并返回
}
```



## 典型应用场景

1. **生产者 - 消费者模型**：多个生产者向通道发送任务，一个消费者串行处理（类似前文的单队列模型）。
2. **协程间数据传递**：例如在后台协程获取数据后，通过通道发送到 UI 协程更新界面。
3. **限流**：利用有界缓冲的 `Channel` 控制并发任务数量（如限制同时运行的网络请求数）。
4. **事件总线**：通过一个全局 `Channel` 分发事件，多个订阅者接收处理。



## 与队列的区别

| 特性       | Java 阻塞队列（如 ArrayBlockingQueue） | Kotlin Channel                      |
| ---------- | -------------------------------------- | ----------------------------------- |
| 阻塞方式   | 阻塞线程                               | 挂起协程（非阻塞线程）              |
| 与协程配合 | 需要手动管理线程，容易阻塞             | 天然支持协程，无缝集成挂起函数      |
| 关闭机制   | 需额外逻辑处理                         | 内置 `close()` 方法，自动通知接收方 |
| 多路复用   | 不支持                                 | 可通过 `select` 实现                |



## 线程安全问题

Kotlin 协程中的 `Channel` 是**线程安全**的。它的设计目标之一就是支持多协程（可能运行在不同线程）同时进行发送（`send()`）和接收（`receive()`）操作，而无需额外的同步机制。



### 线程安全的具体体现

1. **多协程并发操作安全**
   多个协程可以同时调用 `send()` 发送数据，或调用 `receive()` 接收数据，`Channel` 内部会处理并发控制，确保数据传递的原子性和顺序性。

   示例（多生产者 - 单消费者）：

   ```kotlin
   import kotlinx.coroutines.*
   import kotlinx.coroutines.channels.Channel
   
   fun main() = runBlocking {
       val channel = Channel<Int>(Channel.UNLIMITED)
       
       // 启动3个生产者协程（可能在不同线程）
       repeat(3) { producerId ->
           launch(Dispatchers.IO) {
               for (i in 1..3) {
                   val value = producerId * 10 + i
                   channel.send(value)
                   println("生产者$producerId 发送: $value")
               }
           }
       }
       
       // 启动1个消费者协程
       launch {
           repeat(9) { // 总共9个数据
               val value = channel.receive()
               println("接收: $value")
           }
           channel.close()
       }
   }
   ```

   输出（顺序可能因调度略有不同，但数据不会错乱）：

   ```plaintext
   生产者0 发送: 1
   生产者1 发送: 11
   生产者2 发送: 21
   接收: 1
   接收: 11
   接收: 21
   ...（后续数据依次处理）
   ```

2. **内部同步机制**
   `Channel` 内部通过锁或无锁算法实现了线程安全（具体实现依赖于 `Channel` 的类型，如 `ArrayChannel`、`LinkedListChannel` 等），开发者无需手动添加 `synchronized` 或其他锁机制。

3. **关闭操作的安全性**
   调用 `close()` 后，`Channel` 会原子性地切换到关闭状态，确保：

   - 后续 `send()` 操作会抛出 `ClosedSendChannelException`
   - 已发送的数据可以被正常接收
   - 多个协程同时调用 `close()` 不会导致状态不一致

### 注意事项

虽然 `Channel` 本身是线程安全的，但使用时仍需注意：

1. **避免在非协程环境中使用**
   `send()` 和 `receive()` 是挂起函数，只能在协程中调用。如果在普通线程中强行使用（如通过 `runBlocking` 包装），可能会影响性能或导致死锁。

2. **缓冲策略的影响**
   线程安全不改变 `Channel` 的缓冲行为：例如，无缓冲的 `Channel` 仍要求发送方和接收方 “rendezvous”（同时就绪），只是并发调用时不会导致数据错误。

3. **关闭后的操作**
   通道关闭后，继续发送数据会抛出异常，需通过 `isClosedForSend` 或 `isClosedForReceive` 检查状态：

   ```kotlin
   if (!channel.isClosedForSend) {
       channel.send(data)
   }
   ```

### 小结

`Channel` 是线程安全的组件，专门为多协程（可能跨线程）并发通信设计，内部已实现同步机制。这使得它可以安全地用于生产者 - 消费者模型、多协程协作等场景，无需开发者手动处理线程同步问题。



## 总结

`Channel` 是协程间通信的桥梁，通过**挂起式的发送和接收**实现了高效的协作，避免了线程阻塞。它的缓冲策略、关闭机制和与 `select` 的结合，使其能灵活应对各种协程通信场景，是 Kotlin 协程生态中不可或缺的组件。



# 关键误区与最佳实践

1. **协程取消与资源释放**：

   - 协程取消是 “协作式” 的：需在 `suspend` 函数中响应取消（如定期调用 `delay`、`yield`，或检查 `isActive`）。

   - 用 `finally` 释放资源：

     ```kotlin
     viewModelScope.launch {
         try { /* 执行任务 */ }
         finally { /* 释放资源（如关闭流、取消订阅） */ }
     }
     ```

2. **`StateFlow` 避免频繁更新**：

   - 由于 `StateFlow` 会自动去重（值不变则不发送），建议用 `data class` 存储状态（重写 `equals`）。

3. **`Flow` 收集需在作用域内**：

   - 忘记在 `CoroutineScope` 内调用 `collect` 会导致编译错误，且必须处理取消（避免泄露）。

4. **KMP 中的协程注意点**：

   - 跨平台项目中，`Dispatchers.Main` 在不同平台实现不同（Android 是主线程，iOS 是主队列，桌面是 UI 线程），需依赖 `kotlinx-coroutines-core` 的平台适配库。
