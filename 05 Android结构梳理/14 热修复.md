# 资源修复

## Instant Run概述

Instant Run是Android Studio 2.0以后新增的一个运行机制，能够显著减少开发人员第二次及以后的构建和部署时间。

Instant Run的构建和部署都是基于更改的部分的。
Instant Run部署有三种方式，Instant Run会根据代码的情况来决定采用哪种部署方式，无论哪种方式都不需要重新安装App，这点就已经提高了不少的效率：

-   Hot swap：从名称也可以看出Hot Swap是效率最高的部署方式，代码的增量改变不
    需要重启App，甚至不需要重启当前的Activity。修改一个现有方法中的代码时会采用Hot Swap。
-   Warm Swap：App不需重启，但是Activity需要重启。修改或删除个现有的资源文件时会采用Warm Swap。
-   ColdSwap：App需要重启，但是不需要重新安装。采用Cold Swap的情况很多，比如添加、删除或修改一个字段和方法、添加一个类等。

## Instant Run的资源修复

很多热修复的框架资源修复参考了Instant Run的资源修复原理，那么了解Instat Run的资源修复原理就可以了。Instant Run并不是Android的源码，需要通过反编译获取，可以参考相关书籍。

>   源码可以从这里获取：[Android Instant Run原理分析](https://github.com/nuptboyzhb/AndroidInstantRun)，作者：[nuptboyzhb](https://github.com/nuptboyzhb)

Instat Run资源修复的核心逻辑在MonkeyPatcher的monkeyPatchExistingResources方法中，如下所示:

```java
package com.android.tools.fd.runtime;

//...

public static void monkeyPatchExistingResources(Context context, String externalResourceFile, Collection<Activity> activities) {
   if (externalResourceFile == null) {
      return;
   }
  
   //创建一个新的AssetManager
   try {
      AssetManager newAssetManager = (AssetManager) AssetManager.class.getConstructor(new Class[0]).newInstance(new Object[0]);
     
     	//通过反射调用addAssetPath方法加载外部的资源
      Method mAddAssetPath = AssetManager.class.getDeclaredMethod(
            "addAssetPath", new Class[] { String.class });
      mAddAssetPath.setAccessible(true);
      if (((Integer) mAddAssetPath.invoke(newAssetManager, new Object[] { externalResourceFile })).intValue() == 0) {
         throw new IllegalStateException(
               "Could not create new AssetManager");
      }
     
      Method mEnsureStringBlocks = AssetManager.class.getDeclaredMethod("ensureStringBlocks", new Class[0]);
      mEnsureStringBlocks.setAccessible(true);
      mEnsureStringBlocks.invoke(newAssetManager, new Object[0]);
      if (activities != null) {
         for (Activity activity : activities) {
           	//获取每个Activity的Resources
            Resources resources = activity.getResources();
            try {
               //反射得到Resources的AssetManager类型的mAssets字段
               Field mAssets = Resources.class .getDeclaredField("mAssets");
               mAssets.setAccessible(true);
               //将mAssets引用替换为新创建的AssetManager。
               mAssets.set(resources, newAssetManager);
            } catch (Throwable ignore) {
               //。。。
            }
            
           	//得到Activity的Resources.Theme
            Resources.Theme theme = activity.getTheme();
            try {
               try {
                  //反射得到Resources.Theme的AssetManager类型的mAssets字段。
                  Field ma = Resources.Theme.class.getDeclaredField("mAssets");
                  ma.setAccessible(true);
                  //将Resources.Theme的mAssets替换为newAssetManager
                  ma.set(theme, newAssetManager);
               } catch (NoSuchFieldException ignore) {
                  //。。
               }
               //。。。
            } catch (Throwable e) {
               //。。。
            }
            pruneResourceCaches(resources);
         }
      }
     
      //根据SDK版本的不同，用不同的方式得到Resources的弱引用集合
      Collection<WeakReference<Resources>> references;
      if (Build.VERSION.SDK_INT >= 19) {
         Class<?> resourcesManagerClass = Class.forName("android.app.ResourcesManager");
         Method mGetInstance = resourcesManagerClass.getDeclaredMethod("getInstance", new Class[0]);
         mGetInstance.setAccessible(true);
         Object resourcesManager = mGetInstance.invoke(null, new Object[0]);
         try {
            Field fMActiveResources = resourcesManagerClass.getDeclaredField("mActiveResources");
            fMActiveResources.setAccessible(true);

            ArrayMap<?, WeakReference<Resources>> arrayMap = (ArrayMap) fMActiveResources.get(resourcesManager);
            references = arrayMap.values();
         } catch (NoSuchFieldException ignore) {
            //。。。
         }
      } else {
         Class<?> activityThread = Class.forName("android.app.ActivityThread");
         Field fMActiveResources = activityThread.getDeclaredField("mActiveResources");
         fMActiveResources.setAccessible(true);
         Object thread = getActivityThread(context, activityThread);

         HashMap<?, WeakReference<Resources>> map = (HashMap) fMActiveResources.get(thread);

         references = map.values();
      }
      for (WeakReference<Resources> wr : references) {
         Resources resources = (Resources) wr.get();
         if (resources != null) {
            try {
               Field mAssets = Resources.class.getDeclaredField("mAssets");
               mAssets.setAccessible(true);
               mAssets.set(resources, newAssetManager);
            } catch (Throwable ignore) {
               //。。。
            }
            resources.updateConfiguration(resources.getConfiguration(),
                  resources.getDisplayMetrics());
         }
      }
   } catch (Throwable e) {
      //。。。
   }
}
```

### 小结

可以看出Instant Run中的资源热修复可以简单地总结为两个步骤：

1. 创建新的AssetManager，通过反射调用addAssetPath方法加载外部的资源，这样新创建的AssetManager就含有了外部资源。
2. 将AssetManager类型的mAssets字段的引用全部替换为新创建的AssetManager。

# 代码修复

代码修复主要有3个方案，分别是类加载方案、底层替换方案和Instant Run方案。

## 类加载方案

类加载方案基于Dex分包方案。

Dex分包方案设计到64k限制和LinearAlloc限制。

  1. **65536限制**
     随着应用功能越来越复杂，代码量不断地增大，引入的库也越来越多，可能会在编译时提示如下异常：

     ```
     com.android.dex.DexIndexOverflowException: method ID not in [0,0ffff]: 65536
     ```

     这说明应用中引用的方法数超过了最大数65536个。产生这问题的原因就是系统的65536限制，65536限制的主要原因是DVM Bytecode的限制，DVM指令集的方法调用指令invoke-kind索引为16bits，最多能引用65535个方法。

         1. **LinearAlloc限制**
         在安装应用时可能会提示`INSTALL_FAILED _DEXOPT`，产生的原因就是LinearAlloc限制，DVM中的LinearAlloc是一个固定的缓存区，当方法数超出了缓存区的大小时会报错。

为了解决65536限制和LinearAlloc限制，从而产生了Dex分包方案。

Dex分包方案主要做的是在打包时将应用代码分成多个Dex，将应用启动时必须用到的类和这些类的直接引用类放到主Dex中，其他代码放到次Dex中。当应用启动时先加载主Dex，等到应用启动后再动态地加载次Dex，从而缓解了主Dex的65536限制和LinearAlle限制。Dex分包方案主要有两种，分别是Google官方方案、Dex自动拆包和动态加载方案。

在Android的ClassLoader的加载过程中，有一个环节是调用DexPathList的findClass方法。

```java
public Class<?> findClass(String name, List<Throwable> suppressed) {
    for (Element element : dexElements) {
        Class<?> clazz = element.findClass(name, definingContext, suppressed);
        if (clazz != null) {
            return clazz;
        }
    }
    if (dexElementsSuppressedExceptions != null) {
		suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
```

Element内部封装了DexFile，DexFile 用于加载dex文件，因此每个dex文件对应一个Element。多个Element组成了有序的Element数组dexElements。
当要查找类时，会遍历Element数组dexElemets(相当于遍历dex文件数组)，然后调用Element的findClass方法，其方法内部会调用DexFile的loadCalssBinaryName方法查找类。如果在Element中(dex文件)找到了该类就返回，如果没有找到就接着在下一个Element 中进行查找。

根据上面的查找流程，将有Bug的类Key.class进行修改，再将Key.class打包成包含dex的补丁包Pach.jar，放在Element数组dexElements的第一个元素， 这样会首先找到Patch.dex中的Key.class去替换之前存在Bug的Key.class，排在数组后面的dex文件中存在Bug的Key.class根据ClassLoader的双亲委托模式就不会被加载，这就是类加载方案，如图所示。

![272](/Users/mezzsy/Projects/Blog/Android/assets/272.jpg)

类加载方案需要重启App后让ClassLoader重新加载新的类。这是因为类是无法被卸载的，要想重新加载新的类就需要重启App，因此采用类加载方案的热修复框架是不能即时生效的。

虽然很多热修复框架采用了类加载方案，但具体的实现细节和步骤还是有一些区别的，如：

-   QQ空间的超级补丁和Nuwa是按照上面说的将补丁包放在Element数组的第一个元素得到优先加载。 
-   微信Tinker将新旧APK做了diff，得到patch.dex，再将path.dex与手机中APK的classes.dex做合并，生成新的classes.dex，然后在运行时通过反射将classes.dex放在Element数组的第一个元素。
-   饿了么的Amigo是将补丁包中每个dex对应的Element取出来，之后组成新的Element数组，在运行时通过反射用新的Element数组替换掉现有的Element数组。

采用类加教方案的主要是以腾讯系为主，包括微信的Tnker. QQ空间的超级补丁、手机QQ的QFix、饿了么的Amigo和Nuwa等。

## 底层替换方案

与类加载方案不同的是，底层替换方案不会再次加载新类，而是直接在Native层修改原有类，由于在原有类进行修改限制会比较多，且不能增减原有类的方法和字段。如果增加了方法数，那么方法索引数也会增加，这样访问方法时会无法通过索引找到正确的方法，同样的字段也是类似的情况。

底层替换方案和反射的原理有些关联，就拿方法替换来说，方法反射可以通过调用`java.lang.Class.getDeclaredMethod`，假设要反射Key的show方法，会调用如下所示的代码：

```java
Key.class.getDeclaredMethod("show").invoke(Key.class.newInstance());
```

Android 8.0的invoke方法，如下所示：

**Method#invoke**

```java
@FastNative
public native Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException;
```

invoke方法是一个native方法，对于jni层的代码为：

**java_lang_reflect_Method#Method_invoke**

```c
static jobject Method_invoke(JNIEnv* env, jobject javaMethod, jobject javaReceiver, jobject javaArgs) {
  	ScopedFastNativeObjectAccess soa(env);
  	return InvokeMethod(soa, javaMethod, javaReceiver, javaArgs);
}
```

在Method_invoke函数中又调用了InvokeMethod函数：

**reflection#InvokeMethod**

```c
jobject InvokeMethod(const ScopedObjectAccessAlreadyRunnable& soa, jobject javaMethod, jobject javaReceiver, jobject javaArgs, size_t num_frames) {
  //。。。
  
  ObjPtr<mirror::Executable> executable = soa.Decode<mirror::Executable>(javaMethod);
  const bool accessible = executable->IsAccessible();
  ArtMethod* m = executable->GetArtMethod();//注释1
	
  //。。。
}
```

注释1处获取传入的javaMethod(Key的show方法)在ART虚拟机中对应的一个ArtMethod指针，ArtMethod结构体中包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等，ArtMethod结构如下所示:

```c++
class ArtMethod FINAL {
 //...
  
 protected:
  GcRoot<mirror::Class> declaring_class_;
  std::atomic<std::uint32_t> access_flags_;
  uint32_t dex_code_item_offset_;
  uint32_t dex_method_index_;
  uint16_t method_index_;
  uint16_t hotness_count_;
  
  struct PtrSizedFields {
    ArtMethod** dex_cache_resolved_methods_;//注释1
    void* data_;
    void* entry_point_from_quick_compiled_code_;//注释2
  } ptr_sized_fields_;
 
 //。。。
}
```

在ArtMethod结构中比较重要的字段是注释1处的`dex_cache_resolved_methods_`和注释2处的`entry_point_from_quick_compiled_code_`，它们是方法的执行入口，当调用某一个方法时(比如Key的show方法)，就会取得show方法的执行入口，通过执行入口就可以跳过去执行show方法。替换ArtMethod结构体中的字段或者替换整个ArtMethod结构体，这就是底层替换方案。

-   AndFix采用的是替换ArtMethod结构体中的字段，这样会有兼容问题，因为厂商可能会修改ArtMethod结构体，导致方法替换失败。
-   Sophix采用的是替换整个ArtMethod结构体，这样不会存在兼容问题。

底层替换方案直接替换了方法，可以立即生效不需要重启。采用底层替换方案主要是阿里系为主，包括AndFix、Dexposed、 阿里百川、Sophix。

## Instant Run方案

Instant Run在第一次构建 APK时，使用ASM在每一个方法中注入了类似如下的代码：

```java
IncrementalChange localIncrementalChange = $change;//1
if (localIncrementalChange != null){//2
  	localIncrementalChange.access$dispath("onCreate.(Landroid/os/Bundel;)V", new Object[] {this, paramBundle });
  	return;
}
`$change`
  `MainActivity$override`
  `access$dispatch`
```

其中注释1处是一个成员变量localIncrementalChange，它的值为`$change`，`$change`现了IncrementalChange这个抽象接口。
当点击Instant Run时，如果方法没有变化则`$change`为null，就调用return，不做任何处理。
如果方法有变化，就生成替换类，这里假设MainActivity的onCreate方法做了修改，就会生成替换类`MainActivity$override`，这个类实现了IncrementalChange接口，同时也会生成一个AppPatchesLoaderlmpl类，这个类的getPatchedClasses方法会返回被修改的类的列表(里面包含了MainActivity)，根据列表会将MainActivity的`$change`设置为`MainActivity$override`，因此满足了注释2的条件，会执行`MainActivity$override`的`access$dispatch`方法，在`access$dispatch`方法中会根据参数`"onCreate.(Landroid/os/Bundel;)V"`执行`MainActivity$override`的onCreate方法，从而实现了onCreate方法的修改。

借鉴Instant Run的原理的热修复框架有Robust和Aceso。

> 什么是ASM？
>
> ASM是一个Java字节码操控框架，它能够动态生成类或者增强现有类的功能。ASM可以直接产生class文件，也可以在类被加载到虚拟机之前动态改变类的行为。

# 动态链接库的修复

Android平台的动态链接库主要指的是so库。热修复框架的so的修复的主要是更新so，换句话说就是重新加载so，因此so的修复的基础原理就是加载so。

加载so主要用到了System类的load和loadLibarary方法，如下所示：

```java
public final class System {
		//... 
  	@CallerSensitive
    public static void load(String filename) {
        Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);
    }
  
  	@CallerSensitive
    public static void loadLibrary(String libname) {
        Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);
    }
  	//。。。
}
```

System的load方法传入的参数是so在磁盘的完整路径，用于加载指定路径的so。

System的loadLibrary方法传入的参数是so的名称，用于加载App安装后自动从apk包中复制到`/data/data/packagename/lib`下的so。

目前so的修复都是基于这两个方法。

## System的load方法

```java
public final class System {
  	@CallerSensitive
    public static void load(String filename) {
        Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);
    }
}
```

Runtime.getRuntime()会得到当前Java应用程序的运行环境Runtime，Runtime的load()方法如下所示：

### Runtime#load0

```java
synchronized void load0(Class<?> fromClass, String filename) {
		if (!(new File(filename).isAbsolute())) {
				throw new UnsatisfiedLinkError("Expecting an absolute path of the library: " + filename);
		}
  
    if (filename == null) {
      	throw new NullPointerException("filename == null");
    }
    String error = doLoad(filename, fromClass.getClassLoader());//1
    if (error != null) {
        throw new UnsatisfiedLinkError(error);
    }
}
```

在注释1处调用了doLoad方法，并将加载该类的类加载器作为参数传入进去。

```java
private String doLoad(String name, ClassLoader loader) {
		String librarySearchPath = null;
		if (loader != null && loader instanceof BaseDexClassLoader) {
				BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;
				librarySearchPath = dexClassLoader.getLdLibraryPath();
		}
		synchronized (this) {
				return nativeLoad(name, loader, librarySearchPath);
		}
}
```

doLoad方法会调用native方法nativeLoad（nativeLoad后续分析）。

## System的loadLibrary方法

```java
public final class System {
  	@CallerSensitive
    public static void loadLibrary(String libname) {
        Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);
    }
}
```

调用Runtime的loadLibrary0方法：

```java
synchronized void loadLibrary0(ClassLoader loader, String libname) {
    if (libname.indexOf((int)File.separatorChar) != -1) {
        throw new UnsatisfiedLinkError("Directory separator should not appear in library name: " + libname);
    }
    String libraryName = libname;
    if (loader != null) {
        String filename = loader.findLibrary(libraryName);//注释1
        if (filename == null) {
            throw new UnsatisfiedLinkError(loader + " couldn't find \"" + System.mapLibraryName(libraryName) + "\"");
        }
        String error = doLoad(filename, loader);//注释2
        if (error != null) {
            throw new UnsatisfiedLinkError(error);
        }
        return;
    }

    String filename = System.mapLibraryName(libraryName);
    List<String> candidates = new ArrayList<String>();
    String lastError = null;
    for (String directory : getLibPaths()) {//注释3
        String candidate = directory + filename;//注释4
        candidates.add(candidate);

        if (IoUtils.canOpenReadOnly(candidate)) {
            String error = doLoad(candidate, loader);//注释5
            if (error == null) {
                return; 
            }
            lastError = error;
        }
    }

    if (lastError != null) {
        throw new UnsatisfiedLinkError(lastError);
    }
    throw new UnsatisfiedLinkError("Library " + libraryName + " not found; tried " + candidates);
}
```

loadLibrary0方法分为两个部分，一个是传入的ClassLoader不为null的部分，另一个是ClassLoader为null的部分。

先来看ClassLoader 为null 的部分。
在**注释3**处遍历getLibPaths方法，这个方法会返回`java.library.path`选项配置的路径数组。
在**注释4**处拼接出so路径并传入**注释5**处调用的doLoad方法中。

当ClassLoader不为null时。
在**注释2**处同样调用了doLoad方法，其中第一个参数是通过**注释1**处的ClassLoader的findLibrary方法来得到的，findLibrary方法在ClassLoader的实现类BaseDexClassLoader中实现。

### BaseDexClassLoader#findLibrary

```java
public String findLibrary(String name) {
    return pathList.findLibrary(name);
}
```

在findLibrary方法中调用了DexPathList的findLibrary方法：

```java
public String findLibrary(String libraryName) {
    String fileName = System.mapLibraryName(libraryName);
    for (NativeLibraryElement element : nativeLibraryPathElements) {
        String path = element.findNativeLibrary(fileName);//注释1

        if (path != null) {
            return path;
        }
    }
    return null;
}
```

这和DexPathList的findClass方法类似，在NativeLibraryElement数组中的每一个NativeLibraryElement对应一个so库，在**注释1**处调用NativeLibraryElement的findNativeLibrary方法就可以返回so的路径。

上面的代码结合类加载方案，就可以得到so的修复的一种方案，就是将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回，并调用Runtime的doLoad方法进行加载，在doLoad方法中会调用native方法nativeLoad。

**System的load方法和loadLibrary方法在Java FrameWork层最终调用的都是nativeLoad方法。**

## nativeLoad方法分析

nativeLoad方法对应的JNI层函数如下所示: 

### Runtime.c#Runtime_nativeLoad

```c
JNIEXPORT jstring JNICALL
Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,
                   jobject javaLoader, jstring javaLibrarySearchPath)
{
    return JVM_NativeLoad(env, javaFilename, javaLoader, javaLibrarySearchPath);
}
```

在Runtime_nativeLoad函数中调用了JVM_NativeLoad函数：

```c
JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,
                                 jstring javaFilename,
                                 jobject javaLoader,
                                 jstring javaLibrarySearchPath) {
  //将so的文件名转换为ScopeUtfChars
  ScopedUtfChars filename(env, javaFilename);
  if (filename.c_str() == NULL) {
    return NULL;
  }

  std::string error_msg;
  {
    //注释1，获取当前运行时的虚拟机
    art::JavaVMExt* vm = art::Runtime::Current()->GetJavaVM();
    //虚拟机加载so
    bool success = vm->LoadNativeLibrary(env,
                                         filename.c_str(),
                                         javaLoader,
                                         javaLibrarySearchPath,
                                         &error_msg);
    if (success) {
      return nullptr;
    }
  }

  // Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.
  env->ExceptionClear();
  return env->NewStringUTF(error_msg.c_str());
}
```

在注释1处获取当前运行时的JavaVMExt类型指针，JavaVMExt用于代表一个虚拟机实例，紧接着调用JavaVMExt的LoadNativeLibrary函数来加载so。

### java_vm_ext.cc#LoadNativeLibrary

**第一部分**

```c
bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,
                                  const std::string& path,
                                  jobject class_loader,
                                  jstring library_path,
                                  std::string* error_msg) {
  error_msg->clear();
  SharedLibrary* library;
  Thread* self = Thread::Current();
  {
    MutexLock mu(self, *Locks::jni_libraries_lock_);
    library = libraries_->Get(path);//根据so的名称从libraries中获取对应的SharedLibrary类型指针library
  }
  //...
  
  if (library != nullptr) {//如果满足此处的条件就说明此前加载过该so
    
    if (library->GetClassLoaderAllocator() != class_loader_allocator) {//如果此前加载用的ClassLoader和当前传入的ClassLoader不相同的话，就会返回false
      
      StringAppendF(error_msg, "Shared library \"%s\" already opened by ClassLoader %p; can't open in ClassLoader %p", path.c_str(), library->GetClassLoader(), class_loader);
      LOG(WARNING) << error_msg;
      return false;
    }
    //。。。
    
    if (!library->CheckOnLoadResult()) {//判断上次加载so的结果，如果有异常也会返回false，中断so加载。
      StringAppendF(error_msg, "JNI_OnLoad failed on a previous attempt to load \"%s\"", path.c_str());
      return false;
    }
    
    //以上条件满足，则不再重复加载so。
    return true;
  }
	//...
}
```

**第二部分**

```c
bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,
                                  const std::string& path,
                                  jobject class_loader,
                                  jstring library_path,
                                  std::string* error_msg) {
  //。。。
  Locks::mutator_lock_->AssertNotHeld(self);
  const char* path_str = path.empty() ? nullptr : path.c_str();
  bool needs_native_bridge = false;
  
  //打开路径path_str的so库，得到so句柄handle。
  void* handle = android::OpenNativeLibrary(env,
                                            runtime_->GetTargetSdkVersion(),
                                            path_str,
                                            class_loader,
                                            library_path,
                                            &needs_native_bridge,
                                            error_msg);
	//。。。
  if (handle == nullptr) {//如果获取so句柄失败就会返回false，中断so加载。
    VLOG(jni) << "dlopen(\"" << path << "\", RTLD_NOW) failed: " << *error_msg;
    return false;
  }

  if (env->ExceptionCheck() == JNI_TRUE) {
    LOG(ERROR) << "Unexpected exception:";
    env->ExceptionDescribe();
    env->ExceptionClear();
  }
  bool created_library = false;
  {
    //新创建SharedLibrary, 并将so句柄作为参数传入进去。
    std::unique_ptr<SharedLibrary> new_library(
        new SharedLibrary(env,
                          self,
                          path,
                          handle,
                          needs_native_bridge,
                          class_loader,
                          class_loader_allocator));

    MutexLock mu(self, *Locks::jni_libraries_lock_);
    library = libraries_->Get(path);//获取传入path对应的library，如果library为空指针，就将新创建的SharedLibrary赋值给library，并将library存储到libraries中。
    
    //。。。
}
```

**第三部分**

```c
bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,
                                  const std::string& path,
                                  jobject class_loader,
                                  jstring library_path,
                                  std::string* error_msg) {
  //。。。
  
  bool was_successful = false;
  void* sym = library->FindSymbol("JNI_OnLoad", nullptr);//查找JNI_OnLoad函数的指针并赋值给空指针sym，JNI_OnLoad函数用于native方法的动态注册。
  if (sym == nullptr) {//如果没有找到JNI_OnLoad函数就将was_successful赋值为true, 说明已经加载成功。没有找到JNI_OnLoad函数也算加载成功，这是因为并不是所有so都定义了JNI_OnLoad函数，因为native方法除了动态注册，还有静态注册。
    
    VLOG(jni) << "[No JNI_OnLoad found in \"" << path << "\"]";
    was_successful = true;
  } else {
    ScopedLocalRef<jobject> old_class_loader(env, env->NewLocalRef(self->GetClassLoaderOverride()));
    self->SetClassLoaderOverride(class_loader);
    VLOG(jni) << "[Calling JNI_OnLoad in \"" << path << "\"]";
    typedef int (*JNI_OnLoadFn)(JavaVM*, void*);
    JNI_OnLoadFn jni_on_load = reinterpret_cast<JNI_OnLoadFn>(sym);
    int version = (*jni_on_load)(this, nullptr);//如果找到了JNI_OnLoad函数，就在注释3处执行JNI_OnLoad函数并将结果赋值给version。

    //。。。

    if (version == JNI_ERR) {//如果version为JNI_ERR或者Bad JNI version，说明没有执行成功，was_successful的值仍旧为默认的false，否则就将was_successful赋值为true，最终会返回该was_successful。
      
      StringAppendF(error_msg, "JNI_ERR returned from JNI_OnLoad in \"%s\"", path.c_str());
    } else if (JavaVMExt::IsBadJniVersion(version)) {
      StringAppendF(error_msg, "Bad JNI version returned from JNI_OnLoad in \"%s\": %d", path.c_str(), version);
    } else {
      was_successful = true;
    }
    VLOG(jni) << "[Returned " << (was_successful ? "successfully" : "failure") << " from JNI_OnLoad in \"" << path << "\"]";
  }

  library->SetResult(was_successful);
  return was_successful;
}
```

#### 小结

LoadNativeLibrary函数主要做了如下3方面工作。

1. 判断so是否被加载过，两次ClassLoader是否是同一个，避免so重复加载。
2. 打开so并得到so句柄，如果so句柄获取失败，就返回false。创建新的SharedLibrary，如果传入path对应的library为空指针，就将新创建的SharedLibrary赋值给library，并将library存储到libraries中。
3. 查找JNI_OnLoad的函数指针，根据不同情况设置was_successful的值，最终返回该was_successful。

![273](/Users/mezzsy/Projects/Blog/Android/assets/273.jpg)

## 小结

so修复主要有两个方案：

1. 将so补丁插入到NativeLibraryElement数组的前部，让so补丁的路径先被返回和加载。
2. 调用System的load方法来接管so的加载入口。

# Demo

## AndFix的使用

github地址：https://github.com/alibaba/AndFix

### 介绍

AndFix，全称是Android hot-fix。是阿里开源的一个热补丁框架，允许APP在不重新发布版本的情况下修复线上的bug。支持**Android 2.3到7.0**，并且支持arm 与 X86系统架构的设备。完美支持Dalvik与ART的Runtime，补丁文件是以 .apatch 结尾的文件。

### 具体使用

#### 添加依赖

```
compile 'com.alipay.euler:andfix:0.5.0@aar'
```

#### 代码

先给出代码

布局很简单，两个按钮，点击修复可以实现热修复，点击BUG会出现Toast，提示“BUG”，当修复后，会提示“BUG修复”。

```java
public class MainActivity extends AppCompatActivity {
    private static final String TAG = "MainActivity";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        requestStoragePermissions();
        Button fix = findViewById(R.id.fix);
        Button bug = findViewById(R.id.bug);

        bug.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(MainActivity.this, "BUG", Toast.LENGTH_SHORT).show();
            }
        });

        fix.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                PatchUtils.loadPatch(getApplicationContext());
            }
        });
    }

    private void requestStoragePermissions() {
        ActivityCompat.requestPermissions(this
                , new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
    }
}
```

```java
public class PatchUtils {
    private static final String TAG = "euler";
    private static final String TULIPSPORT_PATCHES = "/文件";
    private static final String DIR = "apatch";//补丁文件夹
    /**
     * patch manager
     */
    public static PatchManager mPatchManager;

    public static void loadPatch(Context context) {
        mPatchManager = new PatchManager(context);
        mPatchManager.init(getVersionName(context));
        mPatchManager.loadPatch();
        try {
            File dir = new File(Environment.getExternalStorageDirectory()
                    .getAbsolutePath() + TULIPSPORT_PATCHES);
            String loadPatchName = Environment.getExternalStorageDirectory()
                    .getAbsolutePath() + TULIPSPORT_PATCHES + "/" +
                    String.valueOf(getVersionCode(context))
                    + "_" +
                    FileUtils.getLoadPatchName(dir,
                            "apatch", String.valueOf(getVersionCode(context) + 1)) + ".apatch";
            Log.d(TAG, loadPatchName);
            mPatchManager.addPatch(loadPatchName);
            Log.d(TAG, "apatch:" + loadPatchName + " added.");
            //复制且加载补丁成功后，删除下载的补丁
            File f = new File(context.getFilesDir(), DIR);
            if (f.exists()) {
                boolean result = new File(loadPatchName).delete();
                if (!result)
                    Log.e(TAG, loadPatchName + " delete fail");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static int getVersionCode(Context context) {
        try {
            PackageInfo pi = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
            return pi.versionCode;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return 0;
        }
    }

    private static String getVersionName(Context context) {
        try {
            PackageInfo pi = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
            return pi.versionName;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

```java
public class FileUtils {
    /**
     * @param fileDir  文件目录
     * @param fileType 后缀名
     * @return 特定目录下的所有后缀名为fileType的文件列表
     */
    public static List<String> getFiles(File fileDir, String fileType) throws Exception {
        List<String> lfile = new ArrayList<String>();
        File[] fs = fileDir.listFiles();
        for (File f : fs) {
            if (f.isFile()) {
                if (fileType
                        .equals(f.getName().substring(
                                f.getName().lastIndexOf(".") + 1,
                                f.getName().length())))
                    lfile.add(f.getName());
            }
        }
        return lfile;
    }

    public static String getLoadPatchName(File fileDir, String fileType, String versionCode) throws Exception {
        List<String> files = getFiles(fileDir, fileType);
        int maxPatchVersion = 0;
        for (String name : files) {
            if (name.startsWith(versionCode + "_")) {
                int patchVersion = Integer.valueOf(name.substring(name.indexOf("_") + 1, name.indexOf(".")));
                maxPatchVersion = Math.max(maxPatchVersion, patchVersion);
            }
        }
        return String.valueOf(maxPatchVersion);
    }
}
```

#### 签名安装

签名打包，将APK命名为old.apk。

![2](/Users/mezzsy/Projects/Blog/Android/assets/238.png)

安装成功后会显示Success，点击运行是这个效果。

![1](/Users/mezzsy/Projects/Blog/Android/assets/239.png)

#### 模拟修改BUG

然后修改Toast，将“BUG”改为“BUG修复”。

```
Toast.makeText(MainActivity.this, "BUG修复", Toast.LENGTH_SHORT).show();
```

这一步模拟修复代码。

再次签名打包，生成命名为new.apk。

#### 生成补丁

在AndFix的GitHub下载tools（apkpatch-1.0.3），解压后在此文件夹放入old.apk、new.apk和签名文件：

![4](/Users/mezzsy/Projects/Blog/Android/assets/240.png)

在此目录下运行apkpatch.bat

![6](/Users/mezzsy/Projects/Blog/Android/assets/241.png)

按照提示输入，如：

![5](/Users/mezzsy/Projects/Blog/Android/assets/242.png)

new.apk是修复后的APK，old.apk是修复前的APK，-o 是输出目前，这里命名为output，-k是签名文件，-p是签名文件的密码，-a和-e分别是用户名和密码。

运行后会在当前目前下生成一个output文件夹，里面放有补丁文件。

![7](/Users/mezzsy/Projects/Blog/Android/assets/243.png)

其中的.apatch是补丁文件，将它放入内部存储的“文件”文件夹里（代码中指定的apatch所在地）。

![8](/Users/mezzsy/Projects/Blog/Android/assets/244.png)

#### 模拟修复

运行。点击修复按钮，然后点击BUG按钮。

![9](/Users/mezzsy/Projects/Blog/Android/assets/245.png)

修复成功

### 测试结果

```
MyApplication的onCreate()：Bug前
Test: Bug前
Activity的onCreate: Bug前
测试一般类的static方法:Bug前
测试一般类的public方法:Bug前
测试一般类的private方法:Bug前
一般的类中的private变量：Bug前
一般的类中的public变量：Bug前
接口方法：Bug前
```

| 测试                         | 结果 |
| ---------------------------- | ---- |
| 1、Application的onCreate方法 |      |
| 2、Activity生命周期的方法    |      |
| 3、一般的类中的静态方法      |      |
| 4、一般的类中的构造方法      |      |
| 5、一般的类中的public方法    |      |
| 6、一般的类中的private方法   |      |
| 7、一般的类中的private变量   |      |
| 8、一般的类中的public变量    |      |
| 9、接口方法                  |      |

### 一些坑

我的手机是Android 8，一开始热修复不了，然后试了虚拟机（6.0），可以了。

之后看到官方文档：

AndFix supports Android version from 2.3 to 7.0, both ARM and X86 architecture, both Dalvik and ART runtime, both 32bit and 64bit.

所以AndFix目前只支持2.3到7.0。