# 并发和并行

并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。

从处理器的角度来看：

并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

# 进程和线程的区别

**进程**：是系统资源分配、保护和调度的基本单位。

**线程**：进程内的一个执行实体。

**关系**：

（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。

（3）处理机分给线程。

**区别**：

**（1）**调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。

**（3）**拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

**（4）**系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

> 进程是系统资源调度的单位，线程是处理机调度的单位，是进程内的一个执行实体。
>
> 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
>
> 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

## 进程和线程在多核的表现

见前面先了解并发和并行。

操作系统调度器：拆分CPU为一段段时间的运行片，轮流分配给不同的程序。

操作系统内存管理模块：管理物理内存、虚拟内存相关的事务。
以前，程序员需要为每个程序安排运行的空间，这里的空间指的是内存的物理地址，但是这么的问题就是，每个程序都要协商如何使用同一内存的不同空间，而且程序员还要关心底层内存分配问题。解决办法就是，提出进程的概念，每个进程用一样的虚拟地址空间，CPU上增加了MMU模块负责转换虚拟地址和物理地址，虚拟地址经过操作系统和MMU之后，虚拟地址会映射到不同的物理地址，不同的进程就能获得各自独立的物理内存空间。

由于CPU同时刻只能执行一个进程，如果不加以控制的话，一个进程可能使用CPU直到运行结束，于是出现了操作系统调度器，而进程也成为了调度单位。

进程的运行不仅需要CPU，还需要其他资源，如内存、显卡，统称为程序的执行环境，也就是程序上下文。在这里就出现了并发的概念，调度器切换CPU给不同进程使用的速度非常快，于是在使用者看来程序是在同时运行，这就是并发，而实际上CPU在同一时刻只在运行一个进程。并发只是给人的假现象 ，原因就是由于cpu工作很快，不断地loop感觉是同时发生，实际都是单个执行的。

CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？此时线程的概念就出现了。线程被包含在进程当中，进程的不同线程间共享CPU和程序上下文。（共享进程分配到的资源）

单CPU进行进程调度的时候，需要读取上下文+执行程序+保存上下文，即进程切换。

如果这个CPU是单核的话，那么在进程中的不同线程为了使用CPU核心，则会进行线程切换，但是由于共享了程序执行环境，**这个线程切换比进程切换开销少了很多**。在这里依然是并发，唯一核心同时刻只能执行一个线程。

出现线程的原因就是由于进程切换需要大量的资源切换，线程却还资源是共享的，切换速度很快，占用资源小，线程内容是隐私的，存储一些上下文信息，以及堆栈信息，占用内存很小，切换很快，同一进程不同线程切换共享进程资源，切换迅速。

如果这个CPU是多核的话，那么进程中的不同线程可以使用不同核心，真正的并行出现了。多核才是并行，单核只能说是并发，假并行

线程是CPU调度和分配的基本单位，进程是操作系统进行资源分配（包括cpu、内存、磁盘IO等）的最小单位。

### 小结

1. 单CPU中进程只能是并发，多CPU计算机中进程可以并行。
2. 单CPU单核中线程只能并发，单CPU多核中线程可以并行。
3. 无论是并发还是并行，使用者来看，看到的是多进程，多线程。

# 虚拟内存与物理内存

## **概念**

物理内存：真实的硬件设备（内存条）

虚拟内存：利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间。（为了满足物理内存的不足而提出的策略）

## **页式存储管理**

页式存储管理在进行内存分配的时候，以物理块为单位进行分配，一个作业有多少页，在装入内存的时候就要给它分配多少个物理块。地址在物理上可以是不连续的（进程的逻辑地址到物理地址的转换需要硬件（地址转换机构）来完成）。

## **虚拟内存思想**

将外存作为内存的扩充，作业运行不需要将作业的全部信息放入内存，将暂时不运行的作业信息放在外存，通过内存与外存之间的对换，使系统逐步将作业信息放人内存，最终达到能够运行整个作业，从逻辑上扩充内存的目的。

**实现：**

内存的分页管理，进程的分页在内存与外存之间对换。

## **分页式虚拟内存管理基本原理**

(1)首先，划分物理内存空间。同时，用户程序也进行分页。

(2)在用户程序开始执行前，不将该程序的所有页都一次性装入内存，而是先放在外存。当程序被调度投入运行时，系统根据需要将页装入内存。

(3)发现所要访问的数据或指令不在内存中，就会产生缺页中断，到外存寻找包含所需数据或指令的页，并将其装入到内存的空闲块中。

(4)在装入页的过程中，若发现内存不足，则需要通过页面置换功能从已在内存的页中挑选一个将其淘汰，释放所占用的物理块后将新的页面装人该块，进程继续运行。

(5)被淘汰的页面如果刚才被修改过，则还需要将其回写到外存，以保留其最新内容。

### **页面置换算法**

- 先进先出置换算法
- 最佳页面置换算法
- 最近最久未使用页面置换算法

# 同步和互斥

## 什么是互斥

若干进程因相互竞争独占性资源而产生的竞争制约关系称为互斥

## 什么是同步

同步是指在若干任务访问共享资源时，采取某种手段来保证共享资源在同一个时刻只被一个任务使用。互斥是同步的一种方法。

# 死锁是怎么导致的？如何定位死锁

某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，直到这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间互相等待的连续循环，没有哪个线程能继续。这被称之为死锁。当以下四个条件同时满足时，就会产生死锁：

1. 互斥条件。任务所使用的资源中至少有一个是不能共享的。

2. 任务必须持有一个资源，同时等待获取另一个被别的任务占有的资源。

3. 资源不能被强占。

4. 必须有循环等待。一个任务正在等待另一个任务所持有的资源，后者又在等待别的任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得大家都被锁住。

要解决死锁问题，必须打破上面四个条件的其中之一。在程序中，最容易打破的往往是第四个条件。