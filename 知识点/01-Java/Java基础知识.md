# 编译和运行过程

```java
//MainApp.java
public class MainApp {  
    public static void main(String[] args) {  
        Animal animal = new Animal("Puppy");  
        animal.printName();  
    }  
}  
//Animal.java 
public class Animal {  
    public String name;  
    public Animal(String name) {  
        this.name = name;  
    }  
    public void printName() {  
        System.out.println("Animal ["+name+"]");  
    }  
}  
```

**编译**

第一步(编译)：创建完源文件之后，程序会先被编译为class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用。如果java编译器在指定目录下找不到该类所依赖的类class文件的话，编译器会报“cant find symbol”的错误。

编译后的字节码文件格式主要分为两部分：**常量池**和**方法字节码**。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。

**运行**

第二步（运行）：java类运行的过程大概可分为两个过程：1、类的加载  2、类的执行。

JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。

下面是程序运行的详细步骤：

1. 在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。
2. 然后JVM找到AppMain的主函数入口，开始执行main函数。
3. main函数的第一条命令是Animal  animal = new Animal("Puppy");就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。
4. 加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存，然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。
5. 当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。
6. 开始运行printName()函数。

# 面向对象

## 五大原则

1. **单一职责原则（Single-Resposibility Principle）**
    其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。
2. **开放封闭原则（Open-Closed principle）**
    其核心思想是：软件实体应该是可扩展的，而不可修改的。
3. **里氏替换原则（Liskov-Substituion Principle）**
    其核心思想是：子类必须能够替换其基类。
4. **依赖倒置原则（Dependecy-Inversion Principle）**
    其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
5. **接口隔离原则（Interface-Segregation Principle）**
    其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。

## 面向对象三大特征

- **封装**：隐藏类的内部实现机制。
- **继承**：重用父类代码，实现多态。
- **多态**：同一方法可以根据对象的不同而采用多种不同的行为方式。

## 对java多态的理解

对于一个方法传入不同的对象类型表现出不同的行为。Java实现的方式是动态绑定和向上转型。

动态绑定：在运行时根据对象的类型进行绑定。。

向上转型：把对某个对象的引用视为对其父类的引用的做法称作向上转型。

**动态绑定（后期绑定、运行时绑定）**：在运行时根据对象的类型进行绑定。

多态的作用：消除类型之间的耦合关系。

实现多态的三个必要条件：继承、重写、向上转型。

向上转型：把对某个对象的引用视为对其父类的引用的做法称作向上转型——在继承树上，父类是放在上方的。

## 对java继承的理解

 一个是对代码的复用。

另一个是对通用版本的特殊化。

## 面向过程和面向对象的区别

**面向过程** 

优点：
性能比面向对象高，因为类调用时需要实例化。 

缺点：
没有面向对象易维护、易复用、易扩展。

**面向对象** 

优点：
易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 

缺点：
性能比面向过程低。

# 编码

## 为什么要编码

- 计算机中存储信息的最小单元是`8bit`，所以能表示的字符范围是`0~255`个。
- 要表示的符号太多，无法用一个字节来完全表示。
- 要解决这个矛盾必须要一个新的数据结构`char`，从`char`到`byte`必须编码。

## 编码方式

- ASCII 码
    `ASCII`码总共有`128`个，用一个字节的低`7`位表示。
- ISO-8859-1
    在`ASCII`码基础上制定了一系列标准来扩展`ASCII`编码，其仍然是单字节编码，总共能表示`256`个字符。
- GB2312
    双字节编码，总的范围是`A1~F7`，从`A1~A9`是符号区，总共包含`682`个符号；从`B0~F7`是汉字区，包含`6763`个汉字。
- GBK
    扩展`GB2312`，加入更多的汉字，其编码范围是`8140~FEFE`，和`GB2312`兼容。
- GB18030
    我国的强制标准，可能是单字节、双字节或者四字节编码，与`GB2312`兼容。
- Unicode编码集
    `ISO`试图创建一个全新的语言字典，将所有的语言互相翻译。`String`在内存中 **不需要编码格式**，它只是一个`Unicode`字符串而已。只有当字符串需要在网络中传输或要被写入文件时，才需要编码格式。
    - UTF-16
        `UTF-16`具体定义了`Unicode`字符在计算机中的存取方法，它用两个字节表示`Unicode`转化格式。
    - UTF-8
        UTF-16的缺点在于很大部分字符仅用一个字节就可以表示，目前却需要使用两个，而UTF-8采用了变长技术，不同类型的字符可以由1~4个字节组成。 
        - 如果一个字节，最高位为`0`，表示这是一个`ASCII`字符。
        - 如果一个字节，以`11`开头，连续的`1`个数表示这个字符的字节数。
        - 如果一个字节，以`10`开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节。

```
String s = "源"; 
//编码。
byte[] b = s.getBytes("UTF-8");
//解码。 
String n = new String(b,"UTF-8"); 
```

Unicode 为世界上所有字符都分配了一个唯一的数字编号，而UTF-8/16/32将编号表示成二进制。UTF-8/16/32 都是 Unicode 的一种实现。

## 对比

- `GB2312`与`GBK`编码规则类似，但是`GBK`范围更大，它能处理所有汉字字符。
- `UTF-16`和`UTF-8`都是处理`Unicode`编码，`UTF-16`效率更高，它适合在本地磁盘和内存之间使用。
- `UTF-16`不是在网络之间传输，因为网络传输容易损坏字节流，`UTF-8`更适合网络传输，对`ASCII`字符采用单字节存储，单字节损毁不会影响后面其它字符。

# 