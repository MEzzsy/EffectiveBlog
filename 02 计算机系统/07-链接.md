Page500
第7章
AP
T
E
链接
链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文
件可被加载（复制）到内存并执行。链接可以执行于编泽时（compiletime），也就是在源代
码被翻译成机器代码时；也可以执行于加载时（loadtime），也就是在程序被加载器（1load-
er）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早
期的计算机系统统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的
程序自动执行的。
链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separatecom-
pilation）成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以
把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模
块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。
链接通常是由链接器来默默地处理的，对于那些在编程人门课堂上构造小程序的学生
而言，链接不是一个重要的议题。那为什么还要这么麻烦地学习关于链接的知识呢?
*理解链接器将帮助你构造大型程序。构造大型程序的程序员经常会遇到由于缺少模
块、缺少库或者不兼容的库版本引起的链接器错误。除非你理解链接器是如何解析
引用、什么是库以及链接器是如何使用库来解析引用的，否则这类错误将令你感到
迷惑和挫败。
●理解链接器将帮助你避免一些危险的编程错误。Linux链接器解析符号引用时所做
的决定可以不动声色地影响你程序的正确性。在默认情况下，错误地定义多个全局
变量的程序将通过链接器，而不产生任何警告信息。由此得到的程序会产生令人迷
惑的运行时行为，而且非常难以调试。我们将向你展示这是如何发生的，以及该如
何避免它。
●理解链接将帮助你理解语言的作用域规则是如何实现的。例如，全局和局部变量之
间的区别是什么?当你定义一个具有static属性的变量或者函数时，实际到底意
味着什么?
●理解链接将帮助你理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系
统功能中扮演着关键角色，比如加载和运行程序、虚拟内存、分页、内存映射。
●理解链接将使你能够利用共享库。多年以来，链接都被认为是相当简单和无趣的。
然而，随着共享库和动态链接在现代操作系统中重要性的日益加强，链接成为一个
复杂的过程，为掌握它的程序员提供了强大的能力。比如，许多软件产品在运行时
使用共享库来升级压缩包装的（shrink-wrapped）二进制程序。还有，大多数Web服
务器都依赖于共享库的动态链接来提供动态内容。
这一章提供了关于链接各方面的全面讨论，从传统静态链接到加载时的共享库的动态链
接，以及到运行时的共享库的动态链接。我们将使用实际示例来描述基本的机制，而且指出
链接问题在哪些情况中会影响程序的性能和正确性。为了使描述具体和便于理解，我们的讨
论是基于这样的环境：一个运行Linux的x86-64系统，使用标准的ELF-64（此后称为ELF）


Page501
第7章链
接
465
目标文件格式。不过，无论是什么样的操作系统、ISA或者目标文件格式，基本的链接概念
是通用的，认识到这一点是很重要的。细节可能不尽相同，但是概念是相同的。
7。1编译器驱动程序
考虑图7-1中的C语言程序。它将作为贯穿本章的一个小的运行示例，帮助我们说明
关于链接是如何工作的一些重要知识点。
code/link/main。c
code/link/sum。c
1
intsum（int*a，intn）；
1
intsum（int*a，intn）
{
inti，s=0；
2
2
3
intarray[2]
{1，2}；
4
4
0；i<n；i++）{
s+=a[i]；
intmain（）
5
for（i
{
7
intval=sum（array，2）；
}
7
8
returnval；
8
returns；
}
code/link/main。c
code/link/sum。c
a）main。c
b）sum。c
图7-1示例程序1。这个示例程序由两个源文件组成，main。c和sum。c。main函数初始化一个整数
数组，然后调用sum函数来对数组元素求和
大多数编译系统提供編译器驱动程序（compilerdriver），它代表用户在需要时调用语
言预处理器、编译器、汇编器和链接器。
比如，要用GNU编译系统构造示例程序，
我们就要通过在shell中输入下列命令来调
用GCC驱动程序：
main。c
sum。c
源文件
翻译器
（срр，сс1，as）
翻译器
（срр，сс1，as）
linux>gcc-0g-oprogmain。csum。c
main。o
可重定位目标文件
sum。o
图7-2概括了驱动程序在将示例程序从
链接器（1d）
ASCII码源文件翻译成可执行目标文件时
的行为。（如果你想看看这些步骤，用-v选
项来运行GCC。）驱动程序首先运行C预处
理器（cpp）e，它将C的源程序main。c翻
译成一个ASCII码的中间文件main。i：
完全链接的
可执行目标文件
prog
图7-2静态链接。链接器将可重定位目标文件组合
起来，形成一个可执行目标文件prog
cpp[otherarguments]main。c/tmp/main。i
接下来，驱动程序运行C编译器（cc1），它将main。i翻译成一个ASCII汇编语言文
件main。s：
cci/tmp/main。i-0g[otherarguments]-o/tmp/main。s
然后，驱动程序运行汇编器（as），它将main。s翻译成一个可重定位目标文件（relo-
catableobjectfile）main。o：
as[otherarguments]-o/tmp/main。o/tmp/main。s
日在某些GCC版本中，预处理器被集成到编译器驱动程序中。


Page502
466
第二部分在系统上运行程序
驱动程序经过相同的过程生成sum。o。最后，它运行链接器程序ld，将main。o和
sum。o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件（executableob-
jectfile）prog：
ld-oprog[systemobjectfilesandargs]/tmp/main。o/tmp/sum。o
要运行可执行文件prog，我们在Linuxshell的命令行上输入它的名字：
linux>。/prog
shell调用操作系统中一个叫做加载器（loader）的函数，它将可执行文件prog中的代
码和数据复制到内存，然后将控制转移到这个程序的开头。
7。2静态链接
像LinuxLD程序这样的静态链接器（staticlinker）以一组可重定位目标文件和命令行
参数作为输人，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入
的可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字
节序列。指令在一一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外ー
节中。
为了构造可执行文件，链接器必须完成两个主要任务：
●符号解析（symbolresolution）。目标文件定义和引用符号，每个符号对应于一个函
数、一个全局变量或一个静态变量（即C语言中任何以static属性声明的变量）。
符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
●重定位（relocation）。编译器和汇编器生成从地址0开始的代码和数据节。链接器通
过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对
这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条
目（relocationentry）的详细指令，不加甄别地执行这样的重定位。
接下来的章节将更加详细地描述这些任务。在你阅读的时候，要记住关于链接器的一
些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程
序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确
定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解
甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。
7。3目标文件
目标文件有三种形式：
●可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位
目标文件合并起来，创建一个可执行目标文件。
*可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
●共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态
地加载进内存并链接。
编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文
件。从技术上来说，一个目标模块（objectmodule）就是一个字节序列，而一个目标文件（ob
jectfile）就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。
目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。


Page503
第7章链
接
467
从贝尔实验室诞生的第一个Unix系统使用的是a。out格式（直到今天，可执行文件仍然
称为a。out文件）。Windows使用可移植可执行（PortableExecutable，PE）格式。Mac
OS-X使用Mach-O格式。现代x86-64Linux和Unix系统使用可执行可链接格式（Execut-
ableandLinkableFormat，ELF）。尽管我们的讨论集中在ELF上，但是不管是哪种格式，
基本的概念是相似的。

7。4
可重定位目标文件
图7-3展示了一个典型的ELF可重定位目标文件的格式。ELF头（ELFheader）以一
个16字节的序列开始，这个序列描述了生成该文件
的系统的字的大小和字节顺序。ELF头剩下的部分
ELF头
。text
包含帮助链接器语法分析和解释目标文件的信息。其
。rodata
中包括ELF头的大小、目标文件的类型（如可重定
位、可执行或者共享的）、机器类型（如x86-64）、节
头部表（sectionheadertable）的文件偏移，以及节头
部表中条目的大小和数量。不同节的位置和大小是由
节头部表描述的，其中目标文件中每个节都有一个固
定大小的条目（entry）。
夹在ELF头和节头部表之间的都是节。一个典
型的ELF可重定位目标文件包含下面几个节：
。text：已编译程序的机器代码。
。rodata：只读数据，比如printf语句中的格图7-3典型的ELF可重定位目标文件
式串和开关语句的跳转表。
。data：已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出
现在。data节中，也不出现在。bss节中。
：bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在
目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化
和未初始化变量是为了空间效率；在目标文件中，未初始化变量不需要占据任何实际的磁
盘空间。运行时，在内存中分配这些变量，初始值为0。
。symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。
程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上，每
个可重定位目标文件在。symtab中都有一张符号表（除非程序员特意用STRIP命令去掉
它）。然而，和编译器中的符号表不同，。symtab符号表不包含局部变量的条目。
。rel。text：一个。text节中位置的列表，当链接器把这个目标文件和其他文件组合
时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修
改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重
定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
。rel。data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初
始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要
data
。bss
。symtab
节，
。rel。text
。rel。data
。debug
。line
。strtab
描述目标
文件的节
节头部表
此
被修改。
。debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定
义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才


Page504
468
第二部分在系统上运行程序
会得到这张表。
。line：原始C源程序中的行号和。text节中机器指令之间的映射。只有以-g选项调
用编译器驱动程序时，才会得到这张表。
。strtab：一个字符串表，其内容包括。symtab和。debug节中的符号表，以及节头
部中的节名字。字符串表就是以null结尾的字符串的序列。
旁注为什么未初始化的数据称为。bss
用术语。bss来表示未初始化的数据是很普遍的。它起始于IBM704汇编语言（大约
在1957年）中“块存储开始（BlockStorageStart）”指令的首字母缩写，并沿用至今。
一种记住。data和。bss节之间区别的简单方法是把“bss”看成是“更好地节省空间
（BetterSaveSpace）"E。
7。5符号和符号表
每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在
链接器的上下文中，有三种不同的符号：
由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C
函数和全局变量。
由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其
他模块中定义的非静态C函数和全局变量。
*只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变
量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。
认识到本地链接器符号和本地程序变量不同是很重要的。。symtab中的符号表不包含
对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类
符号不感兴趣。
有趣的是，定义为带有Cstatic属性的本地过程变量是不在栈中管理的。相反，编
译器在。data或。bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地
链接器符号。比如，假设在同一模块中的两个函数各自定义了一个静态局部变量x：
1
intf（）
{
3
staticintx=0；
4
returnx；
5
6。
7
intg（）
8
{
9。
staticintx=1；
10
returnx；
11
}
在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以
用x。1表示函数f中的定义，而用x。2表示函数g中的定义。
给C语言初学者利用static属性隐藏变量和函数名字
C程序员使用static属性隐藏模块內部的变量和函数声明，就像你在Java和C++


Page505
第7章链
接
469
中使用public和private声明一样。在C中，源文件扮演模块的角色。任何带有
static属性声明的全局变量或者函数都是模块私有的。类似地，任何不带static属
性声明的全局变量和函教都是公共的，可以被其他模块访问。尽可能用static属性来
保护你的变量和函数是很好的编程习惯。
符号表是由汇编器构造的，使用编译器输出到汇编语言。s文件中的符号。。symtab节
中包含ELF符号表。这张符号表包含一个条目的数组。图7-4展示了每个条目的格式。
code/link/elfstructs。c
1
typedefstruct{
int
name；
/*Stringtableoffset*/
char
/*Functionordata（4bits）*/
type：4，
binding：4；/*Localorglobal（4bits）*/
3
4
char
reserved；
/*Unused*/
shortsection；
/*Sectionheaderindex*/
/*Sectionoffsetorabsoluteaddress*/
longvalue；
longsize；
}Elf64_Symbol；
7
/*Objectsizeinbytes*/
code/link/elfstructs。c
图7-4ELF符号表条目。type和binding字段每个都是4位
name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符
号的地址。对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。对于
可执行目标文件来说，该值是一个绝对运行时地址。size是目标的大小（以字节为单位）。
type通常要么是数据，要么是函数。符号表还可以包含各个节的条目，以及对应原始源
文件的路径名的条目。所以这些目标的类型也有所不同。binding字段表示符号是本地的
还是全局的。
每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到
节头部表的索引。有三个特殊的伪节（pseudosection），它们在节头部表中是没有条目的：
ABS代表不该被重定位的符号；UNDEF代表末定义的符号，也就是在本目标模块中引
用，但是却在其他地方定义的符号；COMMON表示还未被分配位置的未初始化的数据目
标。对于COMMON符号，value字段给出对齐要求，而size给出最小的大小。注意，
只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。
COMMON和，bss的区别很细微。现代的GCC版本根据以下规则来将可重定位目标
文件中的符号分配到COMMON和。bss中：
未初始化的全局变量
未初始化的静态变量，以及初始化为0的全局或静态变量
СOMMON
。bss
采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，我们会在
7。6节中加以解释。
GNUREADELF程序是一个查看目标文件内容的很方便的工具。比如，下面是图7-1
中示例程序的可重定位目标文件main。o的符号表中的最后三个条目。开始的8个条目没
有显示出来，它们是链接器内部使用的局部符号。
Num：
Value
SizeType
Bind
Vis
NdxName
8：0000000000000000
24FUNC
GLOBALDEFAULT
1main
9：0000000000000000
8OBJECT
GLOBALDEFAULT
3array
10：0000000000000000
ONOTYPE
GLOBALDEFAULT
UNDsum


Page506
470
第二部分在系统上运行程序
在这个例子中，我们看到全局符号main定义的条目，它是一个位于。text节中偏移量
为0（即value值）处的24字节函数。其后跟随着的是全局符号array的定义，它是一个位
于。data节中偏移量为0处的8字节目标。最后一个条目来自对外部符号sum的引用。
READELF用一个整数索引来标识每个节。Ndx=1表示。text节，而Ndx=3表示。data节。
练习题7。1这个题目针对图7-5中的m。o和swap。o模块。对于每个在swap。o中定
义或引用的符号，请指出它是否在模块swap。o中的。symtab节中有一个符号表条
目。如果是，请指出定义该符号的模块（swap。o或者m。o）、符号类型（局部、全局或
者外部）以及它在模块中被分配到的节（。text、。data、。bss或COMMON）。
符号
。symtab?
符号类型
在哪个模块中定义
节
buf
bufp0
bufpl
swap
temp
code/link/m。c
code/link/swap。c
voidswap（）；
externintbuf[]；
1
1
2
int*bufp0
int*bufp1；
3
intbuf[2]
{1，2}；
=&buf[0]；
4
intmain（）
5
{
voidswap（）
swap（）；
return0；
7
{
8
8
inttemp；
}
9
code/link/m。c
10
bufp1
=&buf[1]；
*bufp0；
*bufp1；
11
temp
*bufpo
*bufp1
}
12
13
temp；
%3D
14
code/link/swap。c
a）m。c
b）swap。c
图7-5练习题7。1的示例程序
7。6符号解析
链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的
一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号
解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变
量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。
不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义
的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符
号表条目，并把它交给链接器处理。如果链接器在它的任何输人模块中都找不到这个被引
用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。比如，如果我们试着在一


Page507
第7章链接
471
台Linux机器上编译和链接下面的源文件：
1
voidfoo（void）；
2
3
intmain（）{
4
foo（）；
5
return0；
6。
那么编译器会没有障碍地运行，但是当链接器无法解析对foo的引用时，就会终止：
linux>gcc-Wall-Og-olinkerrorlinkerror。c
/tmp/ccSz5uti。o：Infunction'main'：
/tmp/ccSz5uti。o（。text+0x7）：undefinedreferenceto'foo'
对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符
号。在这种情况中，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃
其他定义。Linux系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能
给不警觉的程序员带来一些麻烦。
旁注对C++和Java中链接器符号的重整
C++和Java都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数
列表。那么链接器是如何区别这些不同的重載函数之间的差异呢?C++和Java中能使用
重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一
的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。
幸运的是，C++和Java使用兼容的重整策略。一个被重整的类名字是由名字中字符
的整数数量，后面跟原始名字组成的。比如，类Foo被编码成3FOO。方法被编码为原始方
法名，后面加上_，加上被重整的类名，再加上每个参数的单字母编码。比如，Foo：：bar
（int，long）被编码为bar
3Fooil。重整全局变量和模板名字的策略是相似的。
7。6。1链接器如何解析多重定义的全局符号
链接器的输人是一组可重定位目标模块。每个模块定义一组符号，有些是局部的（只
对定义该符号的模块可见），有些是全局的（对其他模块也可见）。如果多个模块定义同名
的全局符号，会发生什么呢?下面是Linux编译系统采用的方法。
在编译时，编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），
而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局
变量是强符号，未初始化的全局变量是弱符号。
根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：
●规则1：不允许有多个同名的强符号。
●规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。
●规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。
比如，假设我们试图编译和链接下面两个C模块：
1
/*foo1。c*/
intmain（）
3
{
4
return0；
5
}


Page508
472
第二部分在系统上运行程序
/*bar1。c*/
intmain（）
1
2
3
{
4
return0；
5
}
在这个情况中，链接器将生成一条错误信息，因为强符号main被定义了多次（规则1）：
linux>gccfoo1。cbarí。c
/tmp/ccq2Uxnd。o：Infunction'main'：
bar1。c：（。text+0x0）：multipledefinitionof'main'
相似地，链接器对于下面的模块也会生成一条错误信息，因为强符号x被定义了两次
（规则1）：
1
/*foo2。c*/
2
intx=15213；
3
4
intmain（）
5
{
6。
return0；
7
}
1
/*bar2。c*/
2
intx=15213；
3
4
voidf（）
5
{
}
然而，如果在一个模块里x未被初始化，那么链接器将安静地选择在另一个模块中定
义的强符号（规则2）：
1
/*foo3。c*/
2
#include<stdio。h>
3
voidf（void）；
4
5
intx=15213；
6。
7
intmain（）
{
9。
f（）；
10
printf（"x=
%d\n"，x）；
11
return0；
12
1
/*bar3。c*/
2
intx；
3
4
voidf（）
5
{
x=15212；
7
在运行时，函数f将x的值由15213改为15212，这会给main函数的作者带来不受
欢迎的意外!注意，链接器通常不会表明它检测到多个x的定义：


Page509
第7章链接
473
linux>gcc-ofoobar3foo3。cbar3。c
linux>。/foobar3
x=15212
如果x有两个弱定义，也会发生相同的事情（规则3）：
1
/*foo4。c*/
#include<stdio。h>
3
voidf（void）；
4
5
intx；
7
intmain（）
8
{
x=15213；
f（）；
9。
10
11
printf（"x
%d\n"，x）；
%3D
12
return0；
13
}
1
/*bar4。c*/
2
intx；
4
voidf（）
5
{
6
x=15212；
7
规则2和规则3的应用会造成一些不易察觉的运行时错误，对于不警觉的程序员来
说，是很难理解的，尤其是如果重复的符号定义还有不同的类型时。考虑下面这个例子，
其中x不幸地在一一个模块中定义为int，而在另一个模块中定义为double：
1
/*foo5。c*/
*2
#include<stdio。h>
3
voidf（void）；
4
inty=15212；
intx=15213；
7
8
intmain（）
{
f（）；
9。
10
printf（"x=0x%xy=0x%x\n"，
х，у）；
11
12
13
return0；
14
}
1
/*bar5。c*/
doublex；
3
voidf（）
5
{
x=-0。0；
}
7


Page510
474
第二部分在系统上运行程序
在一台x86-64/Linux机器上，double类型是8个字节，而int类型是4个字节。在
我们的系统中，x的地址是0x601020，y的地址是0x601024。因此，bar5。c的第6行中
的赋值x=-0。0将用负零的双精度浮点表示覆盖内存中x和y的位置（foo5。c中的第5行
和第6行）!
linux>gcc-Wall-Og-ofoobar5foo5。cbar5。c
/usr/bin/ld：Warning：alignment4ofsymbol'x'in/tmp/cclUFK5g。o
issmallerthan8in/tmp/ccbTLcb9。o
linux>。/foobar5
x=Ox0y=0x80000000
这是一个细微而令人讨厌的错误，尤其是因为它只会触发链接器发出一条警告，而且
通常要在程序执行很久以后才表现出来，且远离错误发生地。在一个拥有成百上千个模块
的大型系统中，这种类型的错误相当难以修正，尤其因为许多程序员根本不知道链接器是
如何工作的。当你怀疑有此类错误时，用像GCC-fno-common标志这样的选项调用链接
器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用
-Werror选项，它会把所有的警告都变为错误。
在7。5节中，我们看到了编译器如何按照一个看似绝对的规则来把符号分配为COM。
MON和。bss。实际上，采用这个惯例是由于在某些情况中链接器允许多个模块定义同名的
全局符号。当编译器在翻译某个模块时，遇到一个弱全局符号，比如说x，它并不知道其他
模块是否也定义了x，如果是，它无法预测链接器该使用x的多重定义中的哪一个。所以编译
器把x分配成COMMON，把决定权留给链接器。另一方面，如果x初始化为0，那么它是一个
强符号（因此根据规则2必须是唯一的），所以编译器可以很自信地将它分配成。bss。类似地，
静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成，。data或。bss。
练习题7。2在此题中，REF（x。i）→DEF（x。k）表示链接器将把模块i中对符号x的任意
引用与模块k中x的定义关联起来。对于下面的每个示例，用这种表示法来说明链接器
将如何解析每个模块中对多重定义符号的引用。如果有一个链接时错误（规则1），写
“错误”。如果链接器从定义中任意选择一个（规则3），则写“未知”。
A。/*Module1*/
/*Module2*/
intmain（）
intmain；
{
intp2（）
}
}
（a）REF（main。1）→DEF（。
（b）REF（main。2）→DEF（。
B。/*Module1*/
voidmain（）
/*Module2*/
intmain=1；
{
intp2（）
}
{
}
（a）REF（main。1）-
→DEF
（b）REF（main。2）→DEF（。
C。/*Module1*/
/*Module2*/
intx；
doub
x=1。0；
voidmain（）
intp2（）
{
{
}
}


Page511
第7章链接
475
（a）REF（x。1）-→DEF（，
（b）REF（x。2）→DEF（
7。6。2与静态库链接
迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形
成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将將所有相关的目标
模块打包成为一个单独的文件，称为静态库（staticlibrary），它可以用做链接器的输人。
当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。
为什么系统要支持库的概念呢?以ISOC99为例，它定义了一组广泛的标准1/O、字
符串操作和整数数学函数，例如atoi、printf、scanf、strcpy和rand。它们在1ibc。
a库中，对每个C程序来说都是可用的。ISOC99还在libm。a库中定义了一组广泛的浮
点数学函数，例如sin、cos和sqrt。
让我们来看看如果不使用静态库，编译器开发人员会使用什么方法来向用户提供这些
函数。一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。Pascal（只
提供了一小部分标准函数）采用的就是这种方法，但是这种方法对C而言是不合适的，因
为C标准定义了大量的标准函数。这种方法将给编译器增加显著的复杂性，而且每次添
加、删除或修改一个标准函数时，就需要一个新的编译器版本。然而，对于应用程序员而
言，这种方法会是非常方便的，因为标准函数将总是可用的。
另一种方法是将所有的标准C函数都放在一个单独的可重定位目标模块中（比如说
libc。o中）应用程序员可以把这个模块链接到他们的可执行文件中：
linux>gccmain。c/usr/lib/libc。o
这种方法的优点是它将编译器的实现与标准函数的实现分离开来，并且仍然对程序员
保持适度的便利。然而，一个很大的缺点是系统中每个可执行文件现在都包含着一份标准
函数集合的完全副本，这对磁盘空间是很大的浪费。（在一个典型的系统上，1ibc。a大约
是5MB，而1ibm。a大约是2MB。）更糟的是，每个正在运行的程序都将它自己的这些函数
的副本放在内存中，这是对内存的极度浪费。另一个大的缺点是，对任何标准函数的任何
改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时
的操作，使得标准函数的开发和维护变得很复杂。
我们可以通过为每个标准函数创建一个独立的可重定位文件，把它们存放在一个为大
家都知道的目录中来解决其中的一些问题。然而，这种方法要求应用程序员显式地链接合
适的目标模块到它们的可执行文件中，这是一个容易出错而且耗时的过程：
linux>gccmain。c/usr/lib/printf。o/usr/lib/scanf。o
。。。
静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的
目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定
单独的文件名字来使用这些在库中定义的函数。比如，使用C标准库和数学库中函数的程
序可以用形式如下的命令行来编译和链接：
linux>gccmain。c/usr/lib/libm。a/usr/lib/libc。a
在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内
存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字（实际上，C编译器驱


Page512
476
第二部分在系统上运行程序
动程序总是传送libc。a给链接器，所以前面提到的对libc。a的引用是不必要的）。
在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存
档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文
件的大小和位置。存档文件名由后缀。a标识。
为了使我们对库的讨论更加形象具体，考虑图7-6中的两个向量例程。每个例程，定
义在它自己的目标模块中，对两个输人向量进行一个向量操作，并把结果存放在一个输出
向量中。每个例程有一个副作用，会记录它自己被调用的次数，每次被调用会把一个全局
变量加1。（当我们在7。12节中解释位置无关代码的思想时会起作用。）
code/link/addvec。c
code/link/multvec。c
1
intaddcnt=
0；
1
intmultcnt=0；
2
2
3
voidaddvec（int*x，int*y，
voidmultvec（int*x，int*y，
int*z，intn）
4
int*z，intn）
5
{
5
{
inti；
inti；
7
addcnt++；
8。
multcnt++；
9。
for（i=0；i<n；i++）
for（i=0；i<n；i++）
z[i]=x[i]*
10
10
z[i]
=x[i]+y[i]；
y[i]；
11
11
12
}
12
code/link/addvec。c
code/link/multvec。c
a）addvec。o
b）multvec。0
图7-6
libvector库中的成员目标文件
要创建这些函数的一个静态库，我们将使用AR工具，如下：
linux>gcc-caddvec。cmultvec。c
linux>arrcslibvector。aaddvec。omultvec。o
为了使用这个库，我们可以编写一个应用，比如图7-7中的main2。c，它调用addvec
库例程。包含（或头）文件vector。h定义了1ibvector。a中例程的函数原型。

-code/link/main2。c
一
#include<stdio。h>
2
#include"vector。h"
4
intx[2]
{1，2}；
inty[2]
intz[2]；
5
{3，4}；
%3D
7
intmain（）
{
addvec（x，y，z，2）；
printf（"z
9。
10
=[%d%d]\n"，z[0]，z[1]）；
11
12
return0；
13
}
code/link/main2。c
图7-7示例程序2。这个程序调用1ibvector库中的函数
为了创建这个可执行文件，我们要编译和链接输入文件main。o和1ibvector。a：


Page513
第7章链接
477
linux>gcc-cmain2。c
linux>gcc-static-oprog2cmain2。0。/libvector。a
或者等价地使用：
linux>gcc-cmain2。c
linux>gcc-static-oprog2cmain2。o-L。-lvector
图7-8概括了链接器的行为。-static参数告诉编译器驱动程序，链接器应该构建一
个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链
接。-lvector参数是1ibvector。a的缩写，-L。参数告诉链接器在当前目录下查找1ib-
vector。a。
源文件
main2。cvector。h
翻译器
（срр，сс1，as）
libvector。a
libc。a
静态库
printf。ofltE
printf。o调用的模块
可重定位目标文件
main2。0
addvec。o
链接器（1d）
prog2c完全链接的
可执行目标文件
图7-8与静态库链接
当链接器运行时，它判定main2。o引用了addvec。o定义的addvec符号，所以复制
addvec。o到可执行文件。因为程序不引用任何由multvec。o定义的符号，所以链接器就
不会复制这个模块到可执行文件。链接器还会复制1ibc。a中的printf。o模块，以及许
多C运行时系统中的其他模块。
7。6。3链接器如何使用静态库来解析引用
虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于Linux链接
器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱
动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令
行中所有的。c文件翻译为。o文件。）在这次扫描中，链接器维护一个可重定位目标文件的
集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了
但是尚未定义的符号）集合U，以及一个在前面输人文件中已定义的符号集合D。初始时，
E、U和D均为空。
*对于命令行上的每个输人文件f，链接器会判断f是一个目标文件还是一个存档文
件。如果了是一个目标文件，那么链接器把了添加到E，修改U和D来反映f中
的符号定义和引用，并继续下一个输入文件。
●如果了是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定
义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就
将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中
所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。此时，任何不
包含在E中的成员目标文件都简单地被丟弃，而链接器将继续处理下一个输人文件。


Page514
478
第二部分在系统上运行程序
●如果当链接器完成对命令行上输人文件的扫描后，U是非空的，那么链接器就会输出一。
个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。
不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文
件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件
之前，那么引用就不能被解析，链接会失败。比如，考虑下面的命令行发生了什么?
linux>gcc-static。/libvector。amain2。c
/tmp/cc9XH6Rp。o：Infunction'main'：
/tmp/cc9XH6Rp。o（。text+0x18）：undefinedreferenceto'addvec'
在处理libvector。a时，U是空的，所以没有libvector。a中的成员目标文件会添
加到E中。因此，对addvec的引用是绝不会被解析的，所以链接器会产生一条错误信息
并终止。
关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也
就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令
行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们排序，使得对于每个被
存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义是在对s的引用之后
的。比如，假设foo。c调用1ibx。a和libz。a中的函数，而这两个库又调用1iby。a中
的函数。那么，在命令行中1ibx。a和1ibz。a必须处在1iby。a之前：
linux>gccfoo。clibx。alibz。aliby。a
如果需要满足依赖需求，可以在命令行上重复库。比如，假设foo。c调用1ibx。a中
的函数，该库又调用1iby。a中的函数，而1iby。a又调用1ibx。a中的函数。那么libx。
a必须在命令行上重复出现：
linux>gccfoo。clibx。aliby。alibx。a
另一种方法是，我们可以将1ibx。a和liby。a合并成一个单独的存档文件。
练习题7。3a和b表示当前目录中的目标模块或者静态库，而a→b表示a依赖于b，也
就是说b定义了一个被a引用的符号。对于下面每种场景，请给出最小的命令行（即一个
含有最少数量的目标文件和库参数的命令），使得静态链接器能解析所有的符号引用。
A。
p。o→libx。a
В。
p。o→libx。a→liby。a
С。
p。o→libx。a→
liby。aHliby。a
→libx。a→p。o
7。7重定位
一且链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义
（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输人
目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤
中，将合并输人模块，并为每个符号分配运行时地址。重定位由两步组成：
●重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的
新的聚合节。例如，来自所有输入模块的。data节被全部合并成一个节，这个节成
为输出的可执行目标文件的。data节。然后，链接器将运行时内存地址赋给新的聚
合节，赋给输入模块定义的每个节，以及赋给输人模块定义的每个符号。当这一步
完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。


Page515
第7章链接
479
*重定位节中的符号引用。在这一一步中，链接器修改代码节和数据节中对每个符号的
引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目
标模块中称为重定位条目（relocationentry）的数据结构，我们接下来将会描述这种
数据结构。

7。7。1
重定位条目
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位
置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何
时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将
目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在。rel。text中。
已初始化数据的重定位条目放在。rel。data中。
图7-9展示了ELF重定位条目的格式。offset是需要被修改的引用的节偏移。
标识被修改引用应该指向的符号。type告知链接器如何修改新的引用。addend是一个有
符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。
symbol
code/link/elfstructs。c
typedefstruct{
longoffset；
longtype：32，
symbol：32；/*Symboltableindex*/
longaddend；
}Elf64_Rela；
1
2
/*Offsetofthereferencetorelocate*/
3
/*Relocationtype*/
/*Constantpartofrelocationexpression*/
code/link/elfstructs。c
图7-9ELF重定位条目。每个条目表示一个必须被重定位的引用，并指明如何计算被修改的引用
ELF定义了32种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的
重定位类型：
R_X86_64_PC32。重定位一个使用32位PC相对地址的引用。回想一下3。6。3节，
一个PC相对地址就是距程序计数器（PC）的当前运行时值的偏移量。当CPU执行
一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运
行时值，得到有效地址（如call1指令的目标），PC值通常是下一条指令在内存中的
地址。
●R_X86_64_32。重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接
使用在指令中编码的32位值作为有效地址，不需要进一步修改。
这两种重定位类型支持x86-64小型代码模型（smallcodemodel），该模型假设可执行目标
文件中的代码和数据的总体大小小于2GB，因此在运行时可以用32位PC相对地址来访问。
GCC默认使用小型代码模型。大于2GB的程序可以用-mcmodel=medium（中型代码模型）
和-mcmodel=large（大型代码模型）标志来编译，不过在此我们不讨论这些模型。
7。7。2重定位符号引用
图7-10展示了链接器的重定位算法的伪代码。第1行和第2行在每个节s以及与每个
节相关联的重定位条目r上迭代执行。为了使描述具体化，假设每个节s是一个字节数
组，每个重定位条目r是一个类型为Elf64_Rela的结构，如图7-9中的定义。另外，还


Page516
480
第二部分在系统上运行程序
假设当算法运行时，链接器已经为每个节（用ADDR（s）表示）和每个符号都选择了运行时地
址（用ADDR（r。Ssymbol）表示）。第3行计算的是需要被重定位的4字节引用的数组s中的
地址。如果这个引用使用的是PC相对寻址，那么它就用第5~9行来重定位。如果该引用
使用的是绝对寻址，它就通过第11~13行来重定位。
foreachsections{
foreachrelocationentryr{
1
2
refptr=s+r。offset；
/*ptrtoreferencetoberelocated*/
4
/*RelocateaPC-relativereference*/
if（r。type
==R_X86_64_PC32）{
6。
ADDR（s）+r。offset；/*ref'srun-timeaddress*/
（unsigned）（ADDR（r。symbol）+r。addend-refaddr）；
7
refaddr=
*refptr
}
%3D
10
11
/*Relocateanabsolutereference*/
12
if（r。type==
R_X86_64_32）
13
*refptr
（unsigned）（ADDR（r。symbol）+r。addend）；
14
}
15
图7-10
重定位算法
让我们来看看链接器如何用这个算法来重定位图7-1示例程序中的引用。图7-11给出
了（用objdump-dxmain。o产生的）GNUOBJDUMP工具产生的main。o的反汇编代码。
code/link/main-relo。d
一
0000000000000000<main>：
2
0：
4883ec08
sub
$0x8，%rsp
be0200000
bf00000000
3
4：
mov
$0x2，%esi
$0x0，%edi
a：R_X86_64_32array
4
9：
mov
%edi=&array
Relocationentry
e800000000
callq13<main+Ox13>
f：R_X86_64_PC32sum-0x4
$0x8，%rsp
e：
sum（）
7
Relocationentry
8
13：
4883c408
add
9。
17：
c3
retq
code/link/main-relo。d
图7-11
main。o的代码和重定位条目。原始C代码在图7-1中
main函数引用了两个全局符号：array和sum。为每个引用，汇编器产生一个重定
位条目，显示在引用的后面一行上。。这些重定位条目告诉链接器对sum的引用要使用32
位PC相对地址进行重定位，而对array的引用要使用32位绝对地址进行重定位。接下
来两节会详细介绍链接器是如何重定位这些引用的。

1。重定位PC相对引用
图7-11的第6行中，函数main调用sum函数，sum函数是在模块sum。o中定义的。
回想一下，重定位条目和指令实际上存放在目标文件的不同节中。为了方便，OBJDUMP工具把它们显示
在一起。


Page517
第7章链接
481
call指令开始于节偏移Oxe的地方，包括1字节的操作码0xe8，后面跟着的是对目标
sum的32位PC相对引用的占位符。
相应的重定位条目r由4个字段组成：
r。offset
Oxf
r。symbol=sum
r。type
=R_X86_64_PC32
r。addend=-4
这些字段告诉链接器修改开始于偏移量0xf处的32位PC相对引用，这样在运行时它
会指向sum例程。现在，假设链接器已经确定
ADDR（s）
ADDR（。text）=0x4004d0
%3D
和
ADDR（r。symbol）
ADDR（sum）=0x4004e8
%3D
使用图7-10中的算法，链接器首先计算出引用的运行时地址（第7行）：
refaddr=
ADDR（s）

+r。offset
=0x4004d0+Oxf
=Ox4004df
然后，更新该引用，使得它在运行时指向sum程序（第8行）：
（unsigned）（ADDR（r。symbol）+r。addend-
（unsigned）（0x4004e8
（unsigned）（0x5）
*refptr
refaddr）
+（-4）
Ox4004df）
%3D
%3D
在得到的可执行目标文件中，call指令有如下的重定位的形式：
4004de：
e805000000
callq4004e8<sum>
sum（）
在运行时，cal11指令将存放在地址Ox4004de处。当CPU执行call指令时，PC的
值为Ox4004e3，即紧随在call指令之后的指令的地址。为了执行这条指令，CPU执行
以下的步骤：
1）将PC压入栈中
2）PC-PC+0x5=0x4004e3+0x5=0x4004e8
因此，要执行的下一条指令就是sum例程的第一条指令，这当然就是我们想要的!

2。重定位绝对引用
重定位绝对引用相当简单。例如，图7-11的第4行中，mov指令将array的地址（一
个32位立即数值）复制到寄存器edi中。mov指令开始于节偏移量Ox9的位置，包括1字
节操作码Oxbf，后面跟着对array的32位绝对引用的占位符。
对应的占位符条目r包括4个字段：
r。offset=Oxa
r。symbol
=array
r。type
=R_X86_64_32
r。addend=0
这些字段告诉链接器要修改从偏移量Oxa开始的绝对引用，这样在运行时它将会指向
array的第一个字节。现在，假设链接器已经确定
ADDR（r。symbol）
ADDR（array）
=Ox601018


Page518
482
第二部分在系统上运行程序
链接器使用图7-10中算法的第13行修改了引用：
（unsigned）（ADDR（r。symbol）+r。addend）
（unsigned）（0x601018
（unsigned）（0x601018）
*refptr
%3D

+0）
%3D
在得到的可执行目标文件中，该引用有下面的重定位形式：
4004d9：
bf18106000
$0x601018，%edi
%edi=&array
mov
综合到一起，图7-12给出了最终可执行目标文件中已重定位的。text节和。data节。在加
载的时候，加载器会把这些节中的字节直接复制到内存，不再进行任何修改地执行这些指令。
1
00000000004004d0<main>：
4004d0：
4883ec08
sub
$0x8，%rsp
2
3
4004d4：
be02000000
$0x2，%esi
mov
$0x601018，%edi
callq4004e8<sum>
$0x8，%rsp
4
4004d9：
bf18106000
mov
%edi=
&array
5
4004de：
e805000000
sum（）
6。
4004e3：
4883c408
add
7
4004e7：
c3
retą
8
00000000004004e8<sum>：
9。
4004e8：
b800000000
mov
$0x0，%eax
10
4004ed：
ba00000000
mov
$0x0，%edx
jmp
movslą%edx，%rcx
11
4004f2：
eb09
4004fd<sum+0x15>
12
4004f4：
4863ca
（%rdi，%rcx，4），%eax
$0x1，%edx
13
4004f7：
03048f
add
14
4004fa：
83c201
add
15
4004fd：
39f2
стр
%esi，%edx
16
4004ff：
7cf3
jl
4004f4<sum+Oxc>
17
400501：
f3c3
repzretą
a）已重定位的。text节
1
0000000000601018<array>：
2
601018：
0100000002000000
b）已重定位的。data节
图7-12可执行文件prog的已重定位的。text节和。data节。原始的C代码在图7-1中
练习题7。4本题是关于图7-12a中的已重定位程序的。
A。第5行中对sum的重定位引用的十六进制地址是多少?
B。第5行中对sum的重定位引用的十六进制值是多少?
练习题7。5考虑目标文件m。o中对swap函数的调用（图7-5）。
9：
e800000000
callq
e<main+0xe>
swap（）
它的重定位条目如下：
r。offset=Oxa
r。symbol
swap
R_X86_64_PC32
r。type
r。addend=-4
%3D
现在假设链接器将m。o中的。text重定位到地址Ox4004d0，将swap重定位到地址


Page519
第7章链接
483
Ox4004e8。那么callg指令中对swap的重定位引用的值是什么?
7。8可执行目标文件
我们已经看到链接器如何将多个目标文件合并成一个可执行目标文件。我们的示例C
程序，开始时是一组ASCII文本文件，现在已经被转化为一个二进制文件，且这个二进制
文件包含加载程序到内存并运行它所需的所有信息。图7-13概括了一个典型的ELF可执
行文件中的各类信息。
将连续的文件
节映射到运行?
时内存段
ELF头
段头部表
。init
只读内存段（代码段）
。text
。rodata
。data
读/写内存段（数据段）
。bss
。symtab
。debug
不加载到内存的符号表
和调试信息
。line
。strtab
描述目标，
文件的节
节头部表
图7-13典型的ELF可执行目标文件
可执行目标文件的格式类似于可重定位目标文件的格式。ELF头描述文件的总体格
式。它还包括程序的入口点（entrypoint），也就是当程序运行时要执行的第一条指令的地
址。。text、。rodata和。data节与可重定位目标文件中的节是相似的，除了这些节已经被
重定位到它们最终的运行时内存地址以外。。init节定义了一个小函数，叫做_init，程序
的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位），所以它不再需要，
rel节。
ELF可执行文件被设计得很容易加载到内存，可执行文件的连续的片（chunk）被映射
到连续的内存段。程序头部表（programheadertable）描述了这种映射关系。图7-14展示
了可执行文件prog的程序头部表，是由OBJDUMP显示的。
code/link/prog-exe。d
Read-onlycodesegment
1LOADoff
Ox0000000000000000vaddr0x0000000000400000paddrOx0000000000400000align2**21
fileszOx000000000000069cmemszOx000000000000069cflagsr-x
Read/writedatasegment
3LOADoff
Ox0000000000000df8vaddrOx0000000000600df8paddrOx0000000000600df8align2**21
4
fileszOx0000000000000228memsz0x0000000000000230flagsrw-
code/link/prog-exe。d
图7-14示例可执行文件prog的程序头部表
off：目标文件中的偏移；vaddr/paddr：内存地址；align：对齐要求；filesz：目标文件中的段大小；
memsz：内存中的段大小；flags：运行时访问权限。
从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。第1行和


Page520
484
第二部分在系统上运行程序
第2行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址Ox400000处，总
共的内存大小是Ox69c字节，并且被初始化为可执行目标文件的头Ox69c个字节，其中包
括ELF头、程序头部表以及。init、。text和。rodata节。
第3行和第4行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址
Ox600df8处，总的内存大小为Ox230字节，并用从目标文件中偏移Oxdf8处开始的
。data节中的0x228个字节初始化。该段中剩下的8个字节对应于运行时将被初始化为0
的。bss数据。
对于任何段s，链接器必须选择一个起始地址vaddr，使得
vaddrmodalign=offmodalign
这里，off是目标文件中段的第一个节的偏移量，align是程序头部中指定的对齐（21=
Ox200000）。例如，图7-14中的数据段中
vaddrmodalign
=0x600df8mod0x200000=0xdf8
以及
offmodalign=Oxdf8mod0x200000=0xdf8
这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内
存中。原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大
小为2的幂的字节片。第9章中你会学习到虚拟内存的知识。
7。9加载可执行目标文件
要运行可执行目标文件prog，我们可以在Linuxshell的命令行中输入它的名字：
linux>。/prog
因为prog不是一个内置的shell命令，所以shell会认为prog是一个可执行目标文
件，通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行它。任何
Linux程序都可以通过调用execve函数来调用加载器，我们将在8。4。6节中详细描述这
个函数。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程
序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。
每个Linux程序都有一个运行时内存映像，类似于图7-15中所示。在Linuxx86-64
系统中，代码段总是从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，
通过调用malloc库往上增长。（我们将在9。9节中详细描述ma1loc和堆。）堆后面的区域
是为共享模块保留的。用户栈总是从最大的合法用户地址（248-1）开始，向较小内存地址
增长。栈上的区域，从地址248开始，是为内核（kernel）中的代码和数据保留的，所谓内核
就是操作系统驻留在内存的部分。
为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用
户地址处。实际上，由于。data段有对齐要求（见7。8节），所以代码段和数据段之间是有
间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间
局随机化（ASLR，参见3。10。4节）。虽然每次程序运行时这些区域的地址都会改变，它们
的相对位置是不变的。
当加载器运行时，它创建类似于图7-15所示的内存映像。在程序头部表的引导下，
加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的


Page521
第7章链接
485
入口点，也就是_start函数的地址。这个函数是在系统目标文件ctrl。o中定义的，对所
有的C程序都是一样的。_start函数调用系统启动函数__libc_start_main，该函数定
义在libc。so中。它初始化执行环境，调用用户层的main函数，处理main函数的返回
值，并且在需要的时候把控制返回给内核。
+对用户代码不可
见的内存
内核内存
248-1
用户栈
（运行时创建）
一rsp（栈指针）
共享库的内存映射区域
brk
运行时堆
（由malloc创建）
读/写段
（。data，。bss）
从可执行文件中加载
只读代码段
（。init，。text，。rodata）
0x400000
图7-15Linuxx86-64运行时内存映像。没有展示出由于段对齐要求和地址空
间布局随机化（ASLR）造成的空隙。区域大小不成比例
旁注加载器实际是如何工作的?
我们对于加载的描述从概念上来说是正确的，但也不是完全准确，这是有意为之。
要理解加载实际是如何工作的，你必须理解进程、虚拟內存和内存映射的概念，这些我
们还没有加以讨论。在后面第8章和第9章中遇到这些概念时，我们将重新回到加载的
问题上，并逐渐向你揭开它的神秘面纱。
对于不够有耐心的读者，下面是关于加载实际是如何工作的一个概述：Linux系统
中的每个程序都运行在一个进程上下文中，有自己的虛拟地址空间。当shell运行一个
程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系
统调用启动加载器。加载器删除子进程现有的虚拟內存段，并创建一组新的代码、数
据、堆和栈段。新的栈和堆段被初始化为零。通过将虛拟地址空间中的页映射到可执行
文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的內容。最后，
加载器跳转到_start地址，它最终会调用应用程序的main函数。除了一些头部信息，在
加载过程中没有任何从磁盘到內存的数据复制。直到CPU引用一个被映射的虛拟页时才
会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。
7。10动态链接共享库
我们在7。6。2节中研究的静态库解决了许多关于如何让大量相关函数对应用程序可用
的问题。然而，静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护
和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的


Page522
486
第二部分在系统上运行程序
更新情况，然后显式地将他们的程序与更新了的库重新链接。
另一个问题是几乎每个C程序都使用标准1/O函数，比如printf和scanf。在运行
时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行上百个进程的典型
系统上，这将是对稀缺的内存系统资源的极大浪费。（内存的一个有趣属性就是不论系统
的内存有多大，它总是一种稀缺资源。磁盘空间和厨房的垃圾桶同样有这种属性。）
共享库（sharedlibrary）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个
目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接
起来。这个过程称为动态链接（dynamiclinking），是由一个叫做动态链接器（dynamiclinker）
的程序来执行的。共享库也称为共享目标（sharedobject），在Linux系统中通常用。so后缀
来表示。微软的操作系统大量地使用了共享库，它们称为DLL（动态链接库）。
共享库是以两种不同的方式来“共
享”的。首先，在任何给定的文件系统
中，对于一个库只有一个。so文件。所
有引用该库的可执行目标文件共享这个，
so文件中的代码和数据，而不是像静态
库的内容那样被复制和嵌人到引用它们
的可执行的文件中。其次，在内存中，
一个共享库的，text节的一个副本可以
被不同的正在运行的进程共享。在第9
章我们学习虚拟似内存时将更加详细地讨
论这个问题。
main2。c
vector。h
翻译器
（срр，сс1，as）
libc。so
libvector。so
可重定位目标文件main2。o
重定位和
符号表信息
链接器（1d）
部分链接的可
执行目标文件
prog21
加载器
（еxеcve）
libc。so
图7-16概括了图7-7中示例程序的
libvector。so
动态链接过程。为了构造图7-6中示例
向量例程的共享库1ibvector。so，我
代码和数据
内存中完全链接
动态链接器（1d-linux。so）
们调用编译器驱动程序，给编译器和链的可执行文件
接器如下特殊指令：
图7-16动态链接共享库
linux>gcc-shared-fpic-olibvector。soaddvec。cmultvec。c
-fpic选项指示编译器生成与位置无关的代码（下一节将详细讨论这个问题）。
-shared选项指示链接器创建一个共享的目标文件。一旦创建了这个库，随后就要将它链
接到图7-7的示例程序中：
linux>gcc-oprog21main2。c。/libvector。so
这样就创建了一个可执行目标文件prog21，而此文件的形式使得它在运行时可以和
libvector。so链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程
序加载时，动态完成链接过程。认识到这一点是很重要的：此时，没有任何1ibvector。so
的代码和数据节真的被复制到可执行文件prog21中。反之，链接器复制了一些重定位和
符号表信息，它们使得运行时可以解析对1ibvector。so中代码和数据的引用。
当加载器加载和运行可执行文件prog21时，它利用7。9节中讨论过的技术，加载部分
链接的可执行文件prog21。接着，它注意到prog21包含一个。interp节，这一节包含动态
链接器的路径名，动态链接器本身就是一个共享目标（如在Linux系统上的1d-linux。so）。
加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。然


Page523
第7章链接
487
后，动态链接器通过执行下面的重定位完成链接任务：
●重定位libc。so的文本和数据到某个内存段。
●重定位libvector。so的文本和数据到另一个内存段。
●重定位prog21中所有对由1ibc。so和1ibvector。so定义的符号的引用。
最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定
了，并且在程序执行的过程中都不会改变。
7。11从应用程序中加载和链接共享库
到目前为止，我们已经讨论了在应用程序被加载后执行前时，动态链接器加载和链接
共享库的情景。然而，应用程序还可能在它运行时要求动态链接器加载和链接某个共享
库，而无需在编译时将那些库链接到应用中。
动态链接是一项强大有用的技术。下面是一些现实世界中的例子：
●分发软件。微软Windows应用的开发者常常利用共享库来分发软件更新。他们生
成一个共享库的新版本，然后用户可以下载，并用它替代当前的版本。下一次他们
运行应用程序时，应用将自动链接和加载新的共享库。
●构建高性能Web服务器。许多Web服务器生成动态内容，比如个性化的Web页
面、账户余额和广告标语。早期的Web服务器通过使用fork和execve创建一个
子进程，并在该子进程的上下文中运行CGI程序来生成动态内容。然而，现代高性
能的Web服务器可以使用基于动态链接的更有效和完善的方法来生成动态内容。
其思路是将每个生成动态内容的函数打包在共享库中。当一个来自Web浏览器的请
求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和
execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只
要一个简单的函数调用的开销就可以处理随后的请求了。这对一个繁忙的网站来说是有很
大影响的。更进一步地说，在运行时无需停止服务器，就可以更新已存在的函数，以及添
加新的函数。
Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接
共享库。
#include<dlfcn。h>
void*dlopen（constchar*filename，intflag）；
返回：若成功则为指向句柄的指针，若出错则为NULL。
dlopen函数加载和链接共享库filename。用已用带RTLD_GLOBAL选项打开了的库
解析filename中的外部符号。如果当前可执行文件是带-rdynamic选项编译的，那么对
符号解析而言，它的全局符号也是可用的。flag参数必须要么包括RTLD_NOW，该标志告
诉链接器立即解析对外部符号的引用，要么包括RTLD_LAZY标志，该标志指示链接器推
迟符号解析直到执行来自库中的代码。这两个值中的任意一个都可以和RTLD_GLOBAL标
志取或。
#include<dlfcn。h>
void*dlsym（void*handle，char*symbol）；
返回：若成功则为指向符号的指针，若出错则为NUILL。


Page524
488
第二部分在系统上运行程序
dlsym函数的输人是一个指向前面已经打开了的共享库的句柄和一个symbol名字，
如果该符号存在，就返回符号的地址，否则返回NULL。
#include<dlfcn。h>
intdlclose（void*handle）；
返回：若成功则为0，若出错则为一1。
如果没有其他共享库还在使用这个共享库，dlclose函数就卸载该共享库。
#include<dlfcn。h>
constchar*dlerror（void）；
返回：如果前面对dlopen、dlsym或dlclose的调用失败，
则为错误消息，如果前面的调用成功，则为NULL。
dlerror函数返回一个字符串，它描述的是调用dlopen、dlsym或者dlclose函数
时发生的最近的错误，如果没有错误发生，就返回NULL。
图7-17展示了如何利用这个接口动态链接我们的libvector。so共享库，然后调用
它的addvec例程。要编译这个程序，我们将以下面的方式调用GCC：
linux>gcc-rdynamic-oprog2rdll。c-ldl
code/link/dll。c
1
#include<stdio。h>
2
#include<stdlib。h>
3
#include<dlfcn。h>
4
{1，2}；
{3，4}；
5
intx[2]
%3!
inty[2]
intz[2]；
7
8
9。
intmain（）
10
{
void*handle；
void（*addvec）（int*，int*，int*，int）；
11
12
13
char*error；
14
/*Dynamicallyloadthesharedlibrarycontainingaddvec（）*/
dlopen（"。/libvector。so"，RTLD_LAZY）；
15
16
handle=
if（!handle）{
fprintf（stderr，"%s\n"，dlerror（））；
exit（1）；
17
18
19
20
}
21
22
/*Getapointertotheaddvec（）functionwejustloaded*/
dlsym（handle，"addvec"）；
dlerror（））!=NULL）{
fprintf（stderr，"%s\n"，error）；
23
addvec=
24
if（（error=
25
图7-17示例程序3。在运行时动态加载和链接共享库1ibvector。so


Page525
第7章链接
489
26
exit（1）；
27
}
28
/*Nowwecancalladdvec（）justlikeanyotherfunction*/
addvec（x，y，z，2）；
29
30
printf（"z
[%d%d]\n"，z[0]，z[1]）；
31
%3D
32
/*Unloadthesharedlibrary*/
if（dlclose（handle）<0）{
fprintf（stderr，"%s\n"，dlerror（））；
exit（1）；
33
34
35
36
37
38
return0；
39
}
code/link/dll。c
图7-17
（续）
旁注共享库和Java本地接口
Java定义了一个标准调用规则，叫做Java本地接口（JavaNativeInterface，JNI），它允
许Java程序调用“本地的”C和C++函数。JNI的基本思想是将本地C函数（如foo）编译
到一个共享库中（如foo。so）。当一个正在运行的了ava程序试图调用函数foo时，Java解
释器利用dlopen接口（或者与其类似的接口）动态链接和加载foo。so，然后再调用foo。
7。12位置无关代码
共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而
节约宝贵的内存资源。那么，多个进程是如何共享程序的一个副本的呢?一种方法是给每
个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共
享库。虽然这种方法很简单，但是它也造成了一些严重的问题。它对地址空间的使用效率
不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。它也难以管理。
我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还
适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我们
还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本
库，就很难避免地址空间分裂成大量小的、未使用而又不再能使用的小洞。更糟的是，对
每个系统而言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。
要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们
加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共
享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读/写数据块。）
可以加载而无需重定位的代码称为位置无关代码（Position-IndependentCode，PIC）。
用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是
使用该选项。
在一个x86-64系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为
PIC。可以用PC相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。然而，对
共享模块定义的外部过程和对全局变量的引用需要一些特殊的技巧，接下来我们会谈到。


Page526
490
第二部分在系统上运行程序

1。PIC数据引用
编译器通过运用以下这个有趣的事实来生成对全局变量的PIC引用：无论我们在内存
中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。
因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段
和数据段的绝对内存位置是无关的。
想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建
了一个表，叫做全局偏移量表（GlobalOffsetTable，GOT）。在GOT中，每个被这个目
标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器还为GOT中
每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使
得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的GOT。
图7-18展示了示例libvector。so共享模块的GOT。addvec例程通过GOT[3]间接
地加载全局变量addcnt的地址，然后把addcnt在内存中加1。这里的关键思想是对
GOT[3]的PC相对引用中的偏移量是一个运行时常量。
数据段
全局偏移量表（GOT）
GOT[0]：
GOT[1]：
GOT[2]：。。
GOT[3]：&adɖcnt
运行时GOT[3]和
addl指令之间的
固定距离是
代码段
0x2008b9
addvec：
mov0x2008b9（%rip），%rax#%rax=*GOT[3]=&addcnt

+add1$0x1，（%rax）

#addcnt++

图7-18用GOT引用全局变量。1ibvector。so中的addvec例程通过libvector。so的
GOT间接引用了addcnt
因为addcnt是由libvector。so模块定义的，编译器可以利用代码段和数据段之间
不变的距离，产生对addcnt的直接PC相对引用，并增加一个重定位，让链接器在构造
这个共享模块时解析它。不过，如果addcnt是由另一个共享模块定义的，那么就需要通
过GOT进行间接访问。在这里，编译器选择采用最通用的解决方案，为所有的引用使
用GOT。

2。PIC函数调用
假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，
因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定
位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它
需要链接器修改调用模块的代码段，GNU编译系统使用了一种很有趣的技术来解决这个问
题，称为延迟绑定（lazybinding），将过程地址的绑定推迟到第一次调用该过程时。
使用延迟绑定的动机是对于一个像libc。so这样的共享库输出的成百上千个函数中，
个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地
方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的
运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。
延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结


Page527
第7章链
接
491
构是：GOT和过程链接表（ProcedureLinkageTable，PLT）。如果一个目标模块调用定义
在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而
PLT是代码段的一部分。
图7-19展示的是PLT和GOT如何协作在运行时解析函数的地址。首先，让我们检
查一下这两个表的内容。
●过程链接表（PLT）。PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一
个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己
的PLT条目。每个条目都负责调用一个具体的函数。PLT[1]（图中未显示）调用系
统启动函数（_
返回值。从PLT[2]开始的条目调用用户代码调用的函数。在我们的例子中，PLT
[2]调用addvec，PLT[3]（图中未显示）调用printf。
●全局偏移量表（GOT）。正如我们看到的，GOT是一个数组，其中每个条目是8字
节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时
会使用的信息。GOT[2]是动态链接器在1d-1inux。so模块中的人口点。其余的每
个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个
相匹配的PLT条目。例如，GoT[4]和PLT[2]对应于addvec。初始时，每个GOT
条目都指向对应PLT条目的第二条指令。
libc_start_main），它初始化执行环境，调用main函数并处理其
数据段
全局偏移量表（GOT）
数据段
全局偏移量表（GOT）
GOT[0]：addrof。dynamic
GOT[1]：addrofrelocentries
GOT[2]：addrofdynamiclinker
GOT[3]：0x4005b6#sysstartup
GOT[4]：0x4005c6#addvec（）
GOT[5]：0x4005d6#printf（）
GOT（0]：addrof。dynamic
GOT[1]：addrofrelocentries
GOT[2]：addrofdynamiclinker
GOT[3]：0x4005b6#sysstartup
GOT[4]：&addvec（）
GOT[5]：0x4005d6#printf（）
代码段
代码段
callqOx4005c0#calladdvec（）
callqOx4005c0#calladdvec（）
过程链接表（PLT）

#PLT[0]：calldynamiclinker

4005a0：pushq*GOT[1]
过程链接表（PLT）

#PLT[0]：calldynamiclinker

4005a0：pushg*GOT[1]
4005a6：jmpq
4005a6：jmpq*GOT[2]-
+の
*GOT[2]
（3

#PLT[2]：calladdvec（）

#PLT[2]：calladdvec（）

4005c0：jmpq*GOT[4]。
4005c0：jmpq*GOT[4]
4005c6：pushq$0x1
4005c6：pushq$0x1
|4005cb：jmpq4005a0
4005cb：jmpq
4005a0
a）第一次调用addvec
b）后续再调用addvec
图7-19
用PLT和GOT调用外部函数。在第一次调用addvec时，动态链接器解析它的地址
图7-19a展示了GOT和PLT如何协同工作，在addvec被第一次调用时，延迟解析
它的运行时地址：
●第1步。不直接调用addvec，程序调用进入PLT[2]，这是addvec的PLT条目。
●第2步。第一条PLT指令通过GOT[4]进行间接跳转。因为每个GOT条目初始时
都指向它对应的PLT条目的第二条指令，这个间接跳转只是简单地把控制传送回
PLT[2]中的下一条指令。


Page528
492
第二部分在系统上运行程序
●第3步。在把addvec的ID（Ox1）压人栈中之后，PLT[2]跳转到PLT[0]。
●第4步。PLT[0]通过GOT[1]间接地把动态链接器的一个参数压人入栈中，然后通过
GOT[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定addvec的运
行时位置，用这个地址重写GOT[4]，再把控制传递给addvec。
图7-19b给出的是后续再调用addvec时的控制流：
●第1步。和前面一样，控制传递到PLT[2]。
●第2步。不过这次通过GOT[4]的间接跳转会将控制直接转移到addvec。
7。13库打桩机制
Linux链接器支持一个很强大的技术，称为库打桩（libraryinterpositioning），它允许
你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某
个特殊库函数的调用次数，验证和追踪它的输人和输出值，或者甚至把它替换成一个完全
不同的实现。
下面是它的基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型
与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是
目标函数了。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返
回值传递给调用者。
打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。要研究这些不同的
机制，我们以图7-20a中的示例程序作为运行例子。它调用C标准库（libc。so）中的mal-
loc和free函数。对malloc的调用从堆中分配一个32字节的块，并返回指向该块的指
针。对free的调用把块还回到堆，供后续的malloc调用使用。我们的目标是用打桩来
追踪程序运行时对malloc和free的调用。

7。13。1
编译时打桩
图7-20展示了如何使用C预处理器在编译时打桩。mymalloc。c中的包装函数（图7-20c）
调用目标函数，打印追踪记录，并返回。本地的malloc。h头文件（图7-20b）指示预处理器用
对相应包装函数的调用替换掉对目标函数的调用。像下面这样编译和链接这个程序：
linux>gcc-DCOMPILETIME-cmymalloc。c
linux>gcc-I。-ointcint。cmymalloc。o
由于有-I。参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，
先在当前目录中查找malloc。h。注意，mymalloc。c中的包装函数是使用标准malloc。h
头文件编译的。
运行这个程序会得到如下的追踪信息：
linux>。/intc
malloc（32）=0x9ee010
free（0x9ee010）
7。13。2链接时打桩
Linux静态链接器支持用--wrapf标志进行链接时打桩。这个标志告诉链接器，把对
符号f的引用解析成__wrap_f（前缀是两个下划线），还要把对符号__real_f（前缀是两
个下划线）的引用解析为f。图7-21给出我们示例程序的包装函数。


Page529
第7章链接
493
code/link/interpose/int。c
1
#include<stdio。h>
2
#include<malloc。h>
3
4
intmain（）
5
{
int*p=malloc（32）；
free（p）；
return（0）；
6。
7
8。
9。
}
code/link/interpose/int。c
a）示例程序int。c
code/link/interpose/malloc。h
#definemalloc（size）mymalloc（size）
#definefree（ptr）myfree（ptr）
1
3
4
void*mymalloc（size_tsize）；
voidmyfree（void*ptr）；
code/link/interpose/malloc。h
b）本地malloc。h文件
code/link/interpose/mymalloc。c
1
#ifdefCOMPILETIME
2
#include<stdio。h>
3
#include<malloc。h>
4
/*mallocwrapperfunction*/
void*mymalloc（size_tsize）
{
7
void*ptr=malloc（size）；
printf（"malloc（%d）=%p\n"，
（int）size，ptr）；
8
9
10
11。
returnptr；
12
}
13
/*freewrapperfunction*/
voidmyfree（void*ptr）
{
14
15
16
free（ptr）；
printf（"free（%p）\n"，ptr）；
}
17
18
19
20
#endif
code/link/interpose/mymalloc。c
c）mymalloc。c中的包装函数
图7-20用C预处理器进行编译时打桩
用下述方法把这些源文件编译成可重定位目标文件：
linux>gcc-DLINKTIME-cmymalloc。c
linux>gcc-cint。c
然后把目标文件链接成可执行文件：
linux>gcc-Wl，--wrap，malloc-Wl，--wrap，free-ointlint。omymalloc。o
-W1，option标志把option传递给链接器。option中的每个逗号都要替换为一个空


Page530
494
第二部分在系统上运行程序
格。所以-w1，--wrap，malloc就把--wrapmalloc传递给链接器，以类似的方式传递
-Wl，--wrap，free。
code/link/interpose/mymalloc。c
1
#ifdefLINKTIME
2
#include<stdio。h>
3
4
void*__real_malloc（size_tsize）；
void_real_free（void*ptr）；
/*mallocwrapperfunction*/
void*__wrap_malloc（size_tsize）
{
7
8
-_real_malloc（size）；/*Calllibcmalloc*/
%p\n"，（int）size，ptr）；
10
void*ptr=
printf（"malloc（%d）
returnptr；
11
12
13
}
14
/*freewrapperfunction*/
--wrap_free（void*ptr）
{
15
16
void
17
-_real_free（ptr）；/*Calllibcfree*/
printf（"free（%p）\n"，ptr）；
}
18
19
20
21
#endif
code/link/interpose/mymalloc。c
图7-21
用--wrap标志进行链接时打桩
运行该程序会得到如下追踪信息：
linux>。/intl
malloc（32）
=Ox18cf010
free（0x18cf010）
7。13。3运行时打桩
编译时打桩需要能够访问程序的源代码，链接时打柱需要能够访问程序的可重定位对
象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个
很厉害的机制基于动态链接器的LD_PRELOAD环境变量。
如果LD_PRELOAD环境变量被设置为一个共享库路径名的列表（以空格或分号分隔），
那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器（LD-LINUX。SO）会
先搜索LD_PRELOAD库，然后才搜索任何其他的库。有了这个机制，当你加载和执行任意
可执行文件时，可以对任何共享库中的任何函数打桩，包括1ibc。so。
图7-22展示了malloc和free的包装函数。每个包装函数中，对dlsym的调用返回，
指向目标libc函数的指针。然后包装函数调用目标函数，打印追踪记录，再返回。
下面是如何构建包含这些包装函数的共享库的方法：
linux>gcc-DRUNTIME-shared-fpic-omymalloc。somymalloc。c-ldl
这是如何编译主程序：
linux>gcc-ointrint。c


Page531
第7章链接
495
code/link/interpose/mymalloc。c
1
#ifdefRUNTIME
2
#define_GNU_SOURCE
3
#include<stdio。h>
#include<stdlib。h>
#include<dlfcn。h>
6。
/*mallocwrapperfunction*/
void*malloc（size_tsize）
7
8。
9
{
void*（*mallocp）（size_tsize）；
char*error；
10
11
12
dlsym（RTLD_NEXT，"malloc"）；/*Getaddressoflibcmalloc*/
=dlerror（））!=NULL）{
mallocp
if（（error
fputs（error，stderr）；
exit（1）；
13
%3D
14
15
16
17
mallocp（size）；/*Calllibcmalloc*/
%p\n"，（int）size，ptr）；
18
char*ptr
%3D
printf（"malloc（%d）
returnptr；
19
20
21
22
/*freewrapperfunction*/
voidfree（void*ptr）
23
24
25
{
void（*freep）（void*）
char*error；
26
NULL；
%3D
27
28
if（!ptr）
29
30
return；
31
dlsym（RTLD_NEXT，"free"）；/*Getaddressoflibcfree*/
dlerror（））!=NULL）{
freep
if（（error
fputs（error，stderr）；
exit（1）；
32
%3D
33
%3D
34
35
36
}
freep（ptr）；/*Calllibcfree*/
printf（"free（%p）\n"，ptr）；
}
37
38
39
40
#endif
code/link/interpose/mymalloc。c
图7-22用LDPRELOAD进行运行时打桩
下面是如何从bashshell中运行这个程序。：
linux>LD_PRELOAD="。/mymalloc。so"。/intr
malloc（32）=Ox1bf7010
free（Ox1bf7010）
如果你不知道运行的shell是哪一种，在命令行上输入printenvSHELL。


Page532
496
第二部分在系统上运行程序
下面是如何在csh或tcsh中运行这个程序：
linux>（setenvLD_PRELOAD"。/mymalloc。so"；。/intr；unsetenvLD_PRELOAD）
malloc（32）=Ox2157010
free（0x2157010）
请注意，你可以用LD_PRELOAD对任何可执行程序的库函数调用打桩!
linux>LD_PRELOAD="。/mymalloc。so"/usr/bin/uptime
malloc（568）
=Ox21bb010
free（0x21bb010）
malloc（15）=0x21bb010
malloc（568）=0x21bb030
malloc（2255）=0x21bb270
free（Ox21bb030）
malloc（20）=Ox21bb030
malloc（20）
=0x21bb050
malloc（20）=0x21bb070
malloc（20）=Ox21bb090
malloc（20）=Ox21bb0b0
malloc（384）=0x21bb0d0
20：47：36up85days，
6：04，
1user，
loadaverage：0。10，0。04，0。05
7。14处理目标文件的工具
在Linux系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU
binutils包尤其有帮助，而且可以运行在每个Linux平台上。
●AR：创建静态库，插人、删除、列出和提取成员。
●STRINGS：列出一个目标文件中所有可打印的字符串。

*STRIP：从目标文件中删除符号表信息。
●NM：列出一个目标文件的符号表中定义的符号。
●SIZE：列出目标文件中节的名字和大小。
●READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含
SIZE和NM的功能。
●OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大
的作用是反汇编。text节中的二进制指令。
Linux系统为操作共享库还提供了LDD程序：
●LDD：列出一个可执行文件在运行时所需要的共享库。
7。15小结
链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处
理称为目标文件的二进制文件，它有3种不同的形式：可重定位的、可执行的和共享的。可重定位的目
标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。共享目标文件（共享
库）是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要
在程序调用dlopen库的函数时。
链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个
唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。


Page533
第7章链接
497
静态链接器是由像GCC这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独
的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则
可能在用户程序中引人微妙的错误。
多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引
用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误
的来源。
加载器将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目
标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链
接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链
接任务。
被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、
链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。
参考文献说明
在计算机系统文献中并没有很好地记录链接。因为链接是处在编译器、计算机体系结构和操作系统
的交叉点上，它要求理解代码生成、机器语言编程、程序实例化和虚拟内存。它没有恰好落在某个通常
的计算机系统领域中，因此这些领域的经典文献并没有很好地描述它。然而，Levine的专著提供了有关
这个主题的很好的一般性参考资料[69]。[54]描述了ELF和DWARF（对。debug和。1ine节内容的规范）
的原始IA32规范。[36]描述了对ELF文件格式的x86-64扩展。x86-64应用二进制接口（ABI）描述了编
译、链接和运行x86-64程序的惯例，其中包括重定位和位置无关代码的规则[77]。
家庭作业
*7。6这道题是关于图7-5的m。o模块和下面的swap。c函数版本的，该函数计算自己被调用的次数：
1
externintbuf[]；
2
=&buf[0]；
int*bufp0
staticint*bufp1；
4
5
staticvoidincr（）
7
{
8
staticintcount=0；
9
count++；
}
10
11
12
13
voidswap（）
14
{
15
inttemp；
16
17
incr（）；
bufp1=&buf[1]；
temp=*bufpo；
*bufp0
*bufp1=temp；
18
19
20
*bufp1；
%3D
21
22
对于每个sSwap。o中定义和引用的符号，请指出它是否在模块swap。o的。symtab节中有符号表
条目。如果是这样，请指出定义该符号的模块（swap。o或m。o）、符号类型（局部、全局或外部）以及
它在模块中所处的节（。text、。data或。bss）。


Page534
498
第二部分在系统上运行程序
符号
swap。o。symtab?
符号类型
定义符号的模块
节
buf
bufp0
bufpl
swap
temp
incr
count

*7。7不改变任何变量名字，修改7。6。1节中的bar5。c，使得foo5。c输出x和y的正确值（也就是整数
15213和15212的十六进制表示）。
在此题中，REF（x，i）→DEF（x，k）表示链接器将任意对模块i中符号x的引用与模块k中符号x的
定义相关联。在下面每个例子中，用这种符号来说明链接器是如何解析在每个模块中有多重定义的
引用的。如果出现链接时错误（规则1），写“错误”。如果链接器从定义中任意选择一个（规则3），
那么写“未知”。
*7。8
A。/*Module1*/
/*Module2*/
intmain（）
staticintmain=1[
{
intp2（）
}
{
}
（a）REF（main。1）→DEF（。
（b）REF（main。2）→DEF（_
B。/*Module1*/
/*Module2*/
intx；
doublex；
voidmain（）
intp2（）
{
{
}
（a）REF（x。1）
→DEF（
（b）REF（x。2）→DEF（
C。/*Module1*/
/*Module2*/
intx=1；
doublex=1。0；
voidmain（）
intp2（）
{
{
}
（a）REF（x。1）→DEF（。
（b）REF（x。2）→DEF（_

+7。9
考虑下面的程序，它由两个目标模块组成：
一
/*foo6。c*/
一
/*bar6。c*/
voidp2（void）；
2
#include<stdio。h>
3
3
4
intmain（）
4
charmain；
5
{
5
voidp2（）
p2（）；
return0；
6
6
7
7
{
8
8
printf（"Ox%x\n"，main）；
当在x86-64Linux系统中编译和执行这个程序时，即使函数p2不初始化变量main，它也能打印字
符串“Ox48ln”并正常终止。你能解释这一点吗?
**7。10a和b表示当前路径中的目标模块或静态库，而a→b表示a依赖于b，也就是说a引用了一个b
定义的符号。对于下面的每个场景，给出使得静态链接器能够解析所有符号引用的最小的命令行
（即含有最少数量的目标文件和库参数的命令）。


Page535
第7章链
接
499
A。p。olibx。ap。o
B。p。o-libx。aliby。aFlliby。a-libx。a
C。p。o+libx。aliby。alibz。aHliby。alibx。a→libz。a
图7-14中的程序头部表明数据段占用了内存中Ox230个字节。然而，其中只有开始的Ox228字节
来自可执行文件的节。是什么引引起了这种差异?
**7。11
**7。12考虑目标文件m。o中对函数swap的调用（作业题7。6）。
9：
e800000000
callq
e<main+0xe>
swap（）
具有如下重定位条目：
r。offset=Oxa
r。symbol=swap
r。type
=R_X86_64_PC32
r。addend=-4
A。假设链接器将m。o中的。text重定位到地址0x4004e0，把swap重定位到地址0x4004f8。那么
callg指令中对swap的重定位引用的值应该是什么?
B。假设链接器将m。o中的。text重定位到地址0x4004d0，把swap重定位到地址0x400500。那么
callg指令中对swap的重定位引用的值应该是什么?
**7。13完成下面的任务将帮助你更熟悉处理目标文件的各种工具。
A。在你的系统上，lib。c和1ibm。a的版本中包含多少目标文件?
B。gcc-0g产生的可执行代码与gcc-0g-g产生的不同吗?
C。在你的系统上，GCC驱动程序使用的是什么共享库?
练习题答案

7。1
这道练习题的目的是帮助你理解链接器符号和C变量及函数之间的关系。注意C的局部变量temp
没有符号表条目。
-symtab条目?
是
符号
符号类型
在哪个模块中定义
节
外部
全局
全局
全局
buf
main。o
。data
是
是
是
bufp0
swap。o
data
bufpl
swap。o
COMMON
swap
swap。o
text
temp
否
7。2这是一个简单的练习，检查你对Unix链接器解析在一个以上模块中有定义的全局符号时所使用规
则的理解。理解这些规则可以帮助你避免一些
A。链接器选择定义在模块1中的强符号，而不是定义在模块2中的弱符号（规则2）：
（a）REF（main。1）→DEF（main。1）
E的编程错误。
（b）REF（main。2）→DEF（main。1）
B。这是一个错误，因为每个模块都定义了一个强符号main（规则1）。
C。链接器选择定义在模块2中的强符号，而不是定义在模块1中的弱符号（规则2）：
（a）REF（x。1）→DEF（x。2）
（b）REF（x。2）一→DEF（x。2）
7。3在命令行中以错误的顺序放置静态库是造成令许多程序员迷惑的链接器错误的常见原因。然而，
旦你理解了链接器是如何使用静态库来解析引用的，它就相当简单易懂了。这个小练习检查了你对
这个概念的理解：
A。linux>
gccp。olibx。a
B。linux>gccp。olibx。aliby。a
C。linux>
gccp。olibx。aliby。alibx。a
7。4这道题涉及的是图7-12a中的反汇编列表。目的是让你练习阅读反汇编列表，并检查你对PC相对