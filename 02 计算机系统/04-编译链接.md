# 编译链接

在Linux下，当我们使用GCC来编译HelloWorld程序时，只须使用最简单的命令：
```
$gcc hello.c
$./a.out
HelloWorld
```

事实上，上述过程可以分解为4个步骤：

1. 预处理（Prepressing）
2. 编译（Compilation）
3. 汇编（Assembly）
4. 链接（Linking）

## 预编译

首先是源代码文件`hello.c`和相关的头文件，如`stdio.h`等被预编译器cpp预编译成一个`.i`文件。

预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如`#include`、`#define`等，主要处理规则如下：

- 将所有的`#define`删除，并且展开所有的宏定义。
- 处理所有条件预编译指令，比如`#if`、`#ifdef`、`#elif`、`#else`、`#endif。
- 处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
- 删除所有的注释`//`和`/**/`。
- 添加行号和文件名标识，比如`#2 “hello.c” 2`，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
- 保留所有的`#pragma`编译器指令，因为编译器须要使用它们。

经过预编译后的`.i`文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到`.i`文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。

## 编译

编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件。

## 汇编

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。

## 链接

重要，见下。

# 静态链接

一个复杂的软件也如此，人们把每个源代码模块独立地编译，然后按照须要将它们“组装”起来，这个组装模块的过程就是链接（Linking）。

链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。

> 符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的，大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。

在程序模块`main.c`中使用另外一个模块`func.c`中的函数foo。我们在`main.c`模块中每一处调用foo的时候都必须确切知道foo这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译`main.c`的时候它并不知道foo函数的地址，所以它暂时把这些调用foo的指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。

由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址置为0，等待链接器在将目标文件A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000。这个地址修正的过程也被叫做重定位（Relocation），每个要被修正的地方叫一个重定位入口（Relocation Entry）。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。