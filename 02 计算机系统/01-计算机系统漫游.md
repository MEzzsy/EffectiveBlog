# 系统的硬件组成

1.  总线
    贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。
2.  I/O设备
3.  主存
    主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。
    数据一般需要经过处理器才能到达主存。利用直接存储器存取技术，数据可以不通过处理器而直接从磁盘到达主存。
4.  处理器
    中央处理单元(CPU)，简称处理器，是解释(或执行)存储在主存中指令的引擎。

## 64/32位

64位CPU是指CPU内部的通用寄存器的宽度为64比特，支持整数的64比特宽度的算术与逻辑运算。

存储器的大小是依据可寻址的存储器组件大小而变，例如 16位地址总线其寻址能力有 2的 16次方 = 65,536 = 64 KB 的存储器空间，而 32位地址总线其寻址能力有 2的 32次方 = 4,294,967,296 = 4 GB的存储器空间。

>   CPU的64位是指一次处理数据，数据的最大长度。
>
>   地址总线的32位是指寻址能力，最大能寻2的32次-1的地址，也就是4GB；64位就是2的64次-1。



第1章 计算机系统漫游
3
。C语言小而简单。C语言的设计是由一个人而非一个协会掌控的，因此这是一个
简洁明了、没有什么冗赘的设计。 K&R这本书用大量的例子和练习描述了完整
的C语言及其标准库，而全书不过 261 页。C语言的简单使它相对而言易于学
习，也易于移植到不同的计算机上。
。C语言是为实践目的设计的。C语言是设计用来实现 Unix 操作系统的。后来，
其他人发现能够用这门语言无障碍地编写他们想要的程序。
C语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也
并非适用于所有的程序员和所有的情况。C语言的指针是造成程序员困惑和程序错误的
一个常见原因。同时，C语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异
常。像 C++ 和Java 这样针对应用级程序的新程序语言解决了这些问题。
1。2 程序被其他程序翻译成不同的格式
hello 程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读
懂。然而，为了在系统上运行 he1lo。c 程序，每条C语句都必须被其他程序转化为一系
列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以
二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。
在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：
linux> gcc -o hello hello。c
在这里，GCC 编译器驱动程序读取源程序文件hello。c，并把它翻译成一个可执行
目标文件 hello。这个翻译过程可分为四个阶段完成，如图 1-3 所示。执行这四个阶段的
程序(预处理器、编译器、汇编器和链接器)一起构成了编译系统(compilation system)。
printf。o
预处理器
( cpp )
hello。c
hello。i
hello。s
汇编器
hello。o
hello
编译器
( ccl )
链接器
( ld)
( as )
源程序
(文本)
修改了的
源程序
(文本)
汇编程序
(文本)
可重定位
目标程序
(二进制)
可执行
目标程序
(二进制)
图1-3 编译系统
●预处理阶段。预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如
hello。c 中第1行的#include <stdio。h> 命令告诉预处理器读取系统头文件
stdio。h 的内容，并把它直接插人程序文本中。结果就得到了另一个C程序，通常
是以。i作为文件扩展名。
●编译阶段。编译器(ccl)将文本文件 hello。i翻译成文本文件 hello。s，它包含一
个汇编语言程序。该程序包含函数 main 的定义，如下所示：
1
main：
$8， %rsp
$。 LCO， %edi
2
subq
3
movl
call
puts
$0， %eax
$8， %rsp
4
5
movl
addq
7
ret
定义中2~7行的每条语句都以一种文本格式描述了一条低级机器语言指令。
汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语


Page 40
4
第1章 计算机系统漫游
言。例如，C编译器和Fortran 编译器产生的输出文件用的都是一样的汇编语言。
●汇编阶段。接下来，汇编器(as)将 hello。s翻译成机器语言指令，把这些指令打包成
一种叫做可重定位目标程序(relocatable object program)的格式，并将结果保存在目标
文件 hello。o中。hello。o文件是一个二进制文件，它包含的 17 个字节是函数 main
的指令编码。如果我们在文本编辑器中打开 hello。o文件，将看到一堆乱码。
●链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C编译器都提供的
标准C库中的一个函数。printf 函数存在于一个名为 printf。。的单独的预编译
好了的目标文件中，而这个文件必须以某种方式合并到我们的hello。o 程序中。链
接器(Id)就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件
(或者简称为可执行文件)，可以被加载到内存中，由系统执行。
旁注 GNU 项目
GCC 是GNU(GNU 是GNU's Not Unix 的缩写)项目开发出来的众多有用工具之
一。GNU 项目是1984年由Richard Stallman 发起的一个免稅的慈善项目。该项目的目
标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改
和传播。GNU项目己经开发出了一个包含Unix 操作系统的所有主要部件的环境，但内
核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC
编译器、GDB 调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。
GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持
的语言包括C、C++、Fortran、Java、Pascal、面向对象 C语言(Objective-C)和Ada。
GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动(通常和
Linux 联系在一起)的思想起源是 GNU 项目中自由软件(free software)的概念。(此处的free
为自由言论(free speech)中的“自由”之意，而非免费啤酒(free beer)中的“免费”之意。)而
且，Linux 如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。
1。3 了解编译系统如何工作是大有益处的
对于像 hello。c这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。
但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。
●优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序
员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在C程序中
做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的C语句转化
为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else 语句高效
得多?一个函数调用的开销有多大? while 循环比 for 循环更有效吗?指针引用比数
组索引更有效吗?为什么将循环求和的结果放到一个本地变量中，会比将其放到一个
通过引用传递过来的参数中，运行起来快很多呢?为什么我们只是简单地重新排列一
下算术表达式中的括号就能让函数运行得更快?
在第3章中，我们将介绍 x86-64，最近几代 Linux、Macintosh 和 Windows 计算机的
机器语言。我们会讲述编译器是怎样把不同的C语言结构翻译成这种机器语言的。在第
5章中，你将学习如何通过简单转换 C语言代码，帮助编译器更好地完成工作，从而调
整C程序的性能。在第6章中，你将学习存储器系统的层次结构特性，C语言编译器如
何将数组存放在内存中，以及C程序又是如何能够利用这些知识从而更高效地运行。


Page 41
第1章 计算机系统漫游
●理解链接时出现的错误。根据我们的经验，一些最令人困扰的程序错误往往都与链
接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无
法解析一个引用，这是什么意思? 静态变量和全局变量的区别是什么?如果你在不
同的C文件中定义了名字相同的两个全局变量会发生什么?静态库和动态库的区别
是什么?我们在命令行上排列库的顺序有什么影响?最严重的是，为什么有些链接
错误直到运行时才会出现?在第7章中，你将得到这些问题的答案。
●避免安全漏洞。多年来，缓冲区溢出错误是造成大多数网络和Internet 服务器上安
全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信
任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存
储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第3章
中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以
用来降低攻击威胁的方法。
1。4 处理器读并解释储存在内存中的指令
此刻，hello。c源程序已经被编译系统翻译译成了可执行目标文件 hello，并被存放在
磁盘上。要想在 Unix 系统上运行该可执行文件，我们将它的文件名输入到称为shell的应
用程序中：
linux> 。/hello
hello， world
linux>
shell 是一个命令行解释器，它输出一个提示符，等待输人一个命令行，然后执行这
个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell 就会假设这是
一个可执行文件的名字，它将加载并运行这个文件。所以在此例中， shell 将加载并运行
hello 程序，然后等待程序终止。 hello 程序在屏幕上输出它的消息，然后终止。 shell
随后输出一个提示符，等待下一个输入的命令行。
1. 4. 1
系统的硬件组成
为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如
图1-4 所示。这张图是近期 Intel 系统产品族的模型，但是所有其他系统也有相同的外观
和特性。现在不要担心这张图很复杂一一我们将在本书分阶段对其进行详尽的介绍。
1. 总线
贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传
递。通常总线被设计成传送定长的字节块，也就是字(word)。字中的字节数(即字长)是一
个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节(32
位)，要么是8个字节(64 位)。本书中，我们不对字长做任何固定的假设。相反，我们将
“在需要明确定义的上下文中具体说明一个“字”是多大。
2. 1/0 设备
1/O(输入/输出)设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O 设
备：作为用户输人的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序
的磁盘驱动器(简单地说就是磁盘)。最开始，可执行程序 hello 就存放在磁盘上。
每个 I/O设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区


Page 42
第1章 计算机系统漫游
别主要在于它们的封装方式。控制器是1/O 设备本身或者系统的主印制电路板(通常称作
主板)上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是
在I/0总线和I/0 设备之间传递信息。
CPU
寄存器文件
PC
ALU
系统总线
内存总线
总线接口
I/O
桥
主存储器
00
I/O 总线
扩展槽，留待
网络适配器一
类的设备使用
USB
图形适配器
磁盘控制器
控制器
鼠标
键盘
显示器
存储在磁盘上的hello
磁盘|可执行文件
一个典型系统的硬件组成
CPU：中央处理单元；ALU；算术/逻辑单元；PC：程序计数器； USB：通用串行总线
图1-4
第6章会更多地说明磁盘之类的I/0 设备是如何工作的。在第10 章中，你将学习如
何在应用程序中利用 Unix I/O 接口访问设备。我们将特别关注网络类设备，不过这些技
术对于其他设备来说也是通用的。
3。主存
主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从
物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储
器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始
的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的
数据项的大小是根据类型变化的。比如，在运行Linux 的 x86-64 机器上，short类型
需要2个字节，int 和 float 类型需要4个字节，而 long 和 double 类型需要8个字节。
第6章将具体介绍存储器技术，比如 DRAM 芯片是如何工作的，它们又是如何组合
起来构成主存的。
女据
4。处理器
中央处理单元(CPU)，简称处理器，是解释(或执行)存储在主存中指令的引擎。处理
器的核心是一个大小为一个字的存储设备(或寄存器)，称为程序计数器(PC)。在任何时
刻，PC都指向主存中的某条机器语言指令(即含有该条指令的地址)。
从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，
再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行
模型来操作的，这个模型是由指令集架构决定的。在这个模型中，指令按照严格的顺序执
行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指
PC也普遍地被用来作为“个人计算机”的缩写。然而，两者之间的区别应该可以很清楚地从上下文中看出来。


Page 43
第1章 计算机系统漫游
7
令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，
而这条指令并不一定和在内存中刚刚执行的指令相邻。
这样的简单操作并不多，它们围绕着主存、寄存器文件(register file)和算术/逻輯单
元(ALU)进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个
寄存器都有唯一的名字。ALU 计算新的数据和地址值。下面是一些简单操作的例子，
CPU 在指令的要求下可能会执行这些操作。
加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
●存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原
来的内容。
操作：把两个寄存器的内容复制到 ALU， ALU 对这两个字做算术运算，并将结果
存放到一个寄存器中，以覆盖该寄存器中原来的内容。
●跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖
PC 中原来的值。
处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂
的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分
开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际
上是如何实现的。在第3章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽
象性。第4章将更详细地介绍处理器实际上是如何实现的。第5章用一个模型说明现代处
理器是如何工作的，从而能预测和优化机器语言程序的性能。
1。4。 2 运行hello 程序
前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发
生了些什么。在这里必须省略很多细节，稍后会做补充，但是现在我们将很满意于这种整
体上的描述。
初始时，shell 程序执行它的指令，等待我们输人一个命令。当我们在键盘上输入字符串
“。/hello”后，shell 程序将字符逐一读人寄存器，再把它存放到内存中，如图1-5 所示。
66
CPU
寄存器文件
PC
ALU
系统总线
内存总线
I/O
"hello"
总线接口
主存储器
桥
||||家
VO 总线
扩展槽，留待
网络适配器一
类的设备使用
USB
图形适配器
磁盘控制器
控制器
鼠标
键盘
显示器
磁盘
用户输入
“hello"
图1-5
从键盘上读取 hello 命令


Page 44
第1章 计算机系统漫游
当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输人。然后
shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 he1lo 目标文件中的代码
和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello， worldln”。
利用直接存储器存取(DMA，将在第6章中讨论)技术，数据可以不通过处理器而直
接从磁盘到达主存。这个步骤如图 1-6 所示。
CPU
寄存器文件
PC
ALU
系统总线
内存总线
I/O
“hello， world\n"
总线接口
主存储器
桥
hello 代码
VO 总线
扩展槽，留待
网络适配器一
类的设备使用
图形
适配器
磁盘
控制器
USB
控制器
鼠标
键盘
显示器
存储在磁盘上的hello
可执行文件
磁盘
图 1-6 从磁盘加载可执行文件到主存
一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello程序
的main 程序中的机器语言指令。这些指令将“hello， worldln”字符串中的字节从主存
复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如
图 1-7 所示。
CPU
寄存器文件
PC
ALU
系统总线
内存总线
I/O
“hello， world\n"
总线接口
主存储器
hello 代码
I/O 总线
扩展槽，留待
网络适配器一
类的设备使用
图形
适配器
磁盘
控制器
USB
控制器
键盘
显示器
“hello， world\n"
鼠标
存储在磁盘上的hello
可执行文件
磁盘
图 1-7 将输出字符串从存储器写到显示器


Page 45
第1章 计算机系统漫游
1。5 高速缓存至关重要
这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方
挪到另一个地方。 hello 程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复
制到主存；当处理器运行程序时，指令又从主存复制到处理器。相似地，数据串“hel-
lo， world/n”开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备。从
程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者
的一个主要目标就是使这些复制操作尽可能快地完成。
根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高
于同类的低速设备。比如说，一个典型系统上的磁盘驱动器可能比主存大 1000 倍，但是对
处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000 万倍。
类似地，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字
节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快 100 倍。更麻烦的是，
随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器
的运行速度比加快主存的运行速度要容易和便宜得多。
针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高
速缓存存储器(cache memory，简称为 cache 或高速缓存)，作为暂时的集结区域，存放处
理器近期可能会需要的信息。图1-8 展示了一个典型系统中的高速缓存存储器。位于处理
器芯片上的L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样
快。一个容量为数十万到数百万字节的更大的L2 高速缓存通过一条特殊的总线连接到处
理器。进程访问L2 高速缓存的时间要比访问L1 高速缓存的时间长5倍，但是这仍然比访
问主存的时间快5~10 倍。L1 和L2 高速缓存是用一种叫做静态随机访问存储器(SRAM)
的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和
L3。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局
部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能
经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。
CPU 芯片
寄存器文件
高速缓存
存储器
ALU
系统总线
内存总线
总线接口
VO桥
主存储器
图 1-8 高速缓存存储器
本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓
存将程序的性能提高一个数量级。你将在第6章里学习这些重要的设备以及如何利用它们。
1。6 存储设备形成层次结构
在处理器和一个较大较慢的设备(例如主存)之间插入一个更小更快的存储设备(例如
高速缓存)的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被


Page 46
10
第1章 计算机系统漫游
组织成了一个存储器层次结构，如图 1-9 所示。在这个层次结构中，从上至下，设备的访
问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结
构中位于最顶部，也就是第0级或记为 LO。这里我们展示的是三层高速缓存 L1 到 L3，
占据存储器层次结构的第1层到第3层。主存在第4层，以此类推。
LO：
更小
寄存器
CPU寄存器保存来自高速缓存
存储器的字
更快
L1：
L1高速缓存
( SRAM )
(每字节)
LI高速缓存保存取自L2高速缓存
的高速缓存行
更贵的
L2高速缓存
( SRAM )
L2：
存储设备
L2高速缓存保存取自L3高速缓存
的高速缓存行
L3高速缓存
( SRAM )
L3：
L3高速缓存保存取自主存
的高速缓存行
更大
主存
( DRAM )
L4：
更慢
主存保存取自本地磁盘
的磁盘块
(每字节)
本地二级存储
(本地磁盘)
L5：
更便宜的
本地磁盘保存取自远程网络
服务器上磁盘的文件
存储设备
远程二级存储
(分布式文件系统，Web服务器)
L6：
图1-9
一个存储器层次结构的示例
存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，
寄存器文件就是 L1的高速缓存， L1 是L2的高速缓存，L2 是L3的高速缓存，L3是主存
的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本
地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。
正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整
个存储器层次结构的理解来提高程序性能。第6章将更详细地讨论这个问题。
1。7 操作系统管理硬件
让我们回到 he1lo 程序的例子。当 shell 加载和运行 hello 程序时，以及 hello 程序输
出自己的消息时，shell 和hello 程序都没有
直接访问键盘、显示器、磁盘或者主存。取而
代之的是，它们依靠操作系统提供的服务。我
们可以把操作系统看成是应用程序和硬件之间
插人的一层软件，如图 1-10 所示。所有应用
应用程序
软件
操作系统
处理器
主存
VO设备
硬件
图1-10
计算机系统的分层视图
程序对硬件的操作尝试都必须通过操作系统。
进程
操作系统有两个基本功能：(1)防止硬
件被失控的应用程序滥用；(2)向应用程序
提供简单一致的机制来控制复杂而又通常大
不相同的低级硬件设备。操作系统通过几个
基本的抽象概念(进程、虚拟内存和文件)来
实现这两个功能。如图 1-11 所示，文件是对
虚拟内存
文件
处理器
主存
I/O设备
图1-11 操作系统提供的抽象表示


Page 47
第1章 计算机系统漫游
11
1/0设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理
器、主存和I/O设备的抽象表示。我们将依次讨论每种抽象表示。
旁注 Unix、Posix 和标准Unix 规范
20 世纪60年代是大型、复杂操作系统盛行的年代，比如IBM的 OS/360 和Honey-
well 的Multics 系统。OS/360是历史上最成功的软件项目之一，而Multics 虽然持续存
在了多年，却从来没有被广泛应用过。贝尔实验室曾经是 Multics项目的最初参与者，
但是因为考虑到该项目的复杂性和缺乏进展而于 1969年退出。鉴于 Mutics项目不愉快
的经历，一群贝尔实验室的研究人员一 Ken Thompson、Dennis Ritchie、Doug Mcll-
roy 和Joe Ossanna，从1969 年开始在DEC PDP-7 计算机上完全用机器语言编写了一个
简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用戶级进程
的 shell 概念，都是来自于Multics，只不过在一个更小、更简单的程序包里实现。1970
年，Brian Kernighan 给新系统命名为“Unix”，这也是一个双关语，暗指“Multics”的
复杂性。1973 年用C重新编写其內核，1974 年，Unix 开始正式对外发布[93]。
贝尔实验室以慷慨的条件向学校提供源代码，所以 Unix 在大专院校里获得了很多
支持并得以持续发展。最有影响的工作发生在20世纪70年代晚期到 80年代早期，在
美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和Internet 协
议，称为 Unix 4。 XBSD(Berkeley Software Distribution)。与此同时，贝尔实验室也在
发布自己的版本，称为System V Unix。其他厂商的版本，比如 Sun Microsystems 的
Solaris 系统，则是从这些原始的BSD 和System V版本中衍生而来。
20 世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的
程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE(电气和电子工程师协
会)开始努力标准化 Unix 的开发，后来由Richard Stallman命名为“Posix”。结果就得
到了一系列的标准，称作Posix 标准。这套标准涵盖了很多方面，比如Unix 系统调用
的C语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为“标准 Unix 规
范”的独立标准化工作已经与Posix一起创建了统一的Unix系统标准。这些标准化工
作的结果是 Unix 版本之间的差异已经基本消失。
1。7。1 进程
像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只
有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。处理器看上去就像
在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对
象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。
进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个
进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一
个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多于可以运行它们的
CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执
行多个程序。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个
进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上
下文切换。为了简化讨论，我们只考虑包含一个 CPU 的单处理器系统的情况。我们会在
1。9。2 节中讨论多处理器系统。


Page 48
12
第1章 计算机系统漫游
操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许
多信息，比如PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器
系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进
程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控
制权传递到新进程。新进程就会从它上次停止的地方开始。图1-12 展示了示例 hello 程
序运行场景的基本理念。
示例场景中有两个并发的进程：shell 进程和 hello 进程。最开始，只有 shell 进程在
运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell 通过调用一个专门
的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系
统保存 shell 进程的上下文，创建一个新的 hello 进程及其上下文，然后将控制权传给新
的 hello 进程。 hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回
给它，shell 进程会继续等待下一个命令行输人。
如图 1-12 所示，从一个进程到另一个进程的转换是由操作系统內核(kernel)管理的。
内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写
文件，它就执行一条特殊的系统调用(system call)指令，将控制权传递给内核。然后内核
执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管
理全部进程所用代码和数据结构的集合。
时间
进程A
进程B
用户代码
read -->
内核代码 }上下文切换
用户代码
磁盘中断--
内核代码 }上下文切换
从read返回-->
用户代码
图 1-12 进程的上下文切换
实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。我们将在第8
章中揭示这项工作的原理，以及应用程序是如何创建和控制它们的进程的。
1。7。2 线程
尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上
可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的
代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模
型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高
效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法，我们将
在1。9。2 节中讨论这个问题。在第 12 章中，你将学习并发的基本概念，包括如何写线程
化的程序。
1。7。3 虚拟内存
虚拟內存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用
主存。每个进程看到的内存都是一致的，称为虚拟地址空间。图1-13 所示的是Linux 进程的


Page 49
第1章 计算机系统漫游
13
虚拟地址空间(其他 Unix 系统的设计也与此类似)。在 Linux 中，地址空间最上面的区域是
保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放
用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。
内核虚拟内存
「用户代码不可见的
内存
用户栈
(运行时创建的)
共享库的内存
映射区域
printf
运行时堆
(在运行时由malloc创建的)
读写数据
从hello可执行
文件加载进来的
只读的代码和数据
程序开始
图1-13 进程的虚拟地址空间
每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在
本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益
的。我们从最低的地址开始，逐步向上介绍。
●程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和
C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初
始化的，在示例中就是可执行文件 hello。在第7章我们研究链接和加载时，你会
学习更多有关地址空间的内容。
●堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被
指定了大小，与此不同，当调用像 malloc 和 free 这样的C标准库函数时，堆可
以在运行时动态地扩展和收缩。在第9章学习管理虚拟内存时，我们将更详细地研
究堆。
共享库。大约在地址空间的中间部分是一块用来存放像 C标准库和数学库这样的共
享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第7章介绍动
态链接时，将学习共享库是如何工作的。
●栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一
样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函
数时，栈就会增长；从一个函数返回时，栈就会收缩。在第3章中将学习编译器是
如何使用栈的。
*内核虛拟內存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区
域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些
操作。


Page 50
14
第1章 计算机系统漫游
虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每
个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为
磁盘的高速缓存。第9章将解释它如何工作，以及为什么对现代系统的运行如此重要。
1。7。4 文件
文件就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网
络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O的系
统函数调用读写文件来实现的。
文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视
图，来看待系统中可能含有的所有各式各样的I/O设备。例如，处理磁盘文件内容的应用
程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在
使用不同磁盘技术的不同系统上运行。你将在第10 章中学习 Unix I/O。
旁注 Linux 项目
1991 年8月，芬兰研究生Linus Torvalds谨慎地发布了一个新的类 Unix 的操作系
统内核，内容如下。
* É： torvalds@klaava。 Helsinki。 FI(Linus Benedict Torvalds)
#T A 1： comp。 os。 minix
主题：在minix 中你最想看到什么?
摘要：关于我的新操作系统的小调查
时间：1991 年8月25 日 20：57：08 GMT
每个使用 minix的朋友，你们好。
我正在做一个(免费的)用在386(486) AT 上的操作系统(只是业余爱好，它不会像
GNU 那样庞大和专业)。这个想法自4月份就开始酝酿，现在快要完成了。我希望得到
各位对 minix 的任何反馈意见，因为我的操作系统在某些方面与它相类似(其中包括相
同的文件系统的物理设计(因为某些实际的原因))。
我现在已经移植了 bash(1。08)和 gcc(1。 40)，并且看上去能运行。这意味着我需要
个月的时间来让它变得更实用 一些，并且，我想要知道大多数人想要什么特性。欢迎
任何建议，但是我无法保证我能实现它们。-)
Linus (torvalds@kruuna。helsinki。fi)
就像 Torvalds 所说的，他创建Linux 的起点是Minix，由Andrew S。 Tanenbaum出
于教育目的开发的一个操作系统[113]。
接下来，如他们所说，这就成了历史。Linux 逐渐发展成为一个技术和文化现象。
通过和GNU 项目的力量结合，Linux项目发展成了一个完整的、符合 Posix 标准的
Unix 操作系统的版本，包括内核和所有支撑的基础设施。从手持设备到大型计算机，
Linux 在范围如此广泛的计算机上得到了应用。IBM的一个工作组甚至把 Linux 移植到
了一块腕表中!
1。8 系统之间利用网络通信
系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现


Page 51
第1章 计算机系统漫游
15
代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个
I/O设备，如图1-14 所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络
到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器
发送来的数据，并把数据复制到自己的主存。
CPU 芯片
寄存器文件
PC
ALU
系统总线
内存总线
总线接口
VO桥
主存储器
扩展槽
VO 总线
USB
控制器
图形适配器
磁盘控制器
网络适配器
鼠标
键盘
显示器
网络
磁盘
图1-14
网络也是一种I/O设备
随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为
计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和telnet 这
样的应用都是基于网络复制信息的功能。
回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello程
序。假设用本地主机上的 telnet 客户端连接远程主机上的 telnet 服务器。在我们登录到远
程主机并运行 shell 后，远端的shell 就在等待接收输人命令。此后在远端运行 hello 程序
包括如图1-15 所示的五个基本步骤。
1. 用户在键盘上
输入“hello”
2. 客户端向telnet服务器
发送字符串“hello”
3. 服务器向shell发送字符
串“hello”， shell运
行hello程序并将输出
发送给telnet服务器
本地telnet
客户端
远程telnet
服务器
5。客户端在显示器上打印
“hello world\n"
字符串
4. telnet服务器向客户端发送
字符串“hello worldln”
图1-15
利用 telnet 通过网络远程运行 hello
当我们在 telnet 客户端键人“hello”字符串并敲下回车键后，客户端软件就会将这
个字符串发送到 telnet 的服务器。telnet 服务器从网络上接收到这个字符串后，会把它传
递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务
器。最后，telnet 服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出申输出
到我们的本地终端上。
这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。在第11章
中，你将学会如何构造网络应用程序，并利用这些知识创建一个简单的 Web 服务器。


Page 52
16
第1章 计算机系统漫游
1。9 重要主题
在此，小结一下我们旋风式的系统漫游。这次讨论得出一个很重要的观点，那就是系
统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到
运行应用程序的最终目的。本书的余下部分会讲述硬件和软件的详细内容，通过了解这些
详细内容，你可以写出更快速、更可靠和更安全的程序。
作为本章的结束，我们在此强调几个贯穿计算机系统所有方面的重要概念。我们会在
本书中的多处讨论这些概念的重要性。
1。9。1 Amdahl 定律
Gene Amdahl，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做
出了简单却有见地的观察。这个观察被称为 Amdahl 定律(Amdahl's law)。该定律的主要
思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要
性和加速程度。若系统执行某应用程序需要时间为 Tad。假设系统某部分所需执行时间与
该时间的比例为a，而该部分性能提升比例为k。即该部分初始所需时间为aTad，现在所
需时间为(aTau)/k。因此，总的执行时间应为
α，
Tnew
= (1-a) Told + (aT old)/k = Told [(1- a) +a/k]
由此，可以计算加速比 S=Tad/Thew 为
1
(1。 1)
S =
(1– a) +a/k
举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为60%(a=0。6)，其加速比
例因子为3(k=3)。则我们可以获得的加速比为1/[0。 4+0。6/3]=1。67 倍。虽然我们对系统的
一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是
Amdahl 定律的主要观点一一要想显著加速整个系统，必须提升全系统中相当大的部分的速度。
旁注表示相对性能
性能提升最好的表示方法就是用比例的形式 Tald/ Thew ，其中，Tad为原始系统所需
时间，Thew为修改后的系统所需时间。如果有所改进，则比值应大于1。我们用后缀
“X”来表示比例，因此，“2。 2X”读作“2。 2倍”。
表示相对变化更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义
是模糊的。应该等于 100。(Tad- Thew)/Thew ，还是 100。(Taa一 Thew)/Tad，还是其他
的值?此外，它对较大的变化也没有太大意义。与简单地说性能提升 2。2X相比，“性能
提升了120%”更难理解。
old ，
练习题1。1 假设你是个卡车司机，要将土豆从爱达荷州的Boise 运送到明尼苏达州
的 Minneapolis，全程 2500 公里。在限速范围内，你估计平均速度为 100 公里/小时，
整个行程需要 25 个小时。
A。你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有1500 公里卡车的速度可
以为 150 公里/小时。那么这对整个行程的加速比是多少?
B。 你可以在 www。fasttrucks。 com 网站上为自己的卡车买个新的涡轮增压器。网站现
货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为
1。67X，那么你必须以多快的速度通过蒙大拿州?


Page 53
第1章 计算机系统漫游
17
练习题1。2 公司的市场部向你的客戶承诺，下一个版本的软件性能将改进 2X。这
项任务被分配给你。你已经确认只有 80%的系统能够被改进，那么，这部分需要被
改进多少(即k取何值)才能达到整体性能目标?
Amdahl 定律一个有趣的特殊情况是考虑k趋向于时的效果。这就意味着，我们可
以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。
于是我们得到
1
(1。 2)
(1
举个例子，如果 60%的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有
1/0。 4=2。 5X。
Amdahl 定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之
外，它还可以用在公司试图降低刀片制造成本，或学生想要提高自己的绩点平均值等方
面。也许它在计算机世界里是最有意义的，在这里我们常常把性能提升2倍或更高的比例
因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。
1。9。2 并发和并行
数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算
机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，
这两个因素都会改进。我们用的术语并发(concurrency)是一个通用的概念，指一个同时具
有多个活动的系统；而术语并行(parallelism)指的是用并发来使一个系统运行得更快。并
行可以在计算机系统的多个抽象层次上运用。在此，我们按照系统层次结构中由高到低的
顺序重点强调三个层次。
1。线程级并发
构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了
并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自20世纪 60 年代初期出
现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执
行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好
像一个杂要艺人保持多个球在空中飞舞一样。这种并发形式允许多个用户同时与系统交
互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多
个任务，例如，在一个窗口中开启 Web 浏览器，在另一窗口中运行字处理器，同时又播
放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处
理器来完成的。这种配置称为单处理器系统。
当构建一个由单操作系统内核控制的多处理
器组成的系统时，我们就得到了一个多处理器系
统。其实从20 世纪 80 年代开始，在大规模的计
算中就有了这种系统，但是直到最近，随着多核
处理器和超线程(hyperthreading)的出现，这种
系统才变得常见。图 1-16 给出了这些不同处理
器类型的分类。
多核处理器是将多个 CPU(称为“核”)集成
到一个集成电路芯片上。图1-17 描述的是一个
所有的处理器
多处理器
单处理器
多核
超线程的
图1-16 不同的处理器配置分类。随着多核
处理器和超线程的出现，多处理器
变得普遍了


Page 54
18
第1章 计算机系统漫游
典型多核处理器的组织结构，其中微处理器芯片有4个 CPU 核，每个核都有自己的 L1 和
L2 高速缓存，其中的 L1 高速缓存分为两个部分一一一个保存最近取到的指令，另一个存
放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能
够将几十个、最终会是上百个核做到一个芯片上。
处理器封装包
核0
核3
寄存器
寄存器
L1数据
高速缓存
L1指令
高速缓存
L1数据
高速缓存
LI指令
高速缓存
L2统一的高速缓存
L2统一的高速缓存
L3统一的高速缓存(所有的核共享)
主存
图1-17
多核处理器的组织结构。4个处理器核集成在一个芯片上
超线程，有时称为同时多线程(simultaneous multi-threading)，是一项允许一个 CPU
执行多个控制流的技术。它涉及CPU 某些硬件有多个备份，比如程序计数器和寄存器文
件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约
20 000 个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定
要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。比如，假设一个线程必
须等到某些数据被装载到高速缓存中，那CPU 就可以继续去执行另一个线程。举例来说，
Intel Core i7 处理器可以让每个核执行两个线程，所以一个4 核的系统实际上可以并行地
执行8个线程。
多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟
并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行
多个活动。其次，它可以使应用程序运行得更快，当然，这必须要求程序是以多线程方式
来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50
年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程
序的方法利用硬件开发线程级并行性。第12 章会更深人地探讨并发，以及使用并发来提
供处理器资源的共享，使程序的执行允许有更多的并行。
2. 指令级并行
在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早
期的微处理器，如 1978 年的Intel 8086，需要多个(通常是3~10个)时钟周期来执行一条
指令。最近的处理器可以保持每个时钟周期2~4条指令的执行速率。其实每条指令从开


Page 55
第1章 计算机系统漫游
19
始到结束需要长得多的时间，大约 20 个或者更多周期，但是处理器使用了非常多的聪明
技巧来同时处理多达 100 条指令。在第4章中，我们会研究流水线(pipelining)的使用。在
流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系
列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同
部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一个时钟周期一条指令的
执行速率。
如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量(super-
scalar)处理器。大多数现代处理器都支持超标量操作。第5章中，我们将描述超标量处理
器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有
更高程度的指令级并行性的程序代码，因而也运行得更快。
3。单指令、多数据并行
在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执
行的操作，这种方式称为单指令、多数据，即 SIMD 并行。例如，较新几代的 Intel 和
AMD处理器都具有并行地对8对单精度浮点数(C数据类型 float)做加法的指令。
提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然
有些编译器会试图从C程序中自动抽取 SIMD 并行性，但是更可靠的方法是用编译泽器支持
的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第5章中比较
通用的程序优化描述的补充，我们在网络旁注OPT：SIMD 中描述了这种编程方式。
1。9。3 计算机系统中抽象的重要性
抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的
应用程序接口(API)就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用
这些代码。不同的编程语言提供不同形式和等级的抽象支持，例如 Java 类的声明和C语
言的函数原型。
*我们已经介绍了计算机系统中使用的几个抽象，如图 1-18 所示。在处理器里，指令
集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行
在一个一次只执行一条指令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行
地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的
处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。
虚拟机
进程
指令集架构
虚拟内存
文件
操作系统
处理器
主存
VO设备
图1-18 计算机系统提供的一些抽象。计算机系统中的一个重大主题就是
提供不同层次的抽象表示，来隐藏实际实现的复杂性
在学习操作系统时，我们介绍了三个抽象：文件是对 1/O设备的抽象，虛拟内存是对
程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象：


Page 56
20
第1章 计算机系统漫游
虛拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是
IBM 在20 世纪60 年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一
些计算机必须能够运行为不同的操作系统(例如， Microsoft Windows、MacOS 和 Linux)
或同一操作系统的不同版本设计的程序。
在本书后续的章节中，我们会具体介绍这些抽象。
1。10 小结
计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示
为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是
ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。
处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和
CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构一CPU 寄存器在顶部，接着是多
层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的
存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速
缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。
操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象：1)文件是对I/O设备的抽象；
2)虚拟内存是对主存和磁盘的抽象；3)进程是处理器、主存和 I/O 设备的抽象。
最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O设备。
参考文献说明
Ritchie写了关于早期 C和Unix 的有趣的第一手资料[91，92]。Ritchie 和Thompson 提供了最早出
版的 Unix 资料[93]。Silberschatz、Galvin 和Gagne[102]提供了关于 Unix 不同版本的详尽历史。GNU
(www。gnu。org)和 Linux(www。 linux。 org)的网站上有大量的当前信息和历史资料。Posix 标准可以在线
#4 (www。unix。 org)。
练习题答案
该问题说明 Amdahl 定律不仅仅适用于计算机系统。
A。根据公式1。 1，有a=0。6，k=1。5。更直接地说，在蒙大拿行驶的1500 公里需要 10 个小时，而
其他行程也需要 10个小时。则加速比为25/(10+10)=1。25X。
B。根据公式1。1，有a=0。6，要求 S=1。67，则可算出k。更直接地说，要使行程加速度达到1。67X，我
们必须把全程时间减少到 15 个小时。蒙大拿以外仍要求为 10 小时，因此，通过蒙大拿的时间
就为5个小时。这就要求行驶速度为 300 公里/小时，对卡车来说这个速度太快了!
理解 Amdahl 定律最好的方法就是解决一些实例。本题要求你从特殊的角度来看公式 1。1。
本题是公式的简单应用。已知 S=2， a=0。8，则计算 k：
1. 1
1. 2
2 =
(1– 0。 8) + 0。 8/k
0. 4+1。 6/k = 1。 0
k = 2。 67


Page 57
第一部分
A
R
1
程序结构和执行
我们对计算机系统的探索是从学习计算机本身开始的，它由
处理器和存储器子系统组成。在核心部分，我们需要方法来表示
基本数据类型，比如整数和实数运算的近似值。然后，我们们考虑
机器级指令如何操作这样的数据，以及编译器又如何将 C程序翻
译成这样的指令。接下来，研究几种实现处理器的方法，帮助我
们更好地了解硬件资源如何被用来执行指令。一旦理解了编译器
和机器级代码，我们就能了解如何通过编写 C程序以及编译它们
来最大化程序的性能。本部分以存储器子系统的设计作为结束東，
这是现代计算机系统最复杂的部分之一。
本书的这一部分将领着你深入 了解如何表示和执行应用程序。
你将学会一些技巧，来帮助你写出安全、可靠且充分利用计算资
源的程序。


Page 58
第2章
A
E
2
信息的表示和处理
现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称
为位(bit)，形成了数字革命的基础。大家熟悉并使用了 1000 多年的十进制(以10 为基数)
起源于印度，在 12 世纪被阿拉伯数学家改进，并在 13 世纪被意大利数学家 Leonardo
Pisano(大约公元 1170一1250，更为大家所熟知的名字是Fibonacci)带到西方。对于有10
个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机
器时，二进制值工作得更好。二值信号能够很容易地被表示、存储和传输，例如，可以表
示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对
二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片
上集成数百万甚至数十亿个这样的电路。
孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(inter-
pretation)，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比
如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，
我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种编码，以及负数
表示和实数近似值的编码。
我们研究三种最重要的数字表示。无符号(unsigned)编码基于传统的二进制表示法，
表示大于或者等于零的数字。补码(two's-complement)编码是表示有符号整数的最常见的
方式，有符号整数就是可以为正或者为负的数字。浮点数(floating-point)编码是表示实数
的科学记数法的以2为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加
法和乘法，类似于对应的整数和实数运算。
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表
示时，某些运算就会溢出(overflow)。溢出会导致某些令人吃惊的后果。例如，在今天的
大多数计算机上(使用32位来表示数据类型 int)，计算表达式 200*300*400*500 会得出结果
-884 901 888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。
另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利
用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出结果-884 901 888：
(500
* 400) *
(300 * 200)
( (500 * 400) * 300) * 200
( (200 * 500) * 300) * 400
400
(200 * (300 * 500))
计算机可能没有产生期望的结果，但是至少它是一致的!
浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值十0，但是一组正数的乘
积总是正的。由于表示的精度有限，浮点运算是不可结合的。例如，在大多
表达式(3。14+1e20)-1e20求得的值会是0。0，而3。14+ (le20-le20)求得的值会是3。14。
整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不
同一整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮
醫上，C


Page 59
第2章 信息的表示和处理
23
点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。
通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属
性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作
系统和编译器组合的可移植性，了解这种属性是非常重要的。后面我们会讲到，大量计算
机的安全漏洞都是由于计算机算术运算的微妙细节引发的。在早期，当人们碰巧触发了程
序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何
漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们
的程序如何工作，以及如何被迫产生不良的行为。
计算机用几种不同的二进制表示形式来编码数值。随着第3章进人机器级编程，你需
要熟悉这些表示方式。在本章中，我们描述这些编码，并且教你如何推出数字的表示。
通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对
于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。
我们对这部分内容的处理是基于一组核心的数学原理的。从编码的基本定义开始，然
后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。我们
相信从这样一个抽象的观点来分析这些内容，对你来说是很重要的，因为程序员需要对计
算机运算与更为人熟悉的整数和实数运算之间的关系有清晰的理解。
旁注 怎样阅读本章
本章我们研究在计算机上如何表示数字和其他形式数据的基本属性，以及计算机对
这些数据执行操作的属性。这就要求我们深入研究数学语言，编写公式和方程式，以及
展示重要属性的推导。
为了帮助你阅读，这部分内容安排如下：首先给出以数学形式表示的属性，作为原
理。然后，用例子和非形式化的讨论来解释这个原理。我们建议你反复阅读原理描述和
它的示例与讨论，直到你对该属性的说明内容及其重要性有了牢固的直觉。对于更加复
杂的属性，还会提供推导，其结构看上去将会像一个数学证明。虽然最终你应该尝试理
解这些推导，但在第一次阅读时你可以跳过它们。
我们也鼓励你在阅读正文的过程中完成练习题，这会促使你主动学习，帮助你理论联
系实际。有了这些例题和练习题作为背景知识，再返回推导，你将发现理解起来会容易许
多。同时，请放心，掌握好高中代数知识的人都具备理解这些内容所需要的数学技能。
C++ 编程语言建立在C语言基础之上，它们使用完全相同的数字表示和运算。本章
中关于C的所有内容对 C++ 都有效。另一方面，Java 语言创造了一套新的数字表示和运
算标准。C标准的设计允许多种实现方式，而Java标准在数据的格式和编码上是非常精确
具体的。本章中多处着重介绍了 Java 支持的表示和运算。
旁注 C编程语言的演变
前面提到过，C 编程语言是贝尔实验室的 Dennis Ritchie 最早开发出来的，目的是
和 Unix 操作系统一起使用(Unix 也是贝尔实验室开发的)。在那个时候，大多数系统程
序，例如操作系统，为了访问不同数据类型型的低级表示，都必须大量地使用汇编代码。
比如说，像 malloc 库函数提供的內存分配功能，用当时的其他高级语言是无法编写的。
Brian Kernighan和 Dennis Ritchie 的著作的第1版[60]记录了最初贝尔实验室的 C
语言版本。随着时间的推移，经过多个标准化组织的努力，C语言也在不断地演变。1989
券


Page 60
24
第一部分 程序结构和执行
年，美国国家标准学会下的一个工作组推出了ANSI C 标准，对最初的贝尔实验室的C
语言做了重大修改。ANSI C与贝尔实验室的 C有了很大的不同，尤其是函数声明的方
式。Brian Kernighan和Dennis Ritchie在著作的第2版[61]中描述了 ANSI C，这本书
至今仍被公认为关于C语言最好的参考手册之一。
国际标准化组织接替了对C语言进行标准化的任务，在 1990 年推出了一个几乎和
ANSI C 一样的版本，称为“ISO C90”。该组织在 1999 年又对 C语言做了更新，推出
“ISO C99”。在这一版本中，引入了一些新的教据类型，对使用不符合英语语言字符的
文本字符串提供了支持。更新的版本 2011 年得到批准，称为“ISO C11”，其中再次添
加了更多的数据类型和特性。最近增加的大多数内容都可以向后兼容，这意味着根据早
期标准(至少可以回溯到 ISO C90) 编写的程序按新标准编译时会有同样的行为。
GNU * (GNU Compiler Collec-
tion， GCC)可以基于不同的命令行选项，依照
多个不同版本的C语言规则来编译程序，如图2-
1所示。比如，根据 ISO C11 来编译程序 prog。
C，我们就使用命令行：
C版本
GCC命令行选项
GNU 89
t， -std=gnu89
ANSI， ISO C90
-ansi， -std=c89
ISO C99
-std=c99
ISO C11
-std=c11
linux> gcc -std=c11 prog。c
图2-1
向 GCC 指定不同的C语言版本
编译选项-ansi 和-std=c89 的用法是一样的一会根据 ANSI 或者ISO C90 标准来编
译程序。(C90 有时也称为“C89”，这是因为它的标准化工作是从 1989 年开始的。)编译
选项-std=c99会让编译器按照 ISO C99 的规则进行编译。
本书中，没有指定任何编译选项时，程序会按照基于 ISO C90的C语言版本进行编
译，但是也包括一些 C99、C11的特性，一些C++ 的特性，还有一些是与GCC相关的
特性。GNU 项目正在开发一个结合了 ISO C11 和其他一些特性的版本，可以通过命令行
选项-std=gnu11 来指定。(目前，这个实现还未完成。)今后，这个版本会成为默认的版本。
2。1 信息存储诸
大多数计算机使用8位的块，或者字节(byte)，作为最小的可寻址的内存单位，而不
是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存
(virtual memory)。内存的每个字节都由一个唯一的数字来标识，称为它的地址(ad-
dress)，所有可能地址的集合就称为虚拟地址空间(virtual address space)。顾名思义，这
个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现(见第9章)是将动
态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为
程序提供一个看上去统一的字节数组。
在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可
管理的单元，来存放不同的程序对象(program object)，即程序数据、指令和控制信息。
可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完
成的。例如，C语言中一个指针的值(无论它指向一个整数、一个结构或是某个其他程序
对象)都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系
起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置
处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数
据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。


Page 61
第2章 信息的表示和处理
25
给C语言初学者 C语言中指针的作用
指针是C语言的一个重要特性。它提供了引用数据结构(包括数组)的元素的机制。
与变量类似，指针也有两个方面；值和类型。它的值表示某个对象的位置，而它的类型
表示那个位置上所存储对象的类型(比如整数或者浮点数)。
真正理解指针需要查看它们在机器级上的表示以及实现。这将是第3章的重点之
一，3。 10。1 节将对其进行深入介绍。
2。1。1 十六进制表示法
一个字节由8位组成。在二进制表示法中，它的值域是 00000000。~11111111，。如果看
成十进制整数，它的值域就是O10~25510。
方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，
以16 为基数，或者叫做十六进制(hexadecimal)数，来表示位模式。十六进制(简写为“hex”)
使用数字‘0”~ ‘9'以及字符“A’~‘F'来表示 16 个可能的值。图 2-2 展示了16个十
六进制数字对应的十进制值和二进制值。用十六进制书写，一个字节的值域为 0016~FFis。
两种符号表示法对于描述位模式来说都不是非常
十六进制数字
十进制值
二进制值
十六进制数字
十进制值
二进制值
1
2
3
4
5
6。
7
1
2
3
4
6。
7
0000
0001
0010
0011
0100
0101
0110
0111
8。
9。
A
E
F
8。
9。
10
11
12
13
14
15
1000
1001
1010
1011
1100
1101
1110
1111
图 2-2
十六进制表示法。每个十六进制数字都对 16 个值中的一个进行了编码
在C语言中，以 Ox 或 OX 开头的数字常量被认为是十六进制的值。字符‘A’
既可以是大写，也可以是小写。例如，我们可以将数字 FA1D37 Bi6写作 0XFA1D37B，或者
Oxfald37b，甚至是大小写混合，比如，OxFalD37b。在本书中，我们将使用 C表示法来
表示十六进制值。
编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间
人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制
数字的转换。数字的转换可以参考如图 2-2 所示的表。一个简单的窍门是，记住十六进制
数字 A、C和F相应的十进制值。而对于把十六进制值 B、D和E转换成十进制值，则可
以通过计算它们与前三个值的相对关系来完成。
比如，假设给你一个数字 OX173A4C。可以通过展开每个十六进制数字，将它转换为
二进制格式，如下所示：
'F'
十六进制
1
7
3
A
4
二进制
0001
0111
0011
1010
0100
1100
这样就得到了二进制表示 000101110011101001001100。
反过来，如果给定一个二进制数字 1111001010110110110011，可以通过首先把它分为
每4位一组来转换为十六进制。不过要注意，如果位总数不是4的倍数，最左边的一组可
以少于4位，前面用0补足。然后将每个4位组转换为相应的十六进制数字：
二进制
11
1100
1010
1101
1011
0011
十六进制
练习题 2。1
3
C
A
D
3
完成下面的数字转换：


Page 62
26
第一部分 程序结构和执行
A。将 OX39A7F8 转换为二进制。
B。将二进制 1100100101111011 转换为十六进制。
C。 将 OXD5E4CC转换为二进制。
D。将二进制 1001101110011110110101 转换为十六进制。
当值c是2的非负整数 n次幂时，也就是z=2"，我们可以很容易地将z写成十六进
制形式，只要记住z的二进制表示就是1后面跟n个0。十六进制数字0代表4个二进制
0。所以，当n表示成i+4j的形式，其中 0<i<3，我们可以把x写成开头的十六进制数
字为1(i=0)、2(i=1)、4(i=2)或者 8(i=3)，后面跟随着j个十六进制的0。比如，x=
2048=2"，我们有n=11=3+4。2，从而得到十六进制表示 Ox800。
练习题2。2 填写下表中的空白项，给出2的不同次幂的二进制和十六进制表示：
2"(十进制)
2"(十六进制)
n
512
0x200
19
16 384
Ox10000
17
32
0x80
十进制和十六进制表示之间的转换需要使用乘法或者除法来处理一般情况。将一个十
进制数字z转换为十六进制，可以反复地用16 除a，得到一个商9 和一个余数r，也就是
=g，16+r。然后，我们用十六进制数字表示的r作为最低位数字，并且通过对q反复
进行这个过程得到剩下的数字。例如，考虑十进制 314 156 的转换：
314 156=19 634 • 16+12
(C)
19 634= 1227 •
16+2
(2)
1227=
76
16+11
(B)
76=
4 •
16+12
(C)
4=
0 • 16+4
(4)
从这里，我们能读出十六进制表示为 0X4CB2C。
反过来，将一个十六进制数字转换为十进制数字，我们可以用相应的 16 的幂乘以每
个十六进制数字。比如，给定数字 OX7AF，我们计算它对应的十进制值为7。162 +10。
16+15=7• 256+10 • 16+15=1792+160+15=1967。
A练习题2。3 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出
不同字节模式的十进制、二进制和十六进制值：
十进制
二进制
十六进制
0000 0000
Ох00
167
62
188
0011 0111
1000 1000
1111 0011
0x52
ОХАС
OXE7


Page 63
第2章 信息的表示和处理
27
旁注 十进制和十六进制间的转换
较大教值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。有大
量的工具可以完成这个工作。一个简单的方法就是利用任何标准的搜索引擎，比如查询：
把 Oxabcd 转换为十进制数
或
把 123 用十六进制表示。
练习题2。4 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用
十六进制表示。提示：只要将执行十进制加法和減法所使用的方法改成以 16 为基数。
A。 0x503c+0x8=
В。 Ох503с-0х40-
C。 Ox503c+64=
D。 Оx50ea-0х503с%D
2。1。 2 字数据大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size)。因为
虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空
间的最大大小。也就是说，对于一个字长为 w位的机器而言，虚拟地址的范围为0~2"-1，
程序最多访问2w个字节。
最近这些年，出现了大规模的从32 位字长机器到64 位字长机器的迁移。这种情况首先出
现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在
智能手机的处理器上。32 位字长限制虚拟地址空间为4 千兆字节(写作4GB)，也就是说，刚刚
超过 4X10字节。扩展到64 位字长使得虚拟地址空间为 16EB，大约是1。 84X1019字节。
大多数 64 位机器也可以运行为32 位机器编译的程序，这是一种向后兼容。因此，举
例来说，当程序 prog。c用如下伪指令编译后
linux> gcc -m32 prog。C
C声明
字节数
该程序就可以在32 位或 64 位机器上正确运
行。另一方面，若程序用下述伪指令编译
有符号
无符号
32位
64位
linux> gcc -m64 prog。C
(signed] char
unsigned char
1
1
那就只能在64 位机器上运行。因此，我
们将程序称为“32 位程序”或“64 位程
序”时，区别在于该程序是如何编译的，
而不是其运行的机器类型。
计算机和编译器支持多种不同方式编
码的数字格式，如不同长度的整数和浮点
数。比如，许多机器都有处理单个字节的
指令，也有处理表示为2字节、4字节或
者8字节整数的指令，还有些指令支持表
short
unsigned short
int
unsigned
4
long
unsigned long
4
8
int32_t
uint32_t
4
4
int64_t
uint64_t
8
8
char *
4
8
float
4
4
double
8
示为4字节和8字节的浮点数。
C语言支持整数和浮点数的多种数据
格式。图 2-3 展示了为C语言各种数据类
图2-3 基本C数据类型的典型大小(以字节为单位)。
分配的字节数受程序是如何编译的影响而变化。
本图给出的是32 位和 64 位程序的典型值
4。


Page 64
28
第一部分 程序结构和执行
型分配的字节数。(我们在2。2节讨论 C标准保证的字节数和典型的字节数之间的关系。)
有些数据类型的确切字节数依赖于程序是如何被编译的。我们给出的是 32 位和 64 位程序
的典型值。整数或者为有符号的，即可以表示负数、零和正数；或者为无符号的，即只能
表示非负数。C的数据类型 char 表示一个单独的字节。尽管“char”是由于它被用来存
储文本串中的单个字符这一事实而得名，但它也能被用来存储整数值。数据类型 short、
int 和 long 可以提供各种数据大小。即使是为64位系统编译，数据类型 int 通常也只有
4个字节。数据类型 long 一般在 32 位程序中为4字节，在64 位程序中则为8字节。
为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引人了
一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有有数据类型
int32_t 和 int64_t，它们分别为4个字节和8个字节。使用确定大小的整数类型是程序
员准确控制数据表示的最佳途径。
大部分数据类型都编码为有符号数值，除非有前缀关键字 unsigned 或对确定大小的
数据类型使用了特定的无符号声明。数据类型 char 是一个例外。尽管大多数编译器和机
器将它们视为有符号数，但C标准不保证这一点。相反，正如方括号指示的那样，程序员
应该用有符号字符的声明来保证其为一个字节的有符号数值。不过，在很多情况下，程序
行为对数据类型 char 是有符号的还是无符号的并不敏感。
对关键字的顺序以及包括还是省略可选关键字来说，C语言允许存在多种形式。比
如，下面所有的声明都是一个意思：
unsigned long
unsigned long int
long unsigned
long unsigned int
我们将始终使用图 2-3 给出的格式。
图 2-3 还展示了指针(例如一个被声明为类型为
长。大多数机器还支持两种不同的浮点数格式：单精度 (在 C中声明为 float)和双精度
(在C中声明为 double)。这些格式分别使用4字节和8字节。
char *
”的变量)使用程序的全字
给C语言初学者声明指针
对于任何数据类型 T，声明
T *p；
表明p是一个指针变量，指向一个类型为T的对象。例如，
char *p；
就将一个指针声明为指向一个 char 类型的对象。
程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就
是使程序对不同数据类型的确切大小不敏感。C语言标准对不同数据类型的数字范围设置了
下界(这点在后面还将讲到)，但是却没有上界。因为从 1980 年左右到 2010 年左右，32 位机
器和32 位程序是主流的组合，许多程序的编写都假设为图 2-3 中32位程序的字节分配。随
着 64 位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就
会显现出来，成为错误。比如，许多程序员假设一个声明为 int类型的程序对象能被用来存储
一个指针。这在大多数 32 位的机器上能正常工作，但是在一台64位的机器上却会导致问题。


Page 65
第2章 信息的表示和处理
29
2。1。3 寻址和字节顺序
对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及
在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序
列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为 int 的变量 x的地址
为 Ox100，也就是说，地址表达式 &x的值为0x100。那么，(假设数据类型型 int 为32 位表
示)x的4个字节将被存储在内存的 Ox100、0x101、0x102和 Ox103 位置。
排列表示一个对象的字节有两个通用的规则。考虑一个 w位的整数，其位表示为[xwー1，
…，Z，To]，其中 zu-1是最高有效位，而x。是最低有效位。假设 w是8的倍数，这
些位就能被分组成为字节，其中最高有效字节包含位[xwー1， Tu-2，…，Tu-8]，而最低有效
字节包含位[x，IG，*'
有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效
字节的顺序存储。前一种规则一一最低有效字节在最前面的方式，称为小端法(little endian)。
后一种规则一一最高有效字节在最前面的方式，称为大端法(big endian)。
假设变量x的类型为int，位于地址 0x100处，它的十六进制值为 Ox01234567。地
址范围 Ox100~ Ox103 的字节顺序依赖于机器的类型：
， zo]，其他字节包含中间的位。某些机器选择在内存中按照从最低
大端法
0x100
0x101
0x102
0x103
小端法
0x100
0x101
0x102
0x103
45
01
。。。
。。。
注意，在字 Ox01234567 中，高位字节的十六进制值为 Ox01，而低位字节值为0x67。
大多数 Intel 兼容机都只用小端模式。另一方面，IBM 和Oracle(从其 2010 年收购
Sun Microsystems 开始)的大多数机器则是按大端模式操作。注意我们说的是“大多数”。
这些规则并没有严格按照企业界限来划分。比如，IBM 和Oracle 制造的个人计算机使用
的是Intel 兼容的处理器，因此使用小端法。许多比较新的微处理器是双端法(bi-endian)，
也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择
了特定操作系统，那么字节顺序也就固定下来。比如，用于许多移动电话的 ARM 微处理
器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统-
Android(来自Google)和IOS(来自 Apple)-
令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际
上，术语“little endian(小端)”和“big endian(大端)”出自Jonathan Swift 的《格利佛游
记》(Gulliver's Travels)一书，其中交战的两个派别无法就应该从哪一端(小端还是大端)
打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，选择何种字节顺序没有技术上的理
由，因此争论沦为关于社会政治论题的争论。只要选择了一种规则并且始终如一地坚持，
-却只能运行于小端模式。
对于哪种字节排序的选择都是任意的。
“端”的起源
以下是Jonathan Swift在1726年关于大小端之争历史的描述：
旁注


Page 66
30
第一部分 程序结构和执行
…我下面要告诉你的是，Lilliput 和 Blefuscu 这两大强国在过去 36个月里一直
66。。。。。。
在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破
鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个
手指弄破了，因此他的父亲，当时的皇帝，就下了一道救令，命令全体臣民吃鸡蛋时打
破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此
曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由 Ble-
fuscu 的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。
据估计，先后几次有11 000 人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，
曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不
得做官。”(此段译文摘自网上蒋剑锋译的《格利佛游记》第一卷第4章。)
在他那个时代， Swift是在讽刺英国(Lilliput)和法国(Blefuscu)之间持续的冲突。
Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序
[24]，后来这个术语被广泛接纳了。
对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种
类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先
是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产
生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。
为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以
确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的
内部表示。我们将在第11 章中看到这种转换的例子。
第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在
检查机器级程序时。作为一个示例，从某个文件中摘出了下面这行代码，该文件给出了一
个针对 Intel x86-64 处理器的机器级代码的文本表示：
4004d3：
01 05 43 Ob 20 00
add
%eax，0x200b43(%rip)
这一行是由反汇编器(disassembler)生成的，反汇编器是一种确定可执行程序文件所表示
的指令序列的工具。我们将在第3章中学习有关这些工具的更多知识，以及怎样解释像这
样的行。而现在，我们只是注意这行表述的意思是：十六进制字节串 01 05 43 Ob 20 00 是
一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值的存储地址由
Ox200b43 加上当前程序计数器的值得到，当前程序计数器的值即为下一条将要执行指令
的地址。如果取出这个序列的最后4个字节：43 Ob 20 00，并且按照相反的顺序写出，我
们得到 00 20 0b 43。去掉开头的0，得到值 0x200b43，这就是右边的数值。当阅读像此
类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序
列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高
有效位在左边，最低有效位在右边的方式相反。
字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在C语言
中，可以通过使用强制类型转换(cast)或联合(union)来允许以一种数据类型引用一个对
象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推
荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。
图2-4 展示了一段C代码，它使用强制类型转换来访问和打印不同程序对象的字节表
示。我们用 typedef 将数据类型 byte_pointer 定义为一个指向类型为“unsigned


Page 67
第2章 信息的表示和处理
31
char”的对象的指针。这样一个字节指针引用一个字节序列，其中每个字节都被认为是一
个非负整数。第一个例程 show_bytes 的输入是一个字节序列的地址，它用一个字节指针
以及一个字节数来指示。该字节数指定为数据类型 size_t，表示数据结构大小的首选数
据类型。show_bytes 打印出每个以十六进制表示的字节。C格式化指令“8。2x”表明整
数必须用至少两个数字的十六进制格式输出。
1
#include <stdio。h>
2
3
typedef unsigned char *byte_pointer；
4
5
void show_bytes (byte_pointer start， size_t len) {
size_t i；
for (i = 0； i < len； i++)
printf (" %。2x"， start[i])；
printf("\n")；
}
7
8
10
11
12
void show_int(int x) {
show_bytes ( (byte_pointer) &x， sizeof(int))；
}
13
14
15
16
void show_float(float x) {
show_bytes ((byte_pointer) &x， sizeof (float))；
}
17
18
19
void show pointer (void *x) {
show_bytes((byte_pointer) &x， sizeof (void *))；
20
21
22
图 2-4
打印程序对象的字节表示。这段代码使用强制类型转换来规避类型系统。
很容易定义针对其他数据类型的类似函数
过程 show_int、show_float 和 show_pointer 展示了如何使用程序 show_bytes 来
分别输出类型为 int、float 和 void *
传递给 show_bytes 一个指向它们参数x的指针 &x，且这个指针被强制类型转换为“un -
signed char * ”。这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字
节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最
的C程序对象的字节表示。可以观察到它们仅仅
低字节地址。
这些过程使用C语言的运算符sizeof 来确定对象使用的字节数。一般来说，表达式
sizeof (T)返回存储一个类型为T的对象所需要的字节数。使用 sizeof 而不是一个固定
的值，是向编写在不同机器类型上可移植的代码迈进了一步。
在几种不同的机器上运行如图2-5 所示的代码，得到如图 2-6 所示的结果。我们使用
了以下几种机器：
Linux 32：运行 Linux 的Intel IA32 处理器。
Windows：运行 Windows 的 Intel IA32 处理器。
Sun：运行 Solaris 的Sun Microsystems SPARC 处理器。(这些机器现在由 Oracle 生产。)
Linux 64：运行 Linux 的Intel x86-64 处理器。


Page 68
32
第一部分 程序结构和执行
code/data/show-bytes。c
1
void test_show_bytes(int val) {
int ival =
val；
3
float fval =
(float) ival；
int *pval
show_int(ival)；
show_float(fval)；
4
= &ival；
5
show_pointer (pval)；
}
7
8
code/data/show-bytes。c
图2-5 字节表示的示例。这段代码打印示例数据对象的字节表示
机器
值
类型
字节(十六进制)
Linux 32
12 345
int
39 30 00 00
Windows
12 345
int
39 30 00 00
Sun
12 345
int
00 00 30 39
Linux 64
12 345
int
39 30 00 00
00 e4 40 46
00 e4 40 46
Linux 32
12 345。0
float
Windows
12 345。0
float
Sun
12 345。0
float
46 40 e4 00
Linux 64
12 345。0
float
00 e4 40 46
Linux 32
&ival
int *
e4 f9 ff bf
Windows
&ival
int *
b4 cc 22 00
Sun
&ival
int *
ef ff fa 0c
Linux 64
&ival
int *
b8 11 e5 ffff 7f 00 00
图 2-6
不同数据值的字节表示。除了字节顺序以外，int 和 float 的结果是一样的。指针值与机器相关
参数12 345 的十六进制表示为 Ox00003039。对于 int 类型的数据，除了字节顺序以
外，我们在所有机器上都得到相同的结果。特别地，我们可以看到在 Linux 32、Windows
和Linux 64 上，最低有效字节值 0x39 最先输出，这说明它们是小端法机器；而在 Sun 上
最后输出，这说明 Sun 是大端法机器。同样地，float 数据的字节，除了字节顺序以外，
也都是相同的。另一方面，指针值却是完全不同的。不同的机器/操作系统配置使用不同
的存储分配规则。一个值得注意的特性是Linux 32、Windows 和 Sun 的机器使用4字节
地址，而Linux 64 使用8字节地址。
给C语言初学者 使用typedef 来命名数据类型
C语言中的typedef 声明提供了一种给数据类型命名的方式。这能够极大地改善代
码的可读性，因为深度嵌套的类型声明很难读懂。
typedef 的语法与声明变量的语法十分相像，除了它使用的是类型名，而不是变量
因此，图2-4 中 byte_pointer的声明和将一个变量声明为类型“unsigned char
有相同的形式。
例如，声明：
名
* リ
typedef int *int_pointer；
int pointer ip；
为一个挂
声明了一个这种类型的
“int_pointer
变量ip。我们还可以将这个变量直接声明为：
将类
int 的指针，
int *ip；


Page 69
第2章 信息的表示和处理
33
给C语言初学者使用printf 格式化输出
printf 函数(还有它的同类 fprintf 和sprintf)提供了一种打印信息的方式，这
种方式对格式化细节有相当大的控制能力。第一个参教是格式串(format string)，而其
余的参数都是要打印的值。在格式串里，每个以“g”开始的字符序列都表示如何格式
化下一个参数。典型的示例包括：‘8d’是输出一个十进制整数，“sf'是输出一个浮点
数，而‘c”是输出一个字符，其編码由参数给出。
指定确定大小数据类型的格式，如 int32_t，要更复杂一些，相关內容参见 2。2。3
节的旁注。
可以观察到，尽管浮点型和整型数据都是对数值 12 345 编码，但是它们有截然不同的
字节模式：整型为 Ox00003039，而浮点数为 0X4640E400。一般而言，这两种格式使用不
同的编码方法。如果我们将这些十六进制模式扩展为二进制形式，并且适当地将它们移
位，就会发现一个有 13 个相匹配的位的序列，用一串星号标识出来：
0 0 0 0 3 0 3 9
00000000000000000011000000111001
*************
4 6
4 0 E 4 0 0
01000110010000001110010000000000
这并不是巧合。当我们研究浮点数格式时，还将再回到这个例子。
给C语言初学者 指针和数组
在函数 show_bytes(图2-4)中，我们看到指针和教组之间紧密的联系，这将在3。8 节
中详细描述。这个函数有一个类型为 byte_pointer(被定义为一个指向 unsigned char 的
指针)的参数 start，但是我们在第8行上看到教组引用 start [i]。在C语言中，我们能
够用数组表示法来引用指针，同时我们也能用指针表示法来引用数组元素。在这个例子
中，引用 start [i]表示我们想要读取以 start 指向的位置为起始的第i个位置处的字节。
给C语言初学者 指针的创建和间接引用
在图2-4 的第13、17 和21行，我们看到对C和C++ 中两种独有操作的使用。C的
“取地址”运算符&创建一个指针。在这三行中，表达式 &x 创建了一个指向保存变量x的
位置的指针。这个指针的类型取决于x的类型型，因此这三个指针的类型分别为 int *、
float*和void **。(数据类型型 void *是一种特殊类型的指针，没有相关联的类型型信息。
强制类型转换运算符可以将一种数据类型转换为另一种。因此，强制类型型转换
(byte_pointer) &x 表明无论指针 &x 以前是什么类型，它现在就是一个指向数据类型
为 unsigned char 的指针。这里给出的这些强制类型转换不会改变真实的指针，它们
只是告诉编译器以新的数据类型型来看待被指向的数据。
旁注 生成一张 ASCII 表
可以通过执行命令 man ascii 来得到一张 ASCII 字符码的表。
练习题2。5
思考下面对 show_bytes 的三次调用：
int val = Ox87654321；
byte_pointer valp =
(byte_pointer) &val；


Page 70
34
第一部分 程序结构和执行
show_bytes(valp， 1)； /* A。 */
show_bytes (valp， 2)； /* B。 */
show_bytes (valp， 3)； /* C。 */
指出在小端法机器和大端法机器上，每次调用的输出值。
A。 小端法：
B。 小端法：
C。 小端法：
练习题2。6 使用 show int 和 show float，我们确定整数 3510593 的十六进制表示
为 Ox00359141，而浮点数 3510593。0 的十六进制表示为 Ox4A564504。
A。 写出这两个十六进制值的二进制表示。
B。移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢?
C。 串中的什么部分不相匹配?
大端法：
大端法：
大端法：
2。1。4 表示字符串
C语言中字符申被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都由
某个标准编码来表示，最常见的是 ASCII 字符码。因此，如果我们以参数“12345”和6
(包括终止符)来运行例程 show_bytes，我们得到结果 31 32 33 34 35 00。请注意，十进
制数字 x的ASCII 码正好是 0x3x，而终止字节的十六进制表示为 0x00。在使用 ASCII 码
作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文
本数据比二进制数据具有更强的平台独立性。
练习题2。7下面对 show_bytes 的调用将输出什么结果?
const char *s = "abcdef"；
show_bytes( (byte_pointer) s， strlen(s))；
注意字母‘a”
z’的 ASCII 码为 Ox61~ Ox7A。
~
旁注 文字编码的 Unicode标准
ASCII 字符集适合于编码英语文档，但是在表达一些特殊字符方面并没有太多办法，
例如法语的“C”。它完全不适合编码希腊语、俄语和中文等语言的文档。这些年，提出了
很多方法来对不同语言的文字进行编码。Unicode联合会(Unicode Consortium)修订了最全
面且广泛接受的文字编码标准。当前的 Unicode 标准(7。0 版)的字库包括将近 100 000个字
符，支持广泛的语言种类，包括古埃及和巴比伦的语言。为了保持信用， Unicode技术委
员会否决了为KIlingon(即电视连续剧《星际迷航》中的虛构文明)编写语言标准的提议。
基本编码，称为 Unicode 的“统一字符集”，使用32位来表示字符。这好像要求文
本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个
或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符
编码为一个字节序列，这样标准 ASCII 字符还是使用和它们在 ASCII 中一样的单字节
编码，这也就意味着所有的ASCII 字节序列用ASCII 码表示和用 UTF-8表示是一样的。
Java 编程语言使用 Unicode来表示字符串。对于C语言也有支持 Unicode 的程序库。
2。1。5 表示代码
考虑下面的C函数：


Page 71
第2章 信息的表示和处理
35
1
int sum (int x， int y) {
2
return x + y；
3
}
当我们在示例机器上编译时，生成如下字节表示的机器代码：
Linux 32
Windows
55 89 e5 8b 45 Oc 03 45 08 c9 c3
55 89 e5 8b 45 Oc 03 45 08 5d c3
Sun
81 c3 e0 08 90 02 00 09
Linux 64
55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方
式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进
制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。
计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器
没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。在第3章学
习机器级编程时，我们将更清楚地看到这一点。
2。1。6 布尔代数简介
二进制值是计算机编码、存储和操作信息的核心，所以围绕数值 0和1的研究已经演化
出了丰富的数学知识体系。这起源于 1850 年前后乔治，布尔(George Boole， 1815-1864)的
工作，因此也称为布尔代数(Boolean algebra)。布尔注意到通过将逻辑值 TRUE(真)和
FALSE(假)编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。
最简单的布尔代数是在二元集合{0，1}
基础上的定义。图 2-7 定义了这种布尔代数
中的几种运算。我们用来表示这些运算的符
号与C语言位级运算使用的符号是相匹配
的，这些将在后面讨论到。布尔运算~对应
于逻辑运算 NOT，在命题逻辑中用符号-
表示。也就是说，当P不是真的时候，我
们就说一P是真的，反之亦然。相应地，当P等于0时，~P等于1，反之亦然。布尔运算
&对应于逻辑运算 AND，在命题逻辑中用符号A表示。当P和Q都为真时，我们说PA
Q为真。相应地，只有当 p=1且q=1时，p8。g 才等于 1。布尔运算|对应于逻辑运算
OR，在命题逻辑中用符号V表示。当P或者Q为真时，我们说PVQ成立。相应地，当
p=1或者 q=1时，lg 等于1。布尔运算~对应于逻辑运算异或，在命题逻辑中用符号田
表示。当P或者Q为真但不同时为真时，我们说 POQ成立。相应地，当p=1且 q=0，
或者p=0且g=1时，p^q 等于1。
后来创立信息论领域的Claude Shannon(1916-2001)首先建立了布尔代数和数字逻辑
之间的联系。他在 1937 年的硕士论文中表明了布尔代数可以用来设计和分析机电继电器
网络。尽管那时计算机技术已经取得了相当的发展，但是布尔代数仍然在数字系统的设计
和分析中扮演着重要的角色。
我们可以将上述4个布尔运算扩展到位向量的运算，位向量就是固定长度为 w、由0
和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假设a和り分
别表示位向量[aw-1， au-2，
长度为w的位向量，其中第；个元素等于 a，&b，， 0<i<w。可以用类似的方式将运算|、^
& 0
0 0
0 1
0 1
0 0 1
1 0
1
1
0| 0
1
1
1
1|1 1
1
图2-7 布尔代数的运算。二进制值1和0表示
逻辑值 TRUE或者 FALSE，而运算符
~、&、1和~分别表示逻辑运算 NOT、
AND， OR FA EXCLUSIVE-OR
， Qo]和[bu-1， bu-2，…，bo]。我们将 a&b 也定义为一个
。。。。


Page 72
36
第一部分 程序结构和执行
和~扩展到位向量上。
举个例子，假设 w=4，参数a=[0110]，6=[1100]。那么4种运算 a&b、alb、a^b
和~b分别得到以下结果：
0110
0110
0110
& 1100
| 1100
1100
1100
0100
1110
1010
0011
练习题2。8 填写下表，给出位向量的布尔运算的求值结果。
运算
结果
[01101001]
[01010101]
a
a & b
a | b
a^b
网络旁注DATA： BOOL
关于布尔代数和布尔环的更多内容
对于任意整数 wVo，长度为 w的位向量上的布尔运算1、&和~形成了一个布尔
代数。最简单的情况是 w=1时，只有2个元素；但是对于更普遍的情况，有2”个长度
为w的位向量。布尔代数和整数算术运算有很多相似之处。例如，乘法对加法的分配
律，写为a。(b+c) = (a。b)+(a。 c)，而布尔运算 & 对|的分配律，写为a&(b|c) =
(a&b)| (a&c)。此外，布尔运算|对&也有分配律，写为 a| (b&c)= (a|b) & (alc)，
但是对于整数我们不能说a+(6。c)= (a+b)。(atc)。
当考虑长度为w的位向量上的~、& 和~运算时，会得到一种不同的数学形式，我
们称为布尔环(Boolean ring)。布尔环与整数运算有很多相同的属性。例如，整数运算
的一个属性是每个值z都有一个加法逆元(additive inverse)一，使得x+(一) =D0。布
尔环也有类似的属性，这里的“加法”运算是，不过这时每个元素的加法逆元是它自
己本身。也就是说，对于任何值a 来说，a^a==0，这里我们用0来表示全 0 的位向量。
可以看到对单个位来说这是成立的，即0~0=1^1=D0，将这个扩展到位向量也是成立
的。当我们重新排列组合顺序，这个属性也仍然成立，因此有(a ^b)^ a=b。这个属性会
引起一些很有趣的结果和聪明的技巧，在练习题 2。10 中我们会有所探讨。
位向量一个很有用的应用就是表示有限集合。我们可以用位向量[aw-1，…，aj， Qo
编码任何子集 AS{0， 1，…，w-1}，其中 a，=1当且仅当；EA。例如(记住我们是把
aw-1写在左边，而将 a。写在右边)，位向量 a=[01101001]表示集合 A= {0，3，5，6}，
而b-[01010101]表示集合 B= {0，2，4，6》。使用这种编码集合的方法，布尔运算|和
&分别对应于集合的并和交，而~对应于于集合的补。还是用前面那个例子，运算 a&b
得到位向量[01000001]，而ANB={0，6}。
在大量实际应用中，我们都能看到用位向量来对集合编码。例如，在第8章，我们会
看到有很多不同的信号会中断程序执行。我们能够通过指定一个位向量掩码，有选择地使
能或是屏蔽一些信号，其中某一位位置上为1时，表明信号i是有效的(使能)，而0表明
该信号是被屏蔽的。因而，这个掩码表示的就是设置为有效信号的集合。


Page 73
第2章 信息的表示和处理
37
练习题2。9 通过混合三种不同颜色的光(红色、绿色和蓝色)，计算机可以在视频屏
幕或者液晶显示器上产生彩色的画面。设想一种简单的方法，使用三种不同颜色的
光，每种光都能打开或关闭，投射到玻璃屏幕上，如图所示：
光源
玻璃屏幕
红
观察者
绿
蓝
那么基于光源R(红)、G(绿)、B(蓝)的关闭(0)或打开(1)，我们就能够创建8
种不同的颜色：
G
颜色
R
颜色
黑色
1
红色
1
蓝色
1
1
红紫色
1
绿色
1
黄色
1
1
蓝绿色
1
1
1
白色
这些颜色中的每一种都能用一个长度为3的位向量来表示，我们可以对它们进行布尔运算。
A。 一种颜色的补是通过关掉打开的光源，且打开关闭的光源而形成的。那么上面列
出的8种颜色每一种的补是什么?
B。描述下列颜色应用布尔运算的结果：
蓝色
一
绿色
黄色
&。
蓝绿色
红色
红紫色
2。1。7 C语言中的位级运算
C语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使
用的那些符号就是C语言所使用的：「就是 OR(或)，&就是AND(与)，~就是 NOT(取
反)，而“就是EXCLUSIVE-OR(异或)。这些运算能运用到任何“整型”的数据类型上，
包括图 2-3 所示内容。以下是一些对 char 数据类型表达式求值的例子：
C的表达式
二进制表达式
二进制结果
十六进制结果
-0x41
- [0100 0001]
[1011 1110]
OXBE
-0x00
- [0000 0000]
[1111 1111]
OXFF
0x69&0x55
[0110 1001]&[0101 0101]
[0100 0001]
0x41
Ox69|0x55
[0110 1001]| [0101 0101]
[0111 1101]
0×7D
正如示例说明的那样，确定一个位级表达式的结果最好的方法，就是将十六进制的参
数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。


Page 74
38
第一部分 程序序结构和执行
练习题 2。10 对于任一位向量a，有a^a=0。应用这一属性，考虑下面的程序：
void inplace_swap(int *x， int *y) {
/* Step 1 */
/* Step 2 */
/* Step 3 */
1
*y
= *x *
*у；
3
*x = *x
*у；
4
*y = *x
*y；
5
}
正如程序名字所暗示的那样，我们认为这个过程的效果是交換指针变量 x和y所指向
的存储位置处存放的值。注意，与通常的交换两个数值的技术不一样，当移动一个值
时，我们不需要第三个位置来临时存储另一个值。这种交换方式并没有性能上的优
势，它仅仅是一个智力游戏。
以指针x和y指向的位置存储的值分别是a和b作为开始，填写下表，给出在程序的
每一步之后，存储在这两个位置中的值。利用~的属性证明达到了所希望的效果。回
想一下，每个元素就是它自身的加法逆元(a^a=0)。
步骤
*x
*y
初始
b
a
第1步
第2步
第3步
练习题2。11 在练习题 2。 10 中的 inplace_swap 函数的基础上，你决定写一段代码，
实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：
void reverse_array(int a[]， int cnt) {
int first， last；
1
3
for (first = 0， last = cnt-1；
4
first <= 1ast；
5
first++，last--)
inplace_swap (&a[first]， &a [last])；
7
}
当你对一个包含元素1、2、3和4的数组使用这个函数时，正如预期的那样，现在数
组的元素变成了 4、3、2和1。不过，当你对一个包含元素1、2、3、4和5的数组使
用这个函数时，你会很惊奇地看到得到数字的元素为5、4、0、2和1。实际上，你会
发现这段代码对所有偶数长度的数组都能正确地工作，但是当数组的长度为奇数时，
它就会把中间的元素设置成 0。
A。对于一个长度为奇数的数组，长度 cnt=2k+1，函数 reverse_array 最后一次
循环中，变量first 和last 的值分别是什么?
B。为什么这时调用函数 inplace_swap 会将数组元素设置为0?
C。 对 reverse_array 的代码做哪些简单改动就能消除这个问题?
位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字
中选出的位的集合。让我们来看一个例子，掩码 OXFF(最低的8位为 1)表示一个字的低位
字节。位级运算 x&0XFF 生成一个由x的最低有效字节组成的值，而其他的字节就被置为
0。比如，对于 x= OX89ABCDEF，其表达式将得到 OX000000EF。表达式~0将生成一个全
1的掩码，不管机器的字大小是多少。尽管对于一个 32 位机器来说，同样的掩码可以写成
OXFFFFFFFF，但是这样的代码不是可移植的。


Page 75
第2章 信息的表示和处理
39
练习题2。12 对于下面的值，写出变量 的C语言表达式。你的代码应该对任何字
长 w>8 都能工作。我们给出了当 x=0x87654321 以及 w=32时表达式求值的结果，
仅供参考。
A。 x 的最低有效字节，其他位均置为0。[0x00000021]。
B。除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变。 [OX789ABC21]。
C。 x的最低有效字节设置成全1，其他字节都保持不变。[0X876543FF]。
练习题2。13 从 20 世纪 70 年代末到 80 年代末，Digital Equipment 的 VAX 计算机
是一种非常流行的机型。它没有布尔运算 AND 和 OR 指令，只有 bis(位设置)和
bic(位清除)这两种指令。两种指令的输入都是一个数据字x和一个掩码字 m。它们
生成一个结果 z，z是由根据掩码m的位来修改x的位得到的。使用 bis 指令，这种
修改就是在m为1的每个位置上，将z对应的位设置为1。使用 bic 指令，这种修改
就是在m为1的每个位置，将 z对应的位设置为0。
为了看清楚这些运算与C语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实
现位设置和位清除操作。只想用这两个函数，而不使用任何其他C语言运算，来实现按
位|和~运算。填写下列代码中缺失的代码。提示：写出 bis 和bic运算的C语言表达式。
/* Declarations of functions implementing operations bis and bic */
int bis (int x， int m)；
int bic(int x， int m)；
/* Compute xly using only calls to functions bis and bic */
int bool_or (int x， int y) {
int result =
return result；
}
/* Compute x^y using only calls to functions bis and bic */
int bool_xor(int x， int y) {
int result
return result；
2。1。8 C语言中的逻辑运算
C语言还提供了一组逻辑运算符||、&。& 和!，分别对应于命题逻辑中的OR、AND
和 NOT 运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑
运算认为所有非零的参数都表示TRUE，而参数 0 表示 FALSE。它们返回1或者 0，分别
表示结果为TRUE 或者为FALSE。以下是一些表达式求值的示例。
表达式
结果
!0x41
0x00
!0x00
0x01
!!0x41
0x01
0x69&&0x55
0x01
0×69||0x55
0x01
可以观察到，按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与


Page 76
40
第一部分 程序结构和执行
其对应的逻辑运算有相同的行为。
逻辑运算符 &。&。和||与它们对应的位级运算 & 和|之间第二个重要的区别是，如果对
第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，
例如，表达式a&&5/a将不会造成被零除，而表达式 p&&tp++也不会导致间接引用空指针。
练习题2。14 假设x和y的字节值分别为 Ox66 和 Ox39。填写下表，指明各个C表达
式的字节值。
表达式
值
表达式
值
x & y
x && y
x y
x || y
~x | ~y
!x || !y
x & !y
x && ~y
练习题2。15
只使用位级和逻辑运算，编写一个 C表达式，它等价于 x==y。换句话
说，当x和y相等时它将返回1，否则就返回0。
2。1。9 C语言中的移位运算
C语言还提供了一一组移位运算，向左或者向右移动位模式。对于一个位表示为[xw-1，
Tu-2，…，To]的操作数 z，C表达式 x<<k 会生成一个值，其位表示为[x一kー1，a-kー2，…，
0]。也就是说，x向左移动k位，丟弃最高的k位，并在右端补た个 0。移位
量应该是一个 0~w-1之间的值。移位运算是从左至右可结合的，所以 x<<j<<k 等价于
Xo ， 0， …，
(x<<j)<<k。
有一个相应的右移运算 x>>k，但是它的行为有点微妙。一般而言，机器支持两种形
式的右移：逻辑右移和算术右移。逻辑右移在左端补ょ个0，得到的结果是[0，
z]。算术右移是在左端补た个最高有效位的值，得到的结果是[x-1，
エ]。这种做法看上去可能有点奇特，但是我们会发现它对有符
***， 0。
Xw-1， Xrw-2 ， ***，
。。。。
Xw-1 ， Xw-1， Xw-2 ， **，
号整数数据的运算非常有用。
让我们来看一个例子，下面的表给出了对一个8位参数 x的两个不同的值做不同的移
位操作得到的结果：
操作
值
参数x
[01100011] [10010101]
x << 4
[00110000] [01010000]
x >> 4 (逻辑右移)
[00000110] [00001001]
x >> 4 (算术右移)
[00000110] [11111001]
斜体的数字表示的是最右端(左移)或最左端(右移)填充的值。可以看到除了一个条目
之外，其他的都包含填充 0。唯一的例外是算术右移[10010101]的情况。因为操作数的最
高位是1，填充的值就是1。
C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移一算术右移或者逻辑
右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移
植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多


Page 77
第2章 信息的表示和处理
41
程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。
与C相比，Java对于如何进行右移有明确的定义。表达是 x>>k 会将 x 算术右移k个
位置，而 x>>>k 会对 x做逻辑右移。
旁注注 移动k位，这里k很大
对于一个由w位组成的数据类型，如果要移动k>w 位会得到什么结果呢?例如，
计算下面的表达式会得到什么结果，假设数据类型 int 为w=32：
int
lval = 0XFEDCBA98
<< 32；
int
aval = 0XFEDCBA98
>> 36；
>> unsigned uval = 0XFEDCBA98U >> 40；
>> C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个
>> w位的值时，移位指令只考虑位移量的低log， w位，因此实际上位移量就是通过计算k mod
>> w得到的。例如，当 w=32 时，上面三个移位运算分别是移动0、4和8位，得到结果：
>> lval
>> OXFEDCBA98
>> aval
>> OXFFEDCBA9
>> uval
>> OX00FEDCBA
>> 不过这种行为对于C程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。
>> 另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。
>> 旁注 与移位运算有关的操作符优先级问题
>> 常常有人会写这样的表达式 1<<2+3<<4，本意是(1<<2) + (3<<4)。但是在C语言中，
>> 前面的表达式等价于 1<< (2+3) <<4，这是由于加法(和减法) 的优先级比移位运算要高。
>> 然后，按照从左至右结合性规则，括号应该是这样打的(1<< (2+3))<<4，得到的结果是
>> 512，而不是期望的52。
>> 在C表达式中搞错优先级是一种常见的程序错误原因，而且常常很难检查出来。所
>> 以当你拿不准的时候，请加上括号!
>> 练习题2。16 填写下表，展示不同移位运算对单字节数的影响。思考移位运算的最
>> 好方式是使用二进制表示。将最初的值转换为二进制，执行移位运算，然后再转换回
>> 十六进制。每个答案都应该是8个二进制数字或者2个十六进制数字。
>> x>>2(逻辑的)
>> 十六进制
>> x<<3
>> x>>2(算术的)
>> 十六进制
>> 二进制
>> 二进制
>> 十六进制
>> 二进制
>> 二进制
>> 十六进制
>> 0xC3
>> 0x75
>> 0x87
>> 0x66
>> 2。2 整数表示
>> 在本节中，我们描述用位来编码整数的两种不同的方式：一种只能表示非负数，而另
>> 一种能够表示负数、零和正数。后面我们将会看到它们在数学属性和机器级实现方面密切
>> 相关。我们还会研究扩展或者收缩一个已编码整数以适应不同长度表示的效果。
>> 图2-8 列出了我们引人的数学术语，用于精确定义和描述计算机如何编码和操作整
>> 数。这些术语将在描述的过程中介绍，图在此处列出作为参考。


Page 78
42
第一部分 程序序结构和执行
符号
类型
含义
B2T。
函数
二进制转补码
B2U
函数
二进制转无符号数
U2B_
函数
无符号数转二进制
U2T。
函数
无符号转补码
T2B
函数
补码转二进制
T2U，
函数
补码转无符号数
TMin
常数
最小补码值
ТМах，
常数
最大补码值
UMax
常数
最大无符号数
操作
补码加法
+。
操作
无符号数加法
操作
补码乘法
操作
无符号数乘法
操作
补码取反
操作
无符号数取反
图2-8 整数的数据与算术操作术语。下标 w表示数据表示中的位数
2。2。1 整型数据类型
C语言支持多种整型数据类型一表示有限范围的整数。这些类型如图 2-9 和图2-10
所示，其中还给出了“典型”32位和 64 位机器的取值范围。每种类型都能用关键字来指
定大小，这些关键字包括 char、short、long，同时还可以指示被表示的数字是非负数
(声明为 unsigned)，或者可能是负数(默认)。如图 2-3 所示，为这些不同的大小分配的
字节数根据程序编译为 32 位还是 64 位而有所不同。根据字节分配，不同的大小所能表示
的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符 long
的。大多数64 位机器使用8个字节的表示，比32 位机器上使用的4个字节的表示的取值
范围大很多。
C数据类型
最小值
最大值
(signed]char
-128
127
unsigned char
255
short
-32 768
32 767
unsigned short
65 535
int
-2 147 483 648
2 147 483 647
unsigned
4 294 967 295
long
-2 147 483 648
2 147 483 647
unsigned long
4 294 967 295
int32_t
-2 147 483 648
2 147 483 647
uint32_t
4 294 967 295
int64_t
-9 223 372 036 854 775 808
9 223 372 036 854 775 807
uint64_t
18 446 744 073 709 551 615
图 2-9
32 位程序上C语言整型数据类型的典型取值范围


Page 79
第2章 信息的表示和处理
43
C数据类型
最小值
最大值
127
[signed]char
unsigned char
-128
255
short
-32 768
32 767
unsigned short
65 535
int
-2 147 483 648
2 147 483 647
unsigned
4 294 967 295
long
-9 223 372 036 854 775 808
9 223 372 036 854 775 807
unsigned long
18 446 744 073 709 551 615
int32_t
-2 147 483 648
2 147 483 647
uint32_t
4 294 967 295
int64_t
-9 223 372 036 854 775 808
9 223 372 036 854 775 807
uint64_t
18 446 744 073 709 551 615
图 2-10
64 位程序上C语言整型数据类型的典型取值范围
图 2-9 和图2-10 中一个很值得注意的特点是取值范围不是对称的一负数的范围比整
数的范围大1。当我们考虑如何表示负数的时候，会看到为什么会这样。
C语言标准定义了每种数据类型必须能够表示的最小的取值范围。如图 2-11 所示，它
们的取值范围与图 2-9 和图 2-10 所示的典型实现一样或者小一些。特别地，除了固定大小
的数据类型是例外，我们看到它们只要求正数和负数的取值范围是对称的。此外，数据类
型 int 可以用2个字节的数字来实现，而这几乎回退到了 16 位机器的时代。还可以看到，
long 的大小可以用4个字节的数字来实现，对32 位程序来说这是很典型的。固定大小的数
据类型保证数值的范围与图2-9 给出的典型数值一致，包括负数与正数的不对称性。
C数据类型
最小值
最大值
[signed] char
unsigned char
-127
127
255
short
-32 767
32 767
unsigned short
65 535
int
-32 767
32 767
unsigned
65 535
long
-2 147 483 647
2 147 483 647
unsigned long
4 294 967 295
int32_t
-2 147 483 648
2 147 483 647
uint32_t
4 294 967 295
int64_t
-9 223 372 036 854 775 808
9 223 372 036 854 775 807
uint64_t
18 446 744 073 709 551 615
C语言的整型数据类型的保证的取值范围。C语言标准要求
这些数据类型必须至少具有这样的取值范围
图 2-11
给C语言初学者
C和C++ 都支持有符号(默认)和无符号数。Java 只支持有符号教。
C、C++ 和Java 中的有符号和无符号数
2. 2. 2
假设有一个整数数据类型有 w位。我们可以将位向量写成立，表示整个向量，或者写
成[zwー1， Iu-2，…，Io]，表示向量中的每一位。把之看做一个二进制表示的数，就获得


Page 80
44
第一部分 程序结构和执行
了之的无符号表示。在这个编码中，每个位 x，都取值为0或1，后一种取值意味着数值 2' 应
为数字值的一部分。我们用一个函数 B2U。。(Binary to Unsigned 的缩写，长度为 w)来表示：
原理：无符号数编码的定义
对向量文=[Iu-1， Iu-2，
***， x]：
TE一1
B2U(云)=
(2。 1)
2=0
在这个等式中，符号“一”表示左边被定义为等于右边。函数 B2Uw将一个长度为w的
0、1串映射到非负整数。举一个示例，图 2-11 展示的是下面几种情况下 B2U给出的从位
向量到整数的映射：
B2U， ([0001]) = 0 • 2³ + 0 • 2² +0• 2' + 1• 2° = 0+0+0+1=1
B2U， ([0101]) = 0 • 2³ +1 • 2² +0 • 2' +1•2° = 0+4+0+1= 5
B2U， ([1011]) = 1• 2° +0 • 2² +1• 2' +1• 2° = 8+0+2+1= 11
B2U， ([1111]) = 1 • 2° +1• 2² +1• 2' +1• 2° = 8+4+2+1 = 15
在图中，我们用长度为2： 的指向右侧箭头的条表示每个位的位置i。每个位向量对应
(2。 2)
的数值就等于所有值为1的位对应的条
23 = 8
的长度之和。
22 = 4
让我们来考虑一下 w 位所能表示
的值的范围。最小值是用位向量[00…
0]表示，也就是整数值 0，而最大值是
用位向量[11…1]表示，也就是整数值
2 =2
2° = 1
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
十 +
+
++++
tu一1
[0001]
UMar wニ》2 = 2"-1。以4 位情况
[0101]
i=0
为例，UMax，= B2U，([1111]) = 2' - [1011]
1=15。因此，函数 B2Uw能够被定义 [1111]
为一个映射B2U。w：{0，1}*→{0，…，
2" –1}。
无符号数的二进制表示有一个很重要的属性，也就是每个介于 0~2*-1之间的数都
有唯一一个 w位的值编码。例如，十进制值11 作为无符号数，只有一个4位的表示，即
[1011]。我们用数学原理来重点讲述它，先表述原理再解释。
原理：无符号数编码的唯一性
函数 B2U。是一个双射。
数学术语双射是指一个函数了有两面：它将数值 x 映射为数值 y，即 y=f(x)，但它
也可以反向操作，因为对每一个y而言，都有唯一一个数值 z 使得 f(z) =y。这可以用反
函数f'来表示，在本例中，即x=f'(y)。函数 B2U。将每一个长度为w 的位向量都映
射为0~2"-1之间的一个唯一值；反过来，我们称其为U2B。(即“无符号数到二进制”)，
在0~2*-1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。
图 2-12 w=4的无符号数示例。当二进制表示
中位i为1，数值就会相应加上 2
2。2。3 补码编码
对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补
码(two’s-complement)形式。在这个定义中，将字的最高有效位解释为负权(negative
weight)。我们用函数 B2T。(Binary to Two's-complement 的缩写，长度为 w)来表示：


Page 81
第2章 信息的表示和处理
45
原理：补码编码的定义
对向量=[Iw-1， Tw-2， …，To」：
w-2
B2T(元)=一Tu-l?
(2。 3)
i=0
最高有效位 xw-1」也称为符号位，它的“权重”为-2"-1，是无符号表示中权重的负
数。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。这里来看一个示
例，图2-13 展示的是下面几种情况下 B2T 给出的从位向量到整数的映射。
B2T， ([0001]) =-0• 23 +0 • 2² +0• 2' +1 • 2°
0+0+0+1 =
1
B2T， ([0101])
=-0• 23 +1• 2? +0• 2' +1• 2°
0+4+0+1 =
5
(2。 4)
B2T， ([1011])
=-1• 23 +0• 2² +1• 2' +1• 2° =- 8+0+2+1=-5
B2T， ([1111]) =-1•2³ +1• 2? +1• 2' +1•2° =- 8+4+2+1=-1
在这个图中，我们用向左指的条表
示符号位具有负权重。于是，与一个位
向量相关联的数值是由可能的向左指的
条和向右指的条加起来决定的。
我们可以看到，图 2-12 和图 2-13
中的位模式都是一样的，对等式(2。2)
和等式(2。4)来说也是一样，但是当最 [0001]
高有效位是1时，数值是不同的，这是 [0101]
因为在一种情况中，最高有效位的权重 [1011]
是+8，而在另一种情况中，它的权重
-23 =
= -8
22 = 4
21 = 2
20 = 1
-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8
十
十 +
[1111]
是一8。
让我们来考虑一下 w位补码所能 图2-13
表示的值的范围。它能表示的最小值是
位向量[10…0](也就是设置这个位为负
权，但是清除其他所有的位)，其整数值为TMin，ニ-2w-1。而最大值是位向量 [01…1]
w=4的补码示例。把位3作为符号位，因此当它
为1时，对数值的影响是一23 =-8。这个权重
在图中用带向左箭头的条表示
w-2
(清除具有负权的位，而设置其他所有的位)，其整数值为 TMarw =》2= 21-1。以
i=0
长度为4为例，我们有TMin =B2T， ([1000]) =-23 = -8，而TMaz， = B2T，([0111]) =
22 +2'+2° =4+2+1=7。
我们可以看出B2Tw是一个从长度为w 的位模式到 TMin。和TMaxw 之间数字的映
射，写作 B2T。：{0，1}"→{TMin，…，TMar}。同无符号表示一样，在可表示的取
值范围内的每个数字都有一个唯一的w位的补码编码。这就导出了与无符号数相似的补码
数原理：
原理：补码编码的唯一性
函数 B2T。是一个双射。
我们定义函数T2B，(即“补码到二进制”)作为 B2T。的反函数。也就是说，对于每个
数x，满足TMinw<x<TMarw，则 T2B。(x)是x的(唯一的)w位模式。
练习题2。17 假设 w=4，我们能给每个可能的十六进制数字赋予一个数值，假设用
一个无符号或者补码表示。请根据这些表示，通过写出等式(2。 1)和等式(2。3)所示的
求和公式中的2的非零次幂，填写下表：


Page 82
46
第一部分 程序结构和执行
元
B2U，( x)
B2T，( )
十六进制
二进制
0xE
[1110]
2'+2?+2'=14
-2'+2?+2'=-2
Ох0
0x5
Ox8
0xD
0xF
图2-14 展示了针对不同字长，几个重要数字的位模式和数值。前三个给出的是可表
示的整数的范围，用 UMazw、TMin和TMaz。来表示。在后面的讨论中，我们还会经
常引用到这三个特殊的值。如果可以从上下文中推断出 w，或者 w不是讨论的主要内容
时，我们会省略下标 w，直接引用 UMar、TMin和 TMax。
字长w
数
16
32
64
UMax
ОХFF
0XFFFF
0XFFFFFFFF
0XFFFFFFFFFFFFFFFĘ
255
65 535
4 294 967 295
18 446 744 073 709 551 615
TMin
0x80
0x8000
0x80000000
0x8000000000000000
-128
-32 768
-2 147 483 648
-9 223 372 036 854 775 808
ТМах，
0×7F
0X7FFF
0X7FFFFFFF
0×7FFFFFFFFFFFFFFF
127
32 767
2 147 483 647
9 223 372 036 854 775 807
-1
0XFF
0XFFFF
0XFFFFFFFF
0XFFFFFFFFFFFFFFFF
0x00
0x0000
0x00000000
0x0000000000000000
图2-14 重要的数字。图中给出了数值和十六进制表示
关于这些数字，有几点值得注意。第一，从图 2-9 和图 2-10 可以看到，补码的范围是
不对称的：|TMin|= |TMaz|+1，也就是说，TMin 没有与之对应的正数。正如我们将
会看到的，这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误。之所
以会有这样的不对称性，是因为一半的位模式(符号位设置为1的数)表示负数，而另一半
(符号位设置为0的数)表示非负数。因为0是非负数，也就意味着能表示的整数比负数少
一个。第二，最大的无符号数值刚好比补码的最大值的两倍大一点：UMarw=2TMaxu +
1。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。图2-14 也给出了常
数-1和0的表示。注意-1 和UMax 有同样的位表示一一个全1的串。数值0在两种
表示方式中都是全0的串。
C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这
么做的。程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，那么除
了图2-11 所示的那些范围之外，我们不应该假设任何可表示的数值范围，也不应该假设
有符号数会使用何种特殊的表示方式。另一方面，许多程序的书写都假设用补码来表示有
符号数，并且具有图 2-9 和图 2-10 所示的“典型的”取值范围，这些程序也能够在大量的
机器和编译器上移植。C库中的文件<limits。h>定义了一组常量，来限定编译器运行的
这台机器的不同整型数据类型的取值范围。比如，它定义了常量 INT_MAX、INT_MIN 和
UINT_MAX，它们描述了有符号和无符号整数的范围。对于一个补码的机器，数据类型 int
有w位，这些常量就对应于 TMarw、TMinu和UMarw 的值。


Page 83
第2章 信息的表示和处理
47
旁注关于确定大小的整数类型的更多内容
对于某些程序来说，用某个确定大小的表示来编码数据类型非常重要。例如，当编写程序，
使得机器能够按照一个标准协议在因特网上通信时，让数据类型与协议指定的数据类型兼容是
非常重要的。我们前面看到了，某些C教据类型，特别是 long型，在不同的机器上有不同的取
值范围，而实际上C语言标准只指定了每种数据类型的最小范围，而不是确定的范围。虽然我
们可以选择与大多数机器上的标准表示兼容的数据类型，但是这也不能保证可移植性。
我们已经见过了 32 位和 64 位版本的确定大小的整数类型(图2-3)，它们是一个更
大数据类型类的一部分。ISO C99 标准在文件 stdint 。h 中引入了这个整数类型类。这
个文件定义了一组数据类型，它们的声明形如intN_t 和uintN_t，对不同的N值指定
N位有符号和无符号整数。N的具体值与实现相关关，但是大多数编译器允许的值为 8、
16、32 和64。因此，通过将它的类型声明为 uint16_t，我们可以无歧义地声明一个 16
位无符号变量，而如果声明为int 32_t，就是一个 32 位有符号变量。
这些数据类型对应着一组宏，定义了每个N的值对应的最小和最大值。这些宏名字
形如 INTN MIN、INTN MAX 和 UINTN MAX。
确定宽度类型的带格式打印需要使用宏，以与系统相关的方式扩展为格式串。
此，举个例子来说，变量 x和y的类型是 int32_t 和 uint64_t，可以通过调用printf
来打印它们的值，如下所示：
因
printf("x
%" PRID32 "， y = %" PRI164 "\n"， x， y)；
%3D
编译为 64 位程序时，宏 PRId32 展开成字符串“d”，宏 PRIU64 则展开成两个字符串
“1”“u”。当C预处理器遇到仅用空格(或其他空白字符)分隔的一个字符串常量序列时，
就把它们串联起来。因此，上面的 printf 调用就变成了：
printf("x = %d， y = %lu\n"， x， y)；
使用宏能保证：不论代码是如何被编译的，都能生成正确的格式字符串。
‘关于整数数据类型的取值范围和表示，Java 标准是非常明确的。它要求采用补码表示，取
值范围与图2-10中 64 位的情况一样。在Java 中，单字节数据类型称为 byte，而不是 char。这
些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现地完全一样。
旁注 有符号数的其他表示方法
有符号数还有两种标准的表示方法：
反码(Ones” Complement)；除了最高有效位的权是一(2w-1 -1)而不是一2w-1，它
和补码是一样的：
一2
B20w(立) =-Iuri (2w-l-1) +}x。2'
i=0
原码(Sign-Magnitude)：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：
ー2
B2S„(7) = (– 1) •(Ex，2')
i=0
这两种表示方法都有一个奇怪的属性，那就是对于数字0有两种不同的編码方式。
这两种表示方法，把[00…0]都解释为+0。而值一0 在原码
中表示为[11…1]。。虽然过去生产过基于反码表示的机器，但是几乎所有的現代机器都
使用补码。我们将看到在浮点教中有使用原码编码。
[10•
]，在反


Page 84
48
第一部分 程序结构和执行
请注意补码(Two's complement) 和反码(Ones'complement)中搬号的位置是不同
的。术语补码来源于这样一个情况，对于非负数 z，我们用 2"-x(这里只有一个 2)来
计算一x的w位表示。术语反码来源于这样一个属性，我们用[111…1]-z(这里有很多
个1)来计算一x 的反码表示。
为了更好地理解补码表示，考虑下面的代码：
一
short x = 12345；
short mx = -x；
3
show_bytes ((byte_pointer) &x， sizeof (short))；
show_bytes ((byte_pointer) &mx， sizeof (short))；
4
5
当在大端法机器上运行时，这段代码的输出为30 39 和 cf c7，指明x的十六进制表
示为 Ox3039，而 mx 的十六进制表示为 0XCFC7。将它们展开为二进制，我们得到x 的位
模式为[0011000000111001]，而mx 的位模式为[1100111111000111]。如图 2-15 所示，等
式(2。3)对这两个位模式生成的值为 12 345 和一12 345。
12 345
-12 345
53 191
权
位
值
位
值
位
值
1
1
1
1
1
1
1
2
1
4
1
4
1
4
8
1
8
16
1
16
32
1
32
64
1
64
1
64
128
1
128
1
128
256
1
256
1
256
512
1
512
1
512
1 024
1
1 024
1
1 024
2 048
1
2 048
1
2 048
4 096
4096
8 192
1
8192
16 384
1
16 384
1
16 384
土32 768
1
-32 768
32 768
总计
12 345
-12 345
53 191
图 2-15
12 345 和-12 345 的补码表示，以及53 191 的无符号表示。注意后面两个数有相同的位表示
练习题2。18 在第3章中，我们将看到由反汇编器生成的列表，反汇编器是一种将可
执行程序文件转换回可读性更好的 ASCII 码形式的程序。这些文件包含许多十六进制
数字，都是用典型的补码形式来表示这些值。能够认识这些数字并理解它们的意义
(例如它们是正数还是负数)，是一项重要的技巧。
在下面的列表中，对于标号为 A~I(标记在右边)的那些行，将指令名(sub、mov
和 add)右边显示的(32 位补码形式表示的)十六进制值转换为等价的十进制值。
$0x2e0，%rsp
-Ox58 (%rsp)，%rax
Ox28 (%rdi)，%rax
%rax，-0x30 (%rsp)
4004d0：
48 81 ec e0 02 00 00
sub
A。
4004d7：
48 8b 44 24 a8
mov
В。
4004dc：
48 03 47 28
add
с。
4004e0：
48 89 44 24 do
mov
D。
O O O O


Page 85
第2章 信息的表示和处理
49
Ox78 (%rsp)，%rax
%rax，Ox88 (%rdi)
Ox1f8(%rsp)，%rax
4004e5：
48 8b 44 24 78
mov
Е。
4004ea：
48 89 87 88 00 00 00
mov
F。
4004f1：
48 8b 84 24 f8 01 00
mov
G。
4004f8：
00
Ox8(%rsp)，%rax
%rax，0xc0(%rsp)
4004f9：
48 03 44 24 08
add
4004fe：
48 89 84 24 c0 00 00
mov
Н。
400505：
00
400506：
48 8b 44 d4 b8
-0x48 (%rsp，%rdx，8)，%rax
I。
mov
2。2。4 有符号数和无符号数之间的转换
C语言允许在各种不同的数字数据类型之间做强制类型转换。例如，假设变量 x声明
为int， u声明为 unsigned。表达式 (unsigned) x会将x的值转换成一个无符号数值，而
(int)u 将u的值转换成一个有符号整数。将有符号数强制类型转换成无符号数，或者反
过来，会得到什么结果呢?从数学的角度来说，可以想象到几种不同的规则。很明显，对
于在两种形式中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号
数可能会得到0。如果转换的无符号数太大以至于超出了补码能够表示的范围，可能会得
到 TMax。不过，对于大多数C语言的实现来说，对这个问题的回答都是从位级角度来看
的，而不是数的角度。
比如说，考虑下面的代码：
= -12345；
(unsigned short) v；
1
short
int
V
unsigned short uv =
printf("v
2
3
%d， uv = %u\n"， v， uv)；
%3D
在一台采用补码的机器上，上述代码会产生如下输出：
v = -12345， uv = 53191
我们看到，强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。在图 2-15
中我们看到过，-12 345 的16 位补码表示与53 191 的16 位无符号表示是完全一样的。将
short 强制类型转换为 unsigned short 改变数值，但是不改变位表示。
类似地，考虑下面的代码：
unsigned u
/* UMax */
4294967295u；
tu = (int) u；
%u， tu = %d\n"， u， tu)；
1
%3D
2
int
3
printf("u
在一台采用补码的机器上，上述代码会产生如下输出：
u = 4294967295， tu = -1
从图 2-14 我们可以看到，对于32 位字长来说，无符号形式的4294 967 295(UMax s2)
和补码形式的一1的位模式是完全一样的。将 unsigned 强制类型转换成 int，底层的位
表示保持不变。
对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规
则是：数值可能会改变，但是位模式不变。让我们用更数学化的形式来描述这个规则。我们
定义函数 U2B，和 T2Bw，它们将数值映射为无符号数和补码形式的位表示。也就是说，给
定 0<<UMarw范围内的一个整数 z，函数 U2B。(x)会给出x的唯一的 w位无符号表示。
相似地，当x满足 TMin，<r<TMare，函数 T2B。。(x)会给出x的唯一的 w位补码表示。
现在，将函数T2U。定义为T2U(a)-B2U(T2B。(x))。这个函数的输人是一个


Page 86
50
第一部分 程序结构和执行
TMinw~TMa的数，结果得到一个 0~UMar u 的值，这里两个数有相同的位模式，除
了参数是无符号的，而结果是以补码表示的。类似地，对于0~UMaxw 之间的值x，定义函
数U2Tw为U2Tw (z)一B2T。(U2B (z))。生成一个数的无符号表示和x的补码表示相同。
继续我们前面的例子，从图 2-15 中，我们看到 T2U16(-12 345) = 53 191，并且
U2T16(53 191)=-12 345。也就是说，十六进制表示写作 OxCFC7 的16 位位模式既是
-12 345的补码表示，又是53 191的无符号表示。同时请注意 12 345+53 191=65 536=
216。这个属性可以推广到给定位模式的两个数值(补码和无符号数)之间的关系。类似地，
从图 2-14 我们看到 T2U32(一1)=4294 967 295，并且U2T 32 (4 294 967 295) =-1。也就是
说，无符号表示中的 UMaz 有着和补码表示的-1相同的位模式。我们在这两个数之间也
能看到这种关系：1+UMarw=2”。
接下来，我们看到函数 U2T 描述了从无符号数到补码的转换，而 T2U 描述的是补码
到无符号的转换。这两个函数描述了在大多数C语言实现中这两种数据类型之间的强制类
型转换效果。
练习题 2。19 利用你解答练习题 2。17 时填写的表格，填写下列描述函数 T2U。的表格。
T2U，(x)
-8
-3
-2
-1
5
通过上述这些例子，我们可以看到给定位模式的补码与无符号数之间的关系可以表示
为函数 T2U 的一个属性：
原理：补码转换为无符号数
对满足 TMin<r<TMar。 的ェ有：
ェ+2"，
x< 0
T2U (x)
(2。 5)
=
x>0
比如，我们看到 T2U16(-12345)=-12 345+216 = 53 191，同时 T2U。(一1)=-1+
2" =UMax w o
该属性可以通过比较公式(2。1)和公式(2。3)推导出来。
推导：补码转换为无符号数
比较等式(2。1)和等式(2。3)，我们可以发现对于位模式 立，如果我们计算 B2U。()-
B2T。(立)之差，从0到w-2的位的加权和将互相抵消掉，剩下一个值：B2U。(G)-B2T。 (2)=
T一1(2"-1-(一2w-1))=xw-12w。这就得到一个关系：B2U()=rw-12w +B2T。(は)。我
们因此就有
B2U„ (T2B。(x)) = T2U„(x)
根据公式(2。5)的两种情况，在x的补码表示中，位 zu一1决定了ェ是否为负。
比如说，图2-16 比较了当 w=4时函数 B2U 和B2T 是如何将数值变成位模式的。对
补码来说，最高有效位是符号位，我们用带向左箭头的条来表示。对于无符号数来说，最
高有效位是正权重，我们用带向右的箭头的条来表示。从补码变为无符号数，最高有效位
= x+xu-12ª
(2。 6)


Page 87
第2章 信息的表示和处理
51
的权重从一8变为+8。因此，补码表示的负数如果看成无符号数，值会增加 21= 16。因
而，一5变成了+11，而一1变成了+15。
-2 = -8
23 = 8
22 = 4
21 = 2
20 = 1
-8 -7 -6
-4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
[1011]
+16
[1111]
+16
图2-16
比较当 w=4时无符号表示和补码表示(对补码和无符号数来说，
最高有效位的权重分别是一8和+8，因而产生一个差为 16)
图2-17 说明了函数 T2U 的一般行为。如图所示，当将--个有符号数映射为它相应的
无符号数时，负数就被转换成了大的正数，而非负数会保持不变。
练习题2。20 请说明等式(2。 5)是如何应用到解答练习题 2。19 时生成的表格中的各项的。
反过来看，我们希望推导出一个无符号数 u 和与之对应的有符号数U2T。。(u)之间的关系：
原理：无符号数转换为补码
对满足 0<u<UMaxw的u有：
и
U2T„ (u)
(2。 7)
=
u – 2"，
u> TMax
，该原理证明如下：
推导：无符号数转换为补码
设=U2B。(u)，这个位向量也是U2T。(u)的补码表示。公式(2。 1)和公式(2。3)结合起来有
U2T„(u) =- uw-12“ +u
(2。 8)
在u的无符号表示中，对公式(2。7)的两种情况来说，位 u一1决定了u是否大于
TMax =2"-1-1。
图2-18 说明了函数 U2T 的行为。对于小的数(<TMar。)，从无符号到有符号的转换
将保留数字的原值。对于大的数(>TMar。)，数字将被转换为一个负数值。
2"
2-1无符号数
无符号数 21
+21
+2-1
补码 0
0 补码
-2"-1
-2-1
图2-17 从补码到无符号数的转换。函数
T2U 将负数转换为大的正数
图2-18 从无符号数到补码的转换。函数 U2T
把大于 2-1-1的数字转换为负值


Page 88
52
第一部分 程序结构和执行
总结一下，我们考虑无符号与补码表示之间互相转换的结果。对于在范围 0<s
TMaxw 之内的值x 而言，我们得到 T2U。(x)=ェ和U2T。(z) =x。也就是说，在这个范
围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或者减
去 2”。例如，我们有 T2U。(一1)=-1+2"=UMar w一最靠近0的负数映射为最大的无
符号数。在另一个极端，我们可以看到T2Uw(TMin)=-2w-1+2= 2w-1= TMaza +
1一最小的负数映射为一个刚好在补码的正数范围之外的无符号数。使用图2-15 的示
例，我们能看到 T2U16(-12 345)=65 563+-12 345=53 191。
2。2。5 C语言中的有符号数与无符号数
如图2-9 和图2-10 所示，C语言支持所有整型数据类型的有符号和无符号运算。尽管
C语言标准没有指定有符号数要采用某种表示，但是几乎所有的机器都使用补码。通常，
大多数数字都默认为是有符号的。例如，当声明一个像 12345 或者 Ox1A2B 这样的常量时，
这个值就被认为是有符号的。要创建一个无符号常量，必须加上后缀字符“U”或者‘u’，
例如，12345U 或者 Ox1A2Bu。
C语言允许无符号数和有符号数之间的转换。虽然C标准没有精确规定应如何进行这
种转换，但大多数系统遵循的原则是底层的位表示保持不变。因此，在一台采用补码的机
器上，当从无符号数转换为有符号数时，效果就是应用函数 U2Tw，而从有符号数转换为
无符号数时，就是应用函数 T2U，其中 w表示数据类型的位数。
显式的强制类型转换就会导致转换发生，就像下面的代码：
1
int tx， ty；
2
unsigned ux， uy；
3
tx =
(int) ux；
4
5
uy
(unsigned) ty；
另外，当一种类型的表达式被赋值给另外一种类型的变量时，转换是隐式发生的，就
像下面的代码：
1
int tx， ty；
2
unsigned ux， uy；
3
tx = ux； /* Cast to signed */
uy = ty； /* Cast to unsigned */
4
当用 printf 输出数值时，分别用指示符8d、u 和多x 以有符号十进制、无符号十进制
和十六进制格式输出一个数字。注意 printf 没有使用任何类型信息，所以它可以用指示
符u来输出类型为 int 的数值，也可以用指示符8d 输出类型为 unsigned 的数值。例如，
考虑下面的代码：
1
int x = -1；
unsigned u
= 2147483648； /* 2 to the 31st */
%d\n"， x， x)；
printf ("x
printf ("u
4
= %u =
= %u
%d\n"， u， u)；
%3D
当在一个32 位机器上运行时，它的输出如下：
x = 4294967295 = -1
u = 2147483648 = -2147483648


Page 89
第2章 信息的表示和处理
53
在这两种情况下， printf 首先将这个字当作一个无符号数输出，然后把它当作一个有
符号数输出。以下是实际运行中的转换函数：T2U2(-1)=UMara=232 -1 和U2T2(231 ) =
231 – 232 =- 231=TMin32 。
由于C语言对同时包含有符号和无符号数表达式的这种处理方式，出现了一些奇特的
行为。当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C
语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执
行这个运算。就像我们将要看到的，这种方法对于标准的算术运算来说并无多大差异，但
是对于像<和>这样的关系运算符来说，它会导致非直观的结果。图 2-19 展示了一些关
系表达式的示例以及它们得到的求值结果，这里假设数据类型 int 表示为 32 位补码。考
虑比较式- 1<0U。因为第二个运算数是无符号的，第一个运算数就会被隐式地转换为无符
号数，因此表达式就等价于 4294967295U<OU(回想 T2U。(-1)=UMarw)，这个答案显然
是错的。其他那些示例也可以通过相似的分析来理解。
表达 式
类 型
求
值
OU
无符号
1
==
-1
有符号
1
-1
OU
无符号
0*
2147483647
>
>-2147483647-1
>有符号
>1
>2147483647U >
>-2147483647-1
>无符号
>0*
>2147483647
>(int) 2147483648U
>有符号
>1*
>-1
>
>-2
>有符号
>1
>(unsigned) -1
>-2
>无符号
>1
>
>图 2-19
>C语言的升级规则的效果
>注：非直观的情况标注了‘* '。当一个运算教是无符号的时候，另一个运算数也被隐式强制转換为无符号。
>将 TMins2写为-2147483647-1 的原因请参见网络旁注 DATA：TMIN。
>假设在采用补码运算的 32 位机器上对这些表达式求值，按照图 2-19 的
>练习题2。21
>格式填写下表，描述强制类型转换和关系运算的结果。
>表 达式
>类
>型
>求
>值
>-2147483647-1
>2147483648U
>==
>-2147483647-1 < 2147483647
>-2147483647-1U < 2147483647
>-2147483647-1 < -2147483647
>-2147483647-1U < -2147483647
>网络旁注 DATA： TMIN
>C语言中 TMin的写法
>在图 2-19 和练习题 2。21 中，我们很小心地将 TMins2 写成-2147483647-1。为什么
>不简单地写成-2147483648 或者 Ox80000000? 看一下C头文件 limits。h，注意到它们
>使用了跟我们写 TMing2和TMar2 类似的方法：
>*/
>/* Minimum and maximum values a 'signed int' can hold。
>#define INT_MAX
>2147483647
>#define INT_MIN
>(-INT_MAX - 1)
>不幸的是，补码表示的不对称性和C语言的转换规则之间奇怪的交互，迫使我们用


Page 90
54
第一部分 程序结构和执行
这种不寻常的方式来写 TMins2。虽然理解这个问题題需要我们钻研 C语言标准的一些比
较隐晦的角落，但是它能够帮助我们充分领会整数数据类型和表示的一些细微之处。
2。2。6 扩展一个数字的位表示
一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标
数据类型太小以至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数
据类型转换到一个较大的类型，应该总是可能的。
要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0。
这种运算被称为零扩展(zero extension)，表示原理如下：
原理：无符号数的零扩展
定义宽度为w的位向量i=[uw1， Uu-2，…，uo]和宽度为 w的位向量i=[0，…，
0， uu-1， Uw-2，…，uo」，其中w>w。则 B2Uw(u) =B2U(i)。
按照公式(2。1)，该原理可以看作是直接遵循了无符号数编码的定义。
要将一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展(sign exten-
sion)，在表示中添加最高有效位的值，表示为如下原理。我们用蓝色标出符号位rーi来
突出它在符号扩展中的角色。
原理：补码数的符号扩展
定义宽度为 w的位向量エ=[x-1， Iu-2，*，To。
]和宽度为 w的位向量定=[xi1，
X w-1 ， Xw-1， Xw-2 •
， Io]，其中 w>w。则 B2T。(云)=B2T。(定)。
例如，考虑下面的代码：
short sx = -12345；
/* -12345 */
/*
1
53191 */
/* -12345 */
/*
2
unsigned short usx = sx；
3
int x = sx；
4
unsigned ux = usx；
53191 */
printf ("sx
show_bytes ( (byte_pointer) &sx， sizeof (short))；
printf ("usx =
show_bytes ( (byte_pointer) &usx， sizeof (unsigned short))；
printf("x
show_bytes ( (byte_pointer) &x， sizeof (int))；
6。
%d：\t"， sx)；
%3D
7
8
%u：\t"， usx)；
9。
10
%d：\t"， x)；
11
12
printf("ux
%u：\t"， ux)；
13
show_bytes ( (byte_pointer) &ux， sizeof (unsigned))；
在采用补码表示的32 位大端法机器上运行这段代码时，打印出如下输出：
= -12345：
cf c7
cf c7
SX
usx =
53191：
= -12345：
ff ff cf c7
ux
= 53191：
00 00 cf c7
我们看到，尽管-12 345 的补码表示和 53 191 的无符号表示在16 位字长时是相同的，但是
在32位字长时却是不同的。特别地，-12 345 的十六进制表示为 0XFFFFCFC7，而53 191的十
六进制表示为 0X0000CFC7。前者使用的是符号扩展一最开头加了16 位，都是最高有效位1，
表示为十六进制就是 OXFFFF。后者开头使用 16 个0来扩展，表示为十六进制就是 Ox0000。
图2-20 给出了从字长 w=3到 w=4的符号扩展的结果。位向量[101]表示值一4+1=


Page 91
第2章 信息的表示和处理
55
-3。对它应用符号扩展，得到位向量[1101]，表示的值一8+4+1=-3。我们可以看到，
对于 w=4，最高两位的组合值是一8+4=-4，与w=3时符号位的值相同。类似地，位
向量[111]和[1111]都表示值-1。
|-23 = -8
-22 = -4
22 = 4
21 = 2
20 = 1
-3 -2 -1 0 1 2 3 4 5
十
6 7 8
十H
+
-8 -7 -6 -5
[101]
[1101]
[111]
[1111]
从 w=3到w=4的符号扩展示例。对于 w=4，最高两位组合
权重为-8+4=-4，与w=3时的符号位的权重一样
图 2-20
有了这个直觉，我们现在可以展示保持补码值的符号扩展。
推导：补码数值的符号扩展
令 w=wtk，我们想要证明的是
B2Twtk (Lxu-1 ，…* ，Xw-1 9Xu-i 9Xw-2 ** ， Xo]) = B2T„([xx-1 ，a
u-1 9 Xu–2 ， **，x])
。。。
。。。
k次
下面的证明是对k进行归纳。也就是说，如果我们能够证明符号扩展一位保持了数值
不变，那么符号扩展任意位都能保持这种属性。因此，证明的任务就变为了：
B2Tw+1 ([xw-1 ，Xu-1 ， Xw-2 9*** ， x。]) = B2T„([rµ-1 9 Xw-2 »*** ， 2
用等式(2。3)展开左边的表达式，得到：
B2Tw+1([xw-1 9Xu–1 9Xw–2，***，xo]) =– xu-1
2"+ Σ， 2'
i=0
teー2
=- xu-1 2" +Iw-1 2"-1 + >x，2'
i=0
一2
=- xu-1 (2ª – 2u-1) + > x；2
i=0
w-2
=- xu-1 2" +>x；2
i=0
= B2T„([xu-1 9Xw-2 »*** ；
…，工o])
我们使用的关键属性是 2"一2-1=2-1。因此，加上一个权值为一2”的位，和将一个权值为
-2*-!的位转换为一个权值为2*-1的位，这两项运算的综合效果就会保持原始的数值。
练习题2。22 通过应用等式(2。3)，表明下面每个位向量都是一5 的补码表示。
A。 [1011]
B。 [11011]


Page 92
56
第一部分 程序结构和执行
C。 [111011]
可以看到第二个和第三个位向量可以通过对第一个位向量做符号扩展得到。
值得一提的是，从一个数据大小到另一个数据大小的转换，以及无符号和有符号数字
之间的转换的相对顺序能够影响一个程序的行为。考虑下面的代码：
1
short sx = -12345；
/* -12345
*/
unsigned uy = sx；
/* Mystery! */
2
3
%u：\t"， uy)；
printf("uy
show_bytes( (byte_pointer) &&uy， sizeof (unsigned))；
4
5
在一台大端法机器上，这部分代码产生如下输出：
uy = 4294954951：
ff ff cf c7
这表明当把 short 转换成 unsigned 时，我们先要改变大小，之后再完成从有符号到
无符号的转换。也就是说(unsigned) sx 等价于 (unsigned)(int) sx，求值得到
4 294 954 951，而不等价于(unsigned)(unsigned short) sx，后者求值得到 53 191。事
实上，这个规则是C语言标准要求的。
练习题2。23
考虑下面的C函数：
int fun1(unsigned word) {
return (int) ((word << 24) >> 24)；
}
int fun2(unsigned word) {
return ((int) word << 24) >> 24；
}
假设在一个采用补码运算的机器上以32 位程序来执行这些函数。还假设有符号数值
的右移是算术右移，而无符号数值的右移是逻辑右移。
A。 填写下表，说明这些函数对几个示例参数的结果。你会发现用十六进制表示来做
会更方便，只要记住十六进制数字8到F的最高有效位等于1。
fun1 (w)
fun2 (w)
W
0x00000076
0x87654321
Ox000000C9
0XEDCBA987
B。用语言来描述这些函数执行的有用的计算。
2。2。7 截断数字
假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代
码中这种情况：
1
int x = 53191；
2
short sx =
(short) x；
/* -12345 */
3
int y = sx；
/* -12345 */
当我们把x强制类型转换为 short 时，我们就将32 位的 int 截断为了16 位的short int。


Page 93
第2章 信息的表示和处理
57
就像前面所看到的，这个16 位的位模式就是一12 345 的补码表示。当我们把它强制类型
转换回 int 时，符号扩展把高16 位设置为1，从而生成-12 345的32 位补码表示。
当将一个 w位的数之=[xuー1， Tui2，…，Io]截断为一个k位数字时，我们会丢弃高
w一k位，得到一个位向量定=[r-1， I-2，
值一一溢出的一种形式。对于一个无符号数，我们可以很容易得出其数值结果。
原理：截断无符号数
令元等于位向量[xu-1， Iw-2，
， zo]。令z=B2U。(定)，x'=B2U。(G)。则x'=xmod 2*。
该原理背后的直觉就是所有被截去的位其权重形式都为 2，其中>k，因此，每一个
权在取模操作下结果都为零。可用如下推导表示：
推导：截断无符号数
通过对等式(2。 1)应用取模运算就可以看到：
エo]。截断一个数字可能会改变它的
***，
エo]，而之是将其截断为k位的结果：之=[c-1，
Xk-2 ， ***
uー1
B2U ([xv-1 ，Iu-2 9*** ， xo]) mod 2*
Σ2mod 2
K-1
Σ21 mod 2
i=0
k-1
i=0
B2U， ([xH1 ，It2，** ，xo])
在这段推导中，我们利用了属性：对于任何>k，2' mod 2* =0。
补码截断也具有相似的属性，只不过要将最高位转换为符号位：
原理：截断补码数值
令立等于位向量[z-1，Tw-2，…，Zo]，而之是将其截断为k位的结果：之=[x-1，
， zo]。令x=B2U。(は)，z'=B2T， (2')。则r'=U2T，(a mod 24)。
在这个公式中，z mod 24 将是0到 2*-1之间的一个数。对其应用函数 U2T，产生的
效果是把最高有效位 xょ-1
int 转换为 short。由于 216 =65 536>x，我们有z mod 216 =r。但是，当我们把这个数
转换为16 位的补码时，我们得到ェ'=53 191-65 536=-12345。
推导：截断补码数值
使用与无符号数截断相同的参数，则有
Ikー2，
的权重从 2*-1转变为-2*-1。举例来看，将数值 x=53 191 从
B2U„ ([xu-1 ，Xw-2 ，*** ， Xo])mod 2*
%3D
也就是，z mod 2^能够被一个位级表示为[xー1，I-2，
换为补码数则有=U2T，(a mod 2*)。
总而言之，无符号数的截断结果是：
…，xo]的无符号数表示。将其转
Xk-2 ， ***， XoJ
B2U„ ([xw-1 »Xw-2 ，** ， xo ]) mod 2*
(2。 9)
而补码数字的截断结果是：
B2T [x-1 9X-2 ，。，xo] = U2T，(B2U„([xw-1 ，Xr-2，*** ， Xo]) mod 2*)
练习题2。24 假设将一个4位数值(用十六进制数字 0~F 表示)截断到一个3位数值
(用十六进制数字 0~7 表示)。填写下表，根据那些位模式的无符号和补码解释，说
明这种截断对某些情况的结果。
(2。 10)


Page 94
58
第一部分 程序结构和执行
十六进制
无符号
补码
截断值
原始值
截断值
原始值
截断值
2
2
1
9。
-7
3
11
-5
F
7
15
-1
解释如何将等式(2。9)和等式(2。 10)应用到这些示例上。
2。2。8 关于有符号数与无符号数的建议
就像我们看到的那样，有符号数到无符号数的隐式强制类型转换导致了某些非直观的
行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细徵差
别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，
程序员经常忽视了它的影响。
下面两个练习题说明了某些由于隐式强制类型转换和无符号数据类型造成的细微的错误。
练习题2。25 考虑下列代码，这段代码试图计算数组a中所有元素的和，其中元素的
数量由参数 length 给出。
/* WARNING： This is buggy code */
float sum_elements(float a[]， unsigned length) {
1
2
3
int i；
4
float result = 0；
5
for (i = 0； i <= length-1； i++)
result += a[i]；
7
return result；
当参数 length 等于0时，运行这段代码应该返回 0。0。但实际上，运行时会遇
到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码。
练习题2。26 现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更
长。前提是你要用字符串库函数 strlen，它的声明如下：
/* Prototype for library function strlen */
size_t strlen(const char *s)；
最开始你写的函数是这样的：
/* Determine whether string s is longer than string t */
/* WARNING： This function is buggy */
int strlonger (char *s， char *t) {
return strlen(s)
strlen(t) > 0；
当你在一些示例数据上测试这个函数时，一切似乎都是正确的。进一步研究发现
在头文件 stdio。h 中数据类型 size_t 是定义成unsigned int 的。
A。在什么情况下，这个函数会产生不正确的结果?
B。 解释为什么会出现这样不正确的结果。
C。说明如何修改这段代码好让它能可靠地工作。
始|0 29 B r


Page 95
第2章 信息的表示和处理
59
旁注 函数 getpeername 的安全漏洞
2002年，从事 FreeBSD 开源操作系统项目的程序员意识到，他们对 getpeername
函数的实现存在安全漏洞。代码的简化版本如下：
1
/*
* Illustration of code vulnerability similar to that found in
* FreeBSD's implementation of getpeername()
*/
2
3
4
/* Declaration of library function memcpy */
void *memcpy (void *dest， void *src， size_t n)；
8
/* Kernel memory region holding user-accessible data */
10
#define KSIZE 1024
11
char kbuf [KSIZE]；
12
/* Copy at most maxlen bytes from kernel region to user buffer */
int copy_from_kernel (void *user_dest， int maxlen) {
/* Byte count len is minimum of buffer size and maxlen */
13
14
15
16
int len
KSIZE < maxlen ? KSIZE ： maxlen；
%3D
memcpy(user_dest， kbuf， len)；
return len；
17
18
19
在这段代码里，第7行给出的是库函数 memcpy 的原型，这个函数是要将一段指定
长度为n的字节从内存的一个区域复制到另一个区域。
从第14行开始的函数 copy_from_kernel 是要将一些操作系统内核维护的数据复
制到指定的用户可以访问的内存区域。对用户来说，大多数内核维护的数据结构应该是
不可读的，因为这些数据结构可能包含其他用戶和系统上运行的其他作业的敏感信息，
但是显示为 kbuf 的区域是用户可以读的。参数 maxlen 给出的是分配给用户的缓冲区
的长度，这个缓冲区是用参数 user_dest 指示的。然后，第16 行的计算确保复制的字
节数据不会超出源或者目标缓冲区可用的范围。
不过，假设有些怀有恶意的程序员在调用 copy_from_kernel的代码中对 maxlen
使用了负数值，那么，第16行的最小值计算会把这个值赋给len，然后len会作为参
数n被传递给 memcpy。不过，请注意参数 n是被声明为数据类型 size_t 的。这个数据
类型是在库文件 stdio。h中(通过 typedef)被声明的。典型地，对 32 位程序它被定义
为 unsigned int，对64 位程序定义为 unsigned long。既然参教n是无符号的，那么
memcpy会把它当作一个非常大的正整数，并且试图将这样多字节的数据从内核区域复
制到用戶的缓冲区。虽然复制这么多字节(至少231 个)实际上不会完成，因为程序会遇
到进程中非法地址的错误，但是程序还是能读到它没有被授权的內核內存区域。
我们可以看到，这个问题是由于数据类型的不匹配造成的的：在一个地方，长度参数
是有符号数；而另一个地方，它又是无符号数。正如这个例子表明的那样，这样的不匹
配会成为缺陷的原因，甚至会导致安全漏洞。幸运的是，还没有案例报告有程序员在
FreeBSD 上利用了这个漏洞。他们发布了一个安全建议，“FreeBSD-SA-02：38。 signed-
error”，建议系统管理员如何应用补丁消除这个漏洞。要修正这个缺陷，只要将 copy_
from_kernel 的参数 maxlen 声明为类型 size_t，也就是与memcpy 的参数 n一致。同
时，我们也应该将本地变量 len 和返回值声明为 size_t。

Page 96
60
第一部分 程序结构和执行
我们已经看到了许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转
换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是绝不使用无符号数。实际
上，除了C以外很少有语言支持无符号整数。很明显，这些语言的设计者认为它们带来的
麻烦要比益处多得多。比如，Java 只支持有符号整数，并且要求以补码运算来实现。正常
的右移运算符>>被定义为执行算术右移。特殊的运算符>>>被指定为执行逻辑右移。
当我们想要把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用
的。例如，往一个字中放人描述各种布尔条件的标记(flag)时，就是这样。地址自然地就
是无符号的，所以系统程序员发现无符号类型型是很有帮助的。当实现模运算和多精度运算
的数学包时，数字是由字的数组来表示的，无符号值也会非常有用。
2。3 整数运算
许多刚人门的程序员非常惊奇地发现，两个正数相加会得出一个负数，而比较表达式
x<y和比较表达式 x-y<0 会产生不同的结果。这些属性是由于计算机运算的有限性造成的。
理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。
2。3。1 无符号加法
考虑两个非负整数z和y，满足0<z， y<2”。每个数都能表示为w位无符号数字。然而，
如果计算它们的和，我们就有一个可能的范围 0<a+y<2+1-2。表示这个和可能需要 w十+1
位。例如，图2-21 展示了当x和y有4位表示时，函数 z+y的坐标图。参数(显示在水平轴
上)取值范围为0~15，但是和的取值范围为0~30。函数的形状是一个有坡度的平面(在两个维
度上，函数都是线性的)。如果保持和为一个 wt1位的数字，并且把它加上另外一个数值，我
们可能需要 w+2个位，以此类推。这种持续的“字长膨胀”意味着，要想完整地表示算术运
算的结果，我们不能对字长做任何限制。一些编程语言，例如Lisp，实际上就支持无限精度的
运算，允许任意的(当然，要在机器的内存限制之内)整数运算。更常见的是，编程语言支持固
定精度的运算，因此像“加法”和“乘法”这样的运算不同于它们在整数上的相应运算。
32
28
24
20
16
14
12
10
12
8
4
4
6
10
12
14
图2-21 整数加法。对于一个4位的字长，其和可能需要5位

Page 97
第2章 信息的表示和处理
61
让我们为参数x和y定义运算十，其中 0<z， y<2"，该操作是把整数和x+y截断
为w位得到的结果，再把这个结果看做是一个无符号数。这可以被视为一种形式的模运
算，对z十y的位级表示，简单丢弃任何权重大于2w-1的位就可以计算出和模 2”。比如，
考虑一个4位数字表示，z=9 和y=12 的位表示分别为[1001]和[1100]。它们的和是 21，
5位的表示为[10101]。但是如果丟弃最高位，我们就得到[0101]，也就是说，十进制值
的5。这就和值 21 mod 16=D5一致。
我们可以将操作十。描述为：
原理：无符号数加法
对满足 0<r， y<2” 的x和y有：
エ+y<2
lx+y-2"， 2" <x+y<2u+1
(ェ+y，
正常
エ十y
(2。 11)
溢出
图 2-22 说明了公式(2。 11)的这两种情况，左边的和x十
y映射到右边的无符号 w位的和x十y。正常情况下 x+y
的值保持不变，而溢出情况则是该和数减去 2"的结果。
推导：无符号数加法
一般而言，我们可以看到，如果 rty<2"，和的wt
1位表示中的最高位会等于 0，因此丟弃它不会改变这个数
值。另一方面，如果 2"<a+y<2w+1，和的w+1位表示 图 2-22 整数加法和无符号加法
中的最高位会等于1，因此丢弃它就相当于从和中减去
了2”。
说一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。如等
式(2。11)所示，当两个运算数的和为 2"或者更大时，就发生了溢出。图 2-23 展示了字长
w=4的无符号加法函数的坐标图。这个和是按模 21 = 16 计算的。当x+y<16 时，没有
溢出，并且x十y就是a+y。这对应于图中标记为“正常”的斜面。当z十y>16 时，加
法溢出，结果相当于从和中减去 16。这对应于图中标记为“溢出”的斜面。
xty
2w+1T溢出
0-正常
间的关系。当x+y大于
2-1时，其和溢出：
溢出
16-
14-
正常
12-
10-
14
12
8-
6-
10
4-
8。
2-
9。
8
10
12
14
图2-23 无符号加法(4 位字长，加法是模 16 的)

Page 98
62
第一部分 程序结构和执行
当执行C程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定
是否发生了溢出。
原理：检测无符号数加法中的溢出
对在范围 0<r， y<UMar。 中的ェ和y，令s二ェ十y。则对计算s，当且仅当s<a
(或者等价地 s<y)时，发生了溢出。
作为说明，在前面的示例中，我们看到9+：12=5。由于 5<9，我们可以看出发生了
溢出。
推导：检测无符号数加法中的溢出
通过观察发现x+y>4，因此如果s没有溢出，我们能够肯定s>a。另一方面，如果
s确实溢出了，我们就有s=x+yー2"。假设 y<2"，我们就有y一2w<0，因此s=x+
(y-2")<x。
练习题2。27 写出一个具有如下原型的函数：
/* Determine whether arguments can be added without overflow */
int uadd_ok (unsigned x， unsigned y)；
如果参数x和y相加不会产生溢出，这个函数就返回1。
模数加法形成了一种数学结构，称为阿贝尔群(Abelian group)，这是以丹麦数学家
Niels Henrik Abel(1802~1829)的名字命名。也就说，它是可交换的(这就是为什么叫
“abelian”的地方)和可结合的。它有一个单位元 0，并且每个元素有一个加法逆元。让我
们考虑 w位的无符号数的集合，执行加法运算十。对于每个值 z，必然有某个值一z 满
足一十=0。该加法的逆操作可以表述如下：
原理：无符号数求反
对满足 0<z<2"的任意z，其w位的无符号逆元一x由下式给出：
x = 0
一 =
(2。 12)
2w-工，
x> 0
该结果可以很容易地通过案例分析推导出来：
推导：无符号数求反
当ェ=0时，加法逆元显然是 0。对于 z>0，考虑值 2"-x。我们观察到这个数字在
0<2”-x<2" 范围之内，并且(x+2"-x) mod 2" =2" mod 2" =0。因此，它就是x在
十。下的逆元。
练习题2。28 我们能用一个十六进制数字来表示长度 w=4 的位模式。对于这些数字
的无符号解释，使用等式(2。 12)填写下表，给出所示数字的无符号加法逆元的位表示
(用十六进制形式)。
十六进制
十进制
十进制
十六进制
8。
D
F
2。3。2 补码加法
对于补码加法，我们必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。


Page 99
第2章 信息的表示和处理
63
给定在范围一2一1<a， y<2"-1-1之内的整数值 z 和y，它们的和就在范围一2"<x+
<2”-2之内，要想准确表示，可能需要 w+1 位。就像以前一样，我们通过将表示截断
到w位，来避免数据大小的不断扩张。然而，结果却不像模数加法那样在数学上感觉很熟
悉。定义z十y为整数和z+y被截断为w位的结果，并将这个结果看做是补码数。
原理：补码加法
对满足一2w-1<r， y<2"-1-1的整数ェ和y，有：
正溢出
- 2-l<rty<2~l 正常
(x+y-2"， 2ª-<x+y
x tuy = {x+y，
(2。 13)
le+y+2"， x+y<-2~1
图2-24 说明了这个原理，其中，左边的和x十y
的取值范围为一2"<xty<2"-2，右边显示的是该
和数截断为w位补码的结果。(图中的标号“情况1” 情况4
到“情况4”用于该原理形式化推导的案例分析中。)
当和ェ十y超过 TMaxu 时(情况4)，我们说发生了正溢
负溢出
x+y
+2"
正溢出
x+'y
T+2"-1
+2w-1
情况3
出。在这种情况下，截断的结果是从和数中减去2"。
0十正常
0-
当和ェ十y 小于TMinw 时(情况1)，我们说发生了负溢
情况2
出。在这种情况下，截断的结果是把和数加上 2"。
两个数的w位补码之和与无符号之和有完全相同
的位级表示。实际上，大多数计算机使用同样的机器 情况1
负溢出
指令来执行无符号或者有符号加法。
推导：补码加法
-2"
图2-24 整数和补码加法之间的关系。
既然补码加法与无符号数加法有相同的位级表示，
我们就可以按如下步骤表示运算十：将其参数转换为无
符号数，执行无符号数加法，再将结果转换为补码：
当ェ+y小于一 2-1时，产生
负溢出。当它大于 2~-1时，产
生正溢出
x tuy = U2T(T2U„(x)+T 2U„(y))
根据等式(2。6)，我们可以把T2U。。(c)写成rw-12"+z，把 T2U。(y)写成 yu-l
使用属性，即十。是模 2的加法，以及模数加法的属性，我们就能得到：
x twy = U2T„(T2U„(x) +„T2U„(y))
= U2T„[(xw-12" +x+ yw-1 2" + y) mod 2ª]
= U2T„[(x+y) mod 2"]
(2。 14)
一12+y。
消除了ー12 和 yu-12"这两项，因为它们模 2w等于0。
为了更好地理解这个数量，定义 x为整数和z=x+y，2为'=zmod 2"，而2”为
2ニU2T(z')。数值"等于 x+y。我们分成4种情况分析，如图 2-24 所示。
1) -2"<x<-2w-1。然后，我们会有2’=x十2”。这就得出 0<'<-21+2w =
检查等式(2。7)，我们看到2'在满足2"=z'的范围之内。这种情况称为负溢出(nega-
tive overflow)。我们将两个负数ェ和y相加(这是我们能得到 z<-2"-1的唯一方式)，得
20ー1
到一个非负的结果 =x+y+2"。
2) -2-1<x<0。那么，我们又将有z'=z+2"，得到一2"-1+2 = 2w-1<'<2w。
检查等式(2。7)，我们看到z在满足'=x'-2"的范围之内，因此=z-2"=z+2"
2=z。也就是说，我们的补码和”等于整数和x+y。
3) 0<x<2-1。那么，我们将有=x，得到0A~<2，因此=x'=x。补码和

Page 100
64
第一部分 程序结构和执行
又等于整数和x+y。
4) 2-1<x<2"。我们又将有z'=z，得到 2"-1<'<2”。但是在这个范围内，我们有
=z-2”，得到2"=x+y-2。这种情况称为正溢出(positive overflow)。我们将正数 z
和y相加(这是我们能得到 z>2w-1的唯一方式)，得到一个负数结果 z"=ェ+y-2%。
图 2-25 展示了一些4位补码加法的示例作为说明。每个示例的情况都被标号为对应
于等式(2。13)的推导过程中的情况。注意 21=16，因此负溢出得到的结果比整数和大 16，
而正溢出得到的结果比之小16。我们包括了运算数和结果的位级表示。可以观察到，能够
通过对运算数执行二进制加法并将结果截断到4位，从而得到结果。
y
x+ y
xt
情况
-8
-5
-13
3
1
[1000]
[1011]
[10011]
[0011]
-8
-8
-16
1
[1000]
[1000]
[10000]
[0000]
-8
5
-3
-3
2
[1000]
[0101]
[11101]
[1101]
2
5
7
7
3
[0010]
[0101]
[00111]
[0111]
5
5
10
-6
4
[0101]
[0101]
[01010]
[1010]
图 2-25 补码加法示例。通过执行运算数的二进制加法并将结果截断到4位，
可以获得4位补码和的位级表示
图2-26 阐述了字长 w=4的补码加法。运算数的范围为一8~7之间。当x十y<<-8
时，补码加法就会负溢出，导致和增加了16。当-8<x+y<8时，加法就产生 z+y。当
エ+y>8，加法就会正溢出，使得和减少了16。这三种情况中的每一种都形成了了图中的一
个斜面。
正常
负溢出
正溢出
6-
4。
2-
0-
-2-
-4-
-6-
-8 -
-4
-8-
图2-26 补码加法(字长为4位的情况下，当x+ y<-8时，
产生负溢出；x+y>8时，产生正溢出)