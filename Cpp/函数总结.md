# 使用函数

要使用CPP函数，必需做如下工作：

1.  提供函数原型
2.  提供函数定义
3.  调用函数

函数原型，格式如下：

```
typename functionName(parms);
```

比如：

```cpp
double calculate_tax(int tvarp);
```

函数定义，格式如下：

```
typename functionName(parms){
	statement(s)
}
```

如：

```cpp
double calculate_tax(int tvarp) {
    double tax = 0;
    if (tvarp > 15000) {
        tax += (tvarp - 15000) * 0.15;
        tvarp - 15000;
    }
    if (tvarp > 5000) {
        tax += (tvarp - 5000) * 0.1;
    }
    return tax;
}
```

>   思考：为什么Cpp需要函数原型，而Java不需要？
>
>   可以从Cpp和Java的函数（方法）编译原理来思考。

# 函数参数

Cpp一般按值传递，就是会创建一个变量（形参），然后将实参的值传给形参。形参的生命周期只在函数执行过程中，执行结束就销毁。（如果形参是class类型，并且不是引用，那么会执行复制构造函数和析构函数）。

# 函数和数组

对数组名sizeof可以得到数组的长度（以字节为单位，下同），而对指针名sizeof只能得到指针地址的长度，这个长度对于同一台机器是死的。

在Cpp中，当且仅当在函数头或者函数原型中，数组声明和指针声明是等价的，效果等于指针，所以函数传递数组需要传递长度，否则无法获取数组的长度。指针本身没有指出数组的长度。

# const形参

为了防止参数被修改，可以添加const，cpp的const强度比Java的final更高，不光不能改地址，还不能修改里面的内容。

普通指针不能用于const形参。

# 多维数组形参

```cpp
void array_fun_2(int (*arr)[2], int len);

void array_fun_3(int (*arr)[2][3], int len);
```

# 结构形参

按值传递很简单，略。

传递结构的地址：

-   调用函数时，将结构的地址(&pplace)而不是结构本身(pplace) 传递给它
-   将形参声明为指向polar的指针，即polar \*类型。由于函数不应该修改结构，因此使用了const 修饰符
-   由于形参是指针而不是结构，因此应间接成员运算符(->)， 而不是成员运算符(句点)

# 函数指针

用法：

1.  获取函数的地址
2.  声明一个函数指针
3.  使用函数指针来调用函数

**获取函数的地址**

获取函数的地址很简单，只要使用函数名(后面不跟参数)即可。

**声明一个函数指针**

函数原型

```cpp
int fun(double d);
```

函数指针

```cpp
int (*pf)(double);
pf = fun;
```

**使用函数指针来调用函数**

```cpp
int fun(double d);
void use_fun_ptr(int num, int (*pf)(double));

int main()
{
    int (*pf)(double);
    pf = fun;
    use_fun_ptr(5, pf);
    return 0;
}

int fun(double d)
{
    return (int) d;
}

void use_fun_ptr(int num, int (*pf)(double))
{
    for (int i = 0; i < num; ++i)
    {
        cout << pf(i * 3.4 / 2) << endl;
    }
}
```

```
0
1
3
5
6
```

# C++函数调用原理

编译过程的最终产品是可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址，计算机随后将逐步执行这些指令。
执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈(为此保留的内存块)，跳到标记函数起点的内存单元，执行函数代码(也许还需将返回值放入到寄存器中)，然后跳回到地址被保存的指令处。

这意味着使用函数时，会有一定的开销。

# 内联函数

内联函数的编译代码与其他程序代码“内联”起来了。编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。

要使用内联函数，必须采取下述措施之一：

-   在函数声明前加上关键字inline
-   在函数定义前加上关键字inline

通常的做法是省略原型，将整个定义(即函数头和所有函数代码)放在本应提供原型的地方。

```cpp
inline void inline_function()
{
    cout << "i am inline function" << endl;
}
```

# 引用变量

## 创建引用变量

```
int val = 20;
int &val_2 = val;//创建引用变量
```

引用和指针相似，但是引用在声明的时候必须初始化，而指针不需要，引用更类似于const指针。

## 将引用用作函数参数

```cpp
void swapr(int &a, int &b)    // use references
{
    int temp;

    temp = a;       // use a, b for values of variables
    a = b;
    b = temp;
}
```

如果不想函数改变值，可以加const。

```cpp
double z = cube(x + 2.0);//按值传递可以
double z = refcube(x + 2.0);//按引用传递不可以
```

如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许。

**临时变量**：

什么时候将创建临时变量呢？如果引用参数是const，则编译器将在下面两种情况下生成临时变量：

-   实参的类型正确，但不是左值
-   实参的类型不正确，但可以转换为正确的类型

>   左值是什么？
>
>   左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量(用引号括起的字符串除外，它们由其地址表示)和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左边的实体，但这是引入关键字const之前的情况。现在，常规变量和const变量都可视为左值，因为可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。

编译器会生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器便会删除。

## 将引用用于结构

```cpp
void init_number(number &number)
{
    number.int_val = 1;
    number.long_val = 1;
}

number &add_number(const number &number_a, const number &number_b)
{
    //这种情况返回的是临时变量的引用，函数运行完，引用就没了。
//    number sum;
//    sum.int_val=number_a.int_val+number_b.int_val;
//    sum.long_val=number_a.long_val+number_b.long_val;
//    return sum;

    //这种方式可行，因为创建了新的空间。但因为创建了新的空间，所以要记得delete
    number *sum = new number;
    (*sum).int_val = number_a.int_val + number_b.int_val;
    (*sum).long_val = number_a.long_val + number_b.long_val;
    return *sum;
}

void display_number(const number &number)
{
    cout << "number int value is " << number.int_val << ", long value is " << number.long_val << endl;
}

void test_number()
{
    number number_a, number_b;

    init_number(number_a);
    init_number(number_b);

    number &sum = add_number(number_a, number_b);

    display_number(sum);

    delete &sum;
}
```

```
number int value is 2, long value is 2
```

## 何时使用引用参数

使用引用参数的主要原因有两个：

-   程序员能够修改调用函数中的数据对象。
-   通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时(如结构和类对象)，第二个原因最重要。这些也是使用指针参数的原因。

什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些指导原则：

**对于不修改参数的函数**

-   如果数据对象很小，如内置数据类型或小型结构，则按值传递。
-   如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
-   如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。 这样可以节省
    复制结构所需的时间和空间。
-   如果数据对象是类对象， 则使用const引用。类设计的语义常常要求使用引用，这是C++新增这
    项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

**对于修改调用函数中数据的函数**

-   如果数据对象是内置数据类型，则使用指针。
-   如果数据对象是数组，则只能使用指针。
-   如果数据对象是结构，则使用引用或指针。
-   如果数据对象是类对象，则使用引用。

# 默认参数

```cpp
void default_fun(int n = 1);

void test_default_fun();

int main()
{
    test_default_fun();
    return 0;
}

void default_fun(int n)
{
    cout << n << endl;
}

void test_default_fun()
{
    default_fun();
    default_fun(2);
}
```

通过函数原型添加默认参数。

# 函数模版

```cpp
template<typename T>
void val_swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}

void test_val_swap()
{
    int *a = new int;
    int *b = new int;
    *a = 1;
    *b = 2;
    val_swap(a, b);

    cout << "a = " << *a << endl;
    cout << "b = " << *b << endl;
}
```

```
a = 2
b = 1
```

要建立一个模板，关键字template和typename是必需的，关键字class可以代替typename。另外，必须使用尖括号。类型名可以任意选择(这里为T)。

## 显式具体化

```cpp
//非模板函数
void val_swap(int &a, int &b);

//模板函数
template<typename T>
void val_swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}

//具体化，<int>是可选的，也可以不写
template<>
void val_swap<int>(int &a, int &b);
```

# 编程练习

## 练习1

```cpp
void practice_8_question_1(char *str, int times)
{
    if (times <= 0)return;
    cout << str << endl;
    practice_8_question_1(str, times - 1);
}
```

## 练习2

```cpp
struct CandyBar
{
    char *band;
    double weight;
    int hot;
};

void practice_8_question_2();

void practice_8_question_2_a(CandyBar &candyBar, char *band = "Millennium Munch", double weight = 2.85, int hot = 350);
void practice_8_question_2_b(const CandyBar &candyBar);

void practice_8_question_2()
{
    CandyBar candyBar1;
    CandyBar candyBar2;
    practice_8_question_2_a(candyBar1, "abc", 1.1, 2);
    practice_8_question_2_a(candyBar2);
    practice_8_question_2_b(candyBar1);
    practice_8_question_2_b(candyBar2);
}

void practice_8_question_2_a(CandyBar &candyBar, char *band, double weight, int hot)
{
    candyBar.band = band;
    candyBar.weight = weight;
    candyBar.hot = hot;
}

void practice_8_question_2_b(const CandyBar &candyBar)
{
    cout << "CandyBar["
         << "band = " << candyBar.band
         << ", weight = " << candyBar.weight
         << ", hot = " << candyBar.hot
         << "]"
         << endl;
}
```

```
CandyBar[band = abc, weight = 1.1, hot = 2]
CandyBar[band = Millennium Munch, weight = 2.85, hot = 350]
```

## 练习3

```cpp
void practice_8_question_3()
{
    string s;
    while (cin >> s)
    {
        cout << "original string is " << s << endl;
        practice_8_question_3_a(s);
        cout << "original string is " << s << endl;
    }
}

void practice_8_question_3_a(string &s)
{
    transform(s.begin(), s.end(), s.begin(), ::toupper);//要加两个:
    cout << "upper string is " << s << endl;
}
```

```
abc
original string is abc
upper string is ABC
original string is ABC
zzsy
original string is zzsy
upper string is ZZSY
original string is ZZSY
```

可以看到，C++中的字符串是会被改变的。

## 练习5

```cpp
void practice_8_question_5()
{
    int ints[] = {1, 2, 3, 4, 5};
    double doubles[] = {1.1, 2.2, 3.3, 4.4, 5.5};
    cout << *practice_8_question_5_a(ints) << endl;//解除指针引用
    cout << *practice_8_question_5_a(doubles) << endl;
}

template<typename T>
T *practice_8_question_5_a(T *arr)
{
    T *maxValue;
    maxValue = max_element(arr, arr + 5);
    return maxValue;
}
```

```
5
5.5
```

