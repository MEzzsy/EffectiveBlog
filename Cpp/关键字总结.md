# explicit

```cpp
Chapter11 demo1 = 1.1;

string abc = "acb";
Chapter11 demo2 = abc;


Chapter11(double d);
Chapter11(const string &s);
```

C++可以隐式类型转换，如果要禁止这种行为，可以在构造函数前加explicit关键字。

```cpp
explicit Chapter11(double d);
```

# typedef

别名，如将unsigned long类型别名为Item：

```cpp
typedef unsigned long Item;
```

# static

static变量是在头文件中声明，在原文件中初始化。

`xxx.h`

```cpp
class xxx {
private:
    static int val;
};
```

`xxx.cpp`

```cpp
#include "xxx.h"
int xxx::val = 0;
```

初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。

**但如果静态成员是整型或枚举型const，则可以在类声明中初始化。**

# const

## 常量

创建常量的通用格式如下：

```
const type_name = value;
```

## const形参

为了防止参数被修改，可以添加const，cpp的const强度比Java的final更高，不光不能改地址，还不能修改里面的内容。

普通指针不能用于const形参。

## 指针和const

让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。将指针本身声明为常量，这样可以防止改变指针指向的位置。

**指向常量的指针**

```cpp
int age = 39;
const int * pt = &age;
```

pt的声明并不意味着pt指向一个常量(age就不是常量)，而是对pt来说，是一个常量，不能通过pt来更改age值。

>   不能将const变量的地址赋给普通指针

**指针本身声明为常量**

```cpp
int sloth = 3;
const int *ps = &sloth;
int * const finger = &sloth;
```

在最后一个声明中，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和\*ps都是const，而\*finger和ps不是。

## 返回对象和const

### 返回指向const对象的引用

```cpp
const Vector & Max (const Vector & v1, const Vector & v2){
    if(v1.val() > v2.val())
    	return vl;
    else
    	return v2;
}
```

这样做的目的是提高效率。

由于返回的是const对象引用，而返回函数内的临时引用会引发问题，所以只能返回形参引用，这就要求形参也是const。

### 返回指向非const对象的引用

两种常见的返回非const对象情形是，重载赋值运算符以及重载与cout一起使用的<<运算符。

前者是为了连续赋值：

```cpp
s1 = s2 = s3;
```

后者是为了串接输出：

```cpp
cout << s1 << endl;
```

## 参数括号后的const

```cpp
const Stock & topval (const Stock & s) const; 
```

括号后的const表明，该函数不会修改被隐式(this)地访问的对象。

```cpp
top = stock1.topval(stock2);
top = stock2.topval(stock1);
```

第一种格式隐式地访问stock1，而显式地访问stock2；第二种格式显式地访问stock1，而隐式地访问
stock2。