# cin

cin在输入会忽略空格和换行符，发送给cin的输入会被缓冲。

`cin >> str;`，这种输入方式不会读取空格、换行符等。

## 面向行的输入

### cin.getline(str,size)

getline是面向行的输入。

```cpp
void chapter_4_demo_input() {
    //面向行的输入：getline
    char str[5];
    cin.getline(str, 5);//input:abcdef
    cout << str << endl;//output:abcd
}
```

注意，读取的字符串长度是size-1，因为会在结尾加空字符`\0`。

getline通过换行符来确定行尾，但不保存换行符，它用空字符串来替换换行符。

### cin.get(str,size)

get也是面向行的输入

```cpp
void chapter_4_demo_input() {
    //面向行的输入：get
    char str[5];
    char str2[5];
    cin.get(str, 5);
    cin.get(str2, 5);
    cout << str << endl;
    cout << str2 << endl;
}
```

get不读取并丢弃换行符，而是将其留在输入队列中。

像上面的例子中，如果输入abcd，那么会直接执行cout。

因为第一次调用后，换行符留在输入队列中，第二次调用时看到的第一个字符是换行符，因此get()认为已到达行尾，而没有发现任何可读取的内容。

```cpp
cin.get(str, 5);
cin.get();
cin.get(str2, 5);
```

可以通过添加`cin.get();`的方式来解决，因为cin.get()可以读取换行符（只能读取一个字符），为下一行读取作准备。

### 两者区别

1.  getline使用简单，不用处理结尾的换行符，但是不能判断是换行还是字符串填满。
    get需要处理结尾的换行符，可以判断是换行还是字符串填满。

## cin.get(ch)

`cin.get(ch);`可以输入空格、换行符等，需要手动退出输入，这里只能传char类型，退出判断可以通过判断EOF，Mac键盘输入EOF的快捷键是command+D（注：在CLion run的框中这个快捷键是退出，可以在终端直接运行可执行文件）。

```cpp
while (!cin.eof()&&!cin.fail()) {
    //...
}
```

检测到EOF后，cin将两位(eofbit和failbit)都设置为1。eof()来查看eofbit是否被设置；如果检测到EOF，则cin.eof()将返回bool值true，否则返回false。fail同理。

更通用的版本是

```cpp
while (cin.get(ch)) {
    //...
}
```

因为istream类提供了一个可以将istream对象(如cin)转换为bool值的函数，这更加通用，因为可以检测其他原因，如：磁盘故障。

```cpp
char ch;
ch = cin.get();
cin.get(ch);
```

`ch = cin.get();`和`cin.get(ch);`效果相同，只是前者返回编码，后者返回istream对象。

# getline(cin,str)

string的面向行的输入