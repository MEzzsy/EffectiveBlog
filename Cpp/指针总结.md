# 指针基础

指针是一个变量，其存储的是值的地址，而不是值本身。

对变量应用地址运算符(&)，就可以获得它的位置：

```cpp
int val = 100;
cout << "value of val = " << val << endl;
cout << "address of val = " << &val << endl;
```

```
value of val = 100
address of val = 0x7ffee26979f8//前面的0省略了
```

指针用于存储值的地址。指针名表示的是地址。`*`运算符被称为间接值(indirect velue )或解除引用(dereferencing)运算符，将其应用于指针，可以得到该地址处存储的值。例如，假设manly是一个指针，则manly表示的是一个地址，而`*`manly表示存储在该地址处的值。`*`manly与常规int变量等效。

```cpp
int val = 100;
int *ptr_val;
ptr_val = &val;
cout << val << endl;
cout << &val << endl;
cout << ptr_val << endl;
cout << *ptr_val << endl;
```

```
100
0x7ffee7eb59f8
0x7ffee7eb59f8
100
```

这里引用《C++ Primer Plus》的话，`*`和`&`用在变量val上，就像硬币的正反面，`*val`和`val`表示值，`val`和`&val`表示地址。看上面的小例子会更好理解。

# 指针的危险

在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。

```cpp
int *p1;
*p1 = 1200;
cout << p1 << endl;
cout << *p1 << endl;
```

```
0x7ffeeb5e6a18
1200
```

p1是一个指针，但它没有被初始化。1200不知道会存放在哪。由于p1没有被初始化，它可能有任何值。不管值是什么，程序都将它解释为存储1200的地址。如果p1的值碰巧为100，计算机将把数据放在地址100上，即使这恰巧是程序代码的地址。p1指向的地方很可能并不是所要存储1200的地方，这种错误可能会导致一些最隐匿、最难以跟踪的bug。

**警告：一定要在对指针应用解除引用运算符`*`之前，将指针初始化为一个确定的的地址。**

# 指针和数组

```cpp
void test_array_fun() {
    int arr[4] = {1, 2, 3, 4};//数组
    int *ptr_arr = arr;//数组指针
    cout << "size of int = " << sizeof(int) << endl;
    cout << "size of arr = " << sizeof(arr) << endl;
    cout << "address of arr = " << &arr << endl;
    cout << "size of ptr_arr's address = " << sizeof(ptr_arr) << endl;
    cout << "address of ptr_arr = " << ptr_arr << endl;
}
```

```
size of int = 4
size of arr = 16
address of arr = 0x7ffee6394a40
size of ptr_arr's address = 8
address of ptr_arr = 0x7ffee6394a40
```

一般情况下，指针可以代替数组，但是还是有一点区别，区别如上。

对数组名sizeof可以得到数组的长度（以字节为单位，下同），而对指针名sizeof只能得到指针地址的长度，这个长度对于同一台机器是死的。

# 动态分配内存

## new分配内存

指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在C语言中，可以用库函数malloc()来分配内存；在C++中仍然可以这样做，但C++还有更好的方法：new运算符。

```cpp
int *pt = new int;
*pt = 100;
cout << pt << endl;
cout << *pt << endl;
```

```
0x7fe81dc017a0
100
```

## 使用delete释放内存

delete运算符，它使得在使用完内存后，能够将其归还给内存池，

```cpp
int *pt = new int;
*pt = 100;
cout << pt << endl;
cout << *pt << endl;

delete pt;
```

这将释放pt指向的内存，但不会删除指针pt本身。例如，可以将pt重新指向另一个新分配的内存块。

**一定要配对地使用new和delete；否则将发生内存泄漏**。

**不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。**

**不能使用delete来释放声明变量所获得的内存**

**只能用delete来释放使用new分配的内存。对空指针使用delete是安全的。**

## 使用new来创建动态数组

在编译时给数组分配内存被称为**静态联编**，意味着数组是在编译时加入到程序中的。
使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。这被称为**动态联编**，意味着数组是在程序运行时创建的。这种数组叫作动态数组。

使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。

创建动态数组很容易：只要将数组的元素类型和元素数目告诉new即可。

```cpp
int n = 10;
int *p_array = new int[n];
int array[n];
```

new运算符返回第一个元素的地址。

>   这里发现，静态数组也可以用变量声明长度。

使用另一种格式的delete来释放：

```cpp
delete[] p_array;
```

方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。

总之，使用new和delete时，应遵守以下规则：

-   不要使用delete来释放不是new分配的内存。
-   不要使用delete释放同一个内存块两次。
-   如果使用new[]为数组分配内存，则应使用delete[]来释放。
-   如果使用new[]为一个实体分配内存，则应使用delete(没有方括号)来释放。
-   对空指针应用delete是安全的。

# 指针和const

让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值。将指针本身声明为常量，这样可以防止改变指针指向的位置。

**指向常量的指针**

```cpp
int age = 39;
const int * pt = &age;
```

pt的声明并不意味着pt指向一个常量，而是对pt来说，是一个常量，不能通过pt来更改age值。

>   不能将const变量的地址赋给普通指针