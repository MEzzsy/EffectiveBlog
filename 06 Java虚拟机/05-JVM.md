# 垃圾收集器与内存分配策略

## 可达性分析算法

基本思路：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的时候，则证明此对象不可用。

可作为GC Roots的对象：

- 虚拟机栈中（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象

## 引用

在JDK1.2之后，Java对引用的概念进行了扩充：将引用分为**强引用、软引用、弱引用、虚引用**4种，这四种引用强度依次减弱。

- **强引用**就是指，在程序代码之中普通存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，GC就不会回收。
  也就是平时A a = new A()这个意思。
- **软引用（SoftReference）**是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围内进行第二次的回收。
  敏感数据的缓存，比如图片。
- **弱引用（WeakReference）**也是描述非必需的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次GC收集之前。当GC工作的时候，无论内存是否充足，都会回收掉弱引用。
  非敏感数据的缓存，比如Handler内存泄漏的处理。
- **虚引用（PhantomReference）**是最弱的一种引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用关联的目的就是在这个对象被GC回收的时候收到一个通知。
  对象销毁前的一些操作，比如说资源释放等。

**demo1，弱引用**

```java
public static void main(String[] args) {
    int[] ints = new int[1024 * 1024 * 20];
    WeakReference<int[]> weakReference = new WeakReference<>(ints);

    ints = null;//ints为强引用，需要指向null，否则数组对象不会被回收
    System.out.println(weakReference.get());
    System.gc();
    System.out.println(weakReference.get());
}
```

```
[I@7f31245a
null
```

这是弱引用的基本使用，可以看到gc之后，数组对象被回收了。

另外，虽然数组对象有一个弱引用，但是也有一个强引用，所以gc之后不会被回收，这里需要将强引用换一个对象引用（这里指向了null）。

这个demo可以回答我之前在百度被问到的一个问题：**图片缓存，图片对象被设为弱引用，为什么gc之后，图片还是会显示在ImageView上？**
图片对象虽然有弱引用，但是ImageView里也有一个强引用引用着图片对象，所以图片对象不会被回收。

**demo2，虚引用**

虚引用是最弱的引用，需要配合ReferenceQueue来使用，主要是检测对象是否存活。

它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。

```java
public class Main {
    public static void main(String[] args) {
        ReferenceQueue<int[]> referenceQueue = new ReferenceQueue<>();

        //此线程不断循环，判断对象是否被回收
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    Reference<? extends int[]> reference = referenceQueue.poll();
                    if (reference != null) {
                        System.out.println("虚引用对象被回收了");
                        break;
                    }
                }
            }
        }).start();

        PhantomReference<int[]> phantomReference = new PhantomReference<>(new int[1024 * 1024 * 20], referenceQueue);

        System.out.println(phantomReference.get());
        System.gc();
        System.out.println(phantomReference.get());
    }
}
```

```
null
null
虚引用对象被回收了
```

另外，虚引用的get方法：

```java
public T get() {
    return null;
}
```

源码是返回null，所以通过虚引用获取不到强引用。

## 对象在虚拟机中的生命周期

1.  创建阶段(Created)
    创建阶段的具体步骤为：
    1.  为对象分配存储空间。
    2.  构造对象。
    3.  从超类到子类对static成员进行初始化。
    4.  递归调用超类的构造方法。
    5.  调用子类的构造方法。
2.  应用阶段(In Use)
    当对象被创建，并分配给变量赋值时，状态就切换到了应用阶段。这一阶段的对象至少要具有一个强引用，或者显式地使用软引用、弱引用或者虚引用。
3.  不可见阶段(Invisible)
    在程序中找不到对象的任何强引用，比如程序的执行已经超出了该对象的作用城。在不可见阶段，对象仍可能被特殊的强引用GC Roots持有着，比如对象被本地方法栈中JNI引用或被运行中的线程引用等。
4.  不可达阶段(Unreachable)
    在程序中找不到对象的任何强引用，并且垃圾收集器发现对象不可达。
5.  收集阶段(Collected)
    垃圾收集器已经发现对象不可达，并且垃圾收集器已经准备好要对该对象的内存空间重新进行分配，这个时候如果该对象重写了finalize方法，则会调用该方法。
6.  终结阶段(Finalized)
    在对象执行完finalize方法后仍然处于不可达状态时，或者对象没有重写finalize方法，则该对象进入终结阶段，并等待垃圾收集器回收该对象空间。
7.  对象空间重新分配阶段(Deallocated)
    当垃圾收集器对对象的内存空间进行回收或者再分配时，这个对象就会彻底消失。

## 对象生存还是死亡

> finalize方法：一旦垃圾回收器准备好释放对象占用的内存，首先调用其finalize方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

即使在可达性分析算法中不可达的对象也并非“非死不可”的，要真正宣告一个对象的死亡，至少经历两次标记过程：

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会**第一次标记**并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。**当对象没有覆盖finalize方法或者finalize方法已经被调用过了**，虚拟机将这两种情况都视为没有必要执行。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行**第二次小规模的标记**，如果对象要在finalize方法)中成功拯救自己一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱那基本上它就真的被回收了。

> 个人总结
>
> 对象什么时候会被回收？
>
> 在可达性分析算法中不可达的对象，垃圾回收器准备好释放对象占用的内存，首先调用其finalize方法（如果在finalize中有自救行为，那么会存活）（finalize方法只会调用一次，也就是说最多自救一次），并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

### finalize方法

Java准备好释放一个对象的内存空间之前会调用finalize方法，并且在下一次垃圾回收时才会进行回收。

**用途**（个人总结）：

- 一个对象可以在finalize方法中进行自救，但是finalize方法只会调用一次，也就是只能自救一次。
- 对象终结条件的验证。

## 回收方法区

永久代的垃圾收集主要回收两部分的内容：**废弃常量和无用的类**。

判定一个常量是否为“废弃常量”比较简单（没有地方引用常量对象），而要判定一个类是否是“无用的类”的条件则相对苛刻的多。类需要满足下面3个条件才能算是无用的类：

- 该类所有的实例已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法

### 标记-清除算法

最基础的算法是标记-清除算法。分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的碎片。

![20180913132805](http://111.230.96.19:8081/image/20180913132805.png)

### 复制算法

为了解决效率问题，出现了复制算法。
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
这种算法的代价是将内存缩小为原来的一半。
现在的商业虚拟机都用这种算法，经研究表明，新生代中的对象大多数是朝生夕死的，所以并不需要按照1:1的比例来划分内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收的时候，将Eden和Survivor中还存活着的对象放到另一个Survivor中。

一般不在老年代使用。

![20180913132837](http://111.230.96.19:8081/image/20180913132837.png)

### 标记-整理算法

标记-整理算法，标记过程和标记-清除的一样，但后续步骤不是直接对可回收对象进行到底清理，而是让所有存活的对象都向一端移动，然后直接清理端边界以外的内存。

一般在老年代使用。

![20180913132858](http://111.230.96.19:8081/image/20180913132858.png)

### 分代收集算法

当前商业虚拟机都采用这种算法，这种算法根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点去采用最适当的算法。
新生代适合复制算法；老年代适合“标记-清理”或者“标记-整理”算法。

## 内存分配与回收策略

对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程缓冲，将按线程优先在TALB上分配。
几条最普遍的内存分配规则：

- **对象优先在新生代的Eden区分配**。
- **大对象直接进入老年代**，大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。
- **长期存活的对象将进入老年代**。
- **动态对象年龄判断**，为了能更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenureThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenureThreshold中要求的年龄。
- **空间分配担保**，新生代使用复制算法，为了内存利用率，只使用其中一个Survivor空间作为轮换备份，如果出现大量对象仍然存活的情况，那么就会把无法容纳的对象放入老年代。

## 什么时候进行垃圾回收

**1**

最后总结一下什么时候会触发一次GC，个人经验看，有三种场景会触发GC：

1. 第一种场景应该很明显，当年轻代或者老年代满了，Java虚拟机无法再为新的对象分配内存空间了，那么Java虚拟机就会触发一次GC去回收掉那些已经不会再被使用到的对象
2. 手动调用System.gc()方法，通常这样会触发一次的Full GC以及至少一次的Minor GC
3. 程序运行的时候有一条低优先级的GC线程，它是一条守护线程，当这条线程处于运行状态的时候，自然就触发了一次GC了。

**2**

堆分成两大块：新生代和老年代。对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。

新生代  = 1个Eden区+2个Survivor区。绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发YoungGarbage Collection，即YGC。垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到Survivor区，这个区真是名副其实的存在。Survivor区分为S0和S1两块内存空间，送到哪块空间呢？每次YGC的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果YGC要移送的对象大于Survivor区容量的上限，则直接移交给老年代。假如一些没有进取心的对象以为可以一直在新生代的Survivor区交换来交换去，那就错了。每个对象都有一个计数器，每次YGC都会加1。-XX: MaxTenuringThreshold参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升至老年代。如果该参数配置为1，那么从新生代的Eden区直接移至老年代。默认值是15，可以在Survivor区交换14次之后，晋升至老年代。

![20180913132858](http://111.230.96.19:8081/image/20190403095248.png)

**3**

一个对象实例化时先去看Eden区有没有足够的空间
如果有不进行垃圾回收，对象直接在Eden区存储。
如果Eden区内存已满，会进行一次minor gc。
然后再进行判断Eden区中的内存是否足够
如果不足，则去看Survivor区的内存是否足够。
如果内存足够，把Eden区部分活跃对象保存在Survivor区，然后把对象保存在Eden区。
如果内存不足，向老年代发送请求，查询老年代的内存是否足够
如果老年代内存足够，将部分Survivor区的活跃对象存入老年代。然后把Eden区的活跃对象放入存活区，对象依旧保存在Eden区。
如果老年代内存不足，会进行一次full gc，之后老年代会再进行判断内存是否足够，如果足够同上。如果不足 会抛出OutOfMemoryError。

## 垃圾收集器

### Serial回收器

Serial回收器是一个**主要应用于YGC**的垃圾回收器，采用串行单线程的方式完成GC任务，其中“Stop The World"简称**STW**，即垃圾回收的某个阶段会暂停整个应用程序的执行。FGC的时间相对较长，频繁FGC会严重影响应用程序的性能。主要流程如图所示。

![20180913163010](http://111.230.96.19:8081/image/20190405210340.png)

### CMS回收器

CMS回收器(Concurrent Mark Sweep Collector)是回收停顿时间比较短、目前比较常用的垃圾回收器。它通过

1. 初始标记(InitialMark)

2. 并发标记(Concurrent Mark)

3. 重新标记(Remak)

4. 并发清除(Concurent Sweep)

四个步骤完成垃圾回收工作。

第1、3步的初始标记和重新标记阶段依然会引发STW，而第2、4步的并发标记和并发清除两个阶段可以和应用程序并发执行，也是比较耗时的操作，但并不影响应用程序的正常执行。由于CMS采用的是“标记一清除算法”，因此产生大量的空间碎片。为了解决这个问题，CMS可以通过配置-XX: +UseCMSCompactAtFullColetion参数，强制JVM在FGC完成后对老年代进行压缩，执行一一次空间碎片整理，但是空间碎片整理阶段也会引发STW。为了减少STW次数，CMS还可以通过配置-XX: +CMSFullGCsBeforeCompaction=n参数，在执行了n次FGC后，JVM再在老年代执行空间碎片整理。

### G1回收器

Hotspot在JDK7中推出了新一代 G1 ( Garbage-First Garbage Collector )垃圾回收，通过-XX: +UseG1GC参数启用。和CMS相比，G1具备压缩功能，能避免碎片问题，G1的暂停时间更加可控。性能总体还是非常不错的，简要结构如图所示。

![20180913163010](http://111.230.96.19:8081/image/20190405211041.png)

G1将Java推空间分制成了若干相同大小的区域，即region，包括Eden、Survivor、Old、Humongous四种类型。其中，Humongous是特殊的old类型，专门放置大型对象。这样的划分方式意味着不需要一个连续的内存空间管理对象。G1将空间分为多个区域，优先回收垃圾最多的区域。G1采用的是"Mark-Copy"，有非常好的空间整合能力，不会产生大量的空间碎片。G1的一大优势在于可预测的停顿时间，能够尽可能快地在指定时间内完成垃圾回收任务。在JDK11中，已经将G1设默认垃圾回收器，通过jstat命令可以查看垃圾回收情况。

以下来自：https://blog.csdn.net/coderlius/article/details/79272773

之前几组垃圾收集器都有几个共同点：

1. 年轻代、老年代是独立且连续的内存块；
2. 年轻代收集使用单eden、双survivor进行复制算法；
3. 老年代收集必须扫描整个老年代区域；
4. 都是以尽可能少而块地执行GC为设计原则。

G1垃圾收集器也是以关注延迟为目标、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：

1. G1的设计原则是"首先收集尽可能多的垃圾(Garbage First)"。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；
2. G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；
3. G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；
4. G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。

# 虚拟机类加载机制

定义：虚拟机把描述类的数据从Class文件（一串二进制的字节流）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的**类加载机制**。

## 类加载的时机

类从被加载到虚拟机内存开始，到卸载出内存为止。它的**整个生命周期**包括：**加载、验证、准备、解析、初始化、使用和卸载**7个阶段。（其中验证、准备、解析3个部分统称为连接）。

![20180913163010](http://111.230.96.19:8081/image/20180913163010.png)

其中，**加载、验证、准备、初始化和卸载**5个阶段的顺序是确定的，类加载过程必须按照这种顺序按部就班地开始。而**解析**阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。另外这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段进行的过程中调用、激活另外一个阶段。

虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。
2. 对类进行反射调用的时候。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动的时候，需要指定一个要执行的主类，虚拟机会先初始化这个主类。
5. 使用JDK1.7的动态语言支持的时候。

以上行为称为**主动引用**，除此之外。所以引用类的方法都不会触发初始化，称为**被动引用**。

举例：

- 通过子类引用父类的静态字段，不会导致子类初始化。
- 通过数组来定义类，不会触发此类的初始化。
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
- 等

**接口和类的不同**在于上面的第三点：在类初始化的时候，要求其父类全部都已初始化，但是接口在初始化的时候，并不要求其父类全部完成初始化，只有在真正用到父类接口的时候才会初始化。

## 类加载的过程

**类加载的全过程**，也就是加载、验证、准备、解析、初始化这5个阶段所执行的具体动作。

> 1. 加载阶段读取类文件产生二进制流，并转化为特定的数据结构，初步校验cafe babe魔法数、常量池、文件长度、是否有父类等，然后创建对应类的java.lang.Class实例。
> 2. 连接阶段包括验证、准备、解析三个步骤。验证是更详细的校验，比如final是否合规、类型是否正确、静态变量是否合理等；准备阶段是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局。
> 3. 初始化阶段执行类构造器\<clinit>方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。

### 加载

虚拟机需要完成以下3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

> 加载阶段读入.class文件，class文件时二进制吗，为什么需要使用二进制的方式？
>
> 是二进制文件。
>
> 个人思考：
>
> 1、采用二进制的话，不仅可以从class文件中获取，还可以从其他地方获取。
>
> 2、为了跨平台。

开发人员可以通过自定义类加载器来控制字节流的获取方式。

数组类本身不是由类加载器创建，而是由虚拟机直接创建，但数组的元素类型是由类加载器创建的。如果数组元素是基本类型，那么虚拟机将标记为与引导类加载器关联。

### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

大致会完成下面4个阶段的检验动作：

1. **文件格式验证**
   第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

   - 是否以魔数0xCAFEBABE开头。
   - 主、次版本号是否在当前虚拟机处理范围之内。
   - 常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。
   - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
   - CONSTANT_Utf8_ info型的常量中是否有不符合UTF8编码的数据。
   - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

   实际上，第一阶段的验证的还远不止这些，该验证阶段的**主要目的**是保证输入的字节流能正确地解析并存储于方法区之内，**格式上符合描述一个Java类型信息的要求**。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。

2. **元数据验证**
   第二阶段是对字节码描述的信息进行语义分析，以保证**其描述的信息符合Java语言规范的要求**，这个阶段可能包括的验证点如下:

   - 这个类是否有父类(除了java.lang.Object 之外，所有的类都应当有父类)。
   - 这个类的父类是否继承了不允许被继承的类(被final修饰的类)。
   - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
   - 类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都致，但返回值类型却不同等)。

   第二阶段的**主要目的**是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。

3. **字节码验证**
   第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：

   - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。

   - 保证跳转指令不会跳转到方法体以外的字节码指令上。

   - 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

   如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的。但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。

4. **符号引用验证**
   最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验，通常需要校验下列内容：

   - 符号引用中通过字符串描述的全限定名是否能找到对应的类。
   - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
   - 符号引用中的类、 字段、方法的访问性 ( private、 protected、public、default) 是否可被当前类访问。

   **符号引用验证的目的是确保解析动作能正常执行**，如果无法通过符号引用验证，那么将会抛出一个java. lang. IncompatibleClassChangeError异常的子类，如java.lang.NoSuchFieldError、 java.lang.NoSuchMethodError等。
   对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要(因为对程序运行期没有影响)的阶段。如果所运行的全部代码(包括自己编写的及第三方包中的代码)都已经被反复使用和验证过，那么在实施阶段就可以考虑使用Xveifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

> 验证过程是防止什么问题？验证过程是怎样的？加载和验证的执行顺序？符号引用的含义？
>
> 1、为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
>
> 2、文件格式验证、元数据验证、字节码验证、符号引用验证。
>
> 3、交叉进行，但是加载的开始在验证之前。
>
> 4、符号引用中通过字符串描述的全限定名是否能找到对应的类并且可被当前类访问。

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始化的阶段，这些变量所使用的内存都将在方法区中进行分配。

这里有两点要注意：

- 这个时候内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
- 这里说的初始值通常情况下是数据类型的零值。假设一个变量`public static int v = 123`，那变量在准备阶段后的初始值是0而不是123，因为这个时候还没有执行任何Java方法。把v赋值123是在初始化阶段才会执行。
- `public static final int v = 123`，此时v为123。因为这种变量属于ConstantValue（只限于基本类型和String）。

### 解析

解析阶段是**虚拟机将常量池内的符号引用替换为直接引用的过程**。

> **符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。
>
> **直接引用**：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
>
> 区别（个人思考）：
>
> 符号引用的目标不一定加载到内存中了，而直接引用的目标必然在内存中了。
>
> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

1.  **类或接口的解析**
   假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：
   1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要（**暗示验证阶段会触发其他类的加载**），又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。

   2）如果C是一个数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”, 接着由虚拟机生成一个代表此数组维度和元素的数组对象。

   3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IlegalAccessError异常。

2. **字段解析**
   要解析一个未被解析过的字段符号引用，首先将会对字段表内class index项中索引的CONSTANT Class info 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。

   1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

    2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

   3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

   4）否则，查找失败，抛出java.lang.NoSuchfieldError异常。

   如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IlegalAccessError异常。

   在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。

3. **类方法解析**
   类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。
   1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现classindex中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
   2）如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
   3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
   4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。
   5）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。
   最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IlegalAccessError异常。

4. **接口方法解析**
   接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。

   1）与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口,那就直接抛出java.lang.IncompatibleClassChangeError异常。

   2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

   3）否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

   4）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。

   由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang IlelAccessError异常。 

### 初始化

到这个阶段才真正开始执行类中定义的Java程序代码（或者说是字节码）。

在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源（执行静态块和对静态变量赋值），或者说，初始化阶段是执行类构造器\<clinit\>方法的过程。

一些知识点：

- \<clinit\>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，**定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问**。

  ```
  static {
      i=0;					//可以正常编译通过
      System.out.println(i);	//编译器提示“非法向前引用”
  }
  public static int i=1;
  //结果i为1.
  ```
  
- \<clinit\>不需要显式地调用父类的\<clinit\>，它保证在调用子类的\<clinit\>之前，父类的\<clinit\>方法已经执行过了。因此在虚拟机的第一个被执行\<clinit\>的类肯定是java.lang.Object。

- 由于父类的\<clinit\>先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

- \<clinit\>方法对于类或接口来说不是必需的，如果一个类没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个生成\<clinit\>方法。

- 接口中不能用静态语句块，但仍有变量初始化的赋值操作，因此接口与类一样都会生成\<clinit\>方法。但接口不需要先执行父类的\<clinit\>。另外，接口的实现类在初始化的时候也不会执行接口的\<clinit\>方法。

- 虚拟机会保证一个类的\<clinit\>方法在多线程环境中会被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\<clinit\>方法。

## 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取买描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何获取所需要的类，实现这个动作的代码模块称为**类加载器**。

### 类与类加载器

类加载器虽然只用于实现类的加载，但是它还有一个作用。

比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

### 双亲委派模型

从Java虚拟机的角度来看，只存在两种不同的类加载器：

- 一种是启动类加载器，这个类加载器使用C++来实现，是虚拟机自身的一部分；
- 另一种是所有其他的类加载器，这些类加载器都由Java语言来实现，独立于虚拟机外部，并且全部继承java.lang.ClassLoader。

从Java开发程序员的角度来看：

- 启动类加载器，加载类库（<JAVA_HOME\>\lib目录）。
- 扩展类加载器，加载<JAVA_HOME\>\lib\ext目录中的。
- 应用程序类加载器，默认的类加载器。

![20180915141136](http://111.230.96.19:8081/image/20180915141136.png)

图片展示的是类加载器之间的层次关系，称为类加载器的**双亲委派模型**。

双亲委派模型要求除了顶层的启动类加载器外，其余的都应当有自己的父类加载器。这里的父子关系一般不会以继承来实现，而是以组合的关系来实现。

双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终会应该会传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求时，子加载器才会尝试自己去加载。

这样做有一个显而易见的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如，java.lang.Object，无论哪个类加载器加载这个类，最终都是委派给启动类加载器，因此Object类在程序的各种类加载器环境中都是同一个类。

### 破坏双亲委派模型

双亲委派模型不是一个强制性的约束模型，而是推荐的一种实现方式。

有3次较大规模的被破坏情况：

1. 第一次被破坏是发生在双亲委派模型之前，即JDK1.2发布之前。
2. 第二次是由这个模型自身的缺陷导致的。
3. 第三次是由于用户对程序动态性的追求而导致的。

# Java内存模型与线程

**物理机的内存模型：**

由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引人了一个新的问题：缓存一致性(Cache Chrence)为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议。

![20181210160955](http://111.230.96.19:8081/image/20181210160955.png)

**Java中的内存模型**

Java内存模型的**主要目标**是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

Java内存模型规定了所有的变量都存储在虚拟机的主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的使用操作（读取、赋值等）都必须在工作内存中进行，而不能直接在主内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

![4](/Applications/文件/知识点/img/4.jpg)

> Java内存模型是描述工作内存和主内存之间的交互操作。主内存主要对应Java堆，工作内存主要对应虚拟机栈。

## 内存间交互操作

Java内存模型定义了8种操作来完成主内存和工作内存之间的交互：

- **lock（锁定）**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- **unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read（读取）**：作用于主内存的变量，把一个变量从主内存传输到线程的工作内存中，以便随后的load动作使用。
- **load（载入）**：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。
- **use（使用）**：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码的指令时将会执行这个操作。
- **assgin（赋值）**：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。
- **store（存储）**：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中。
- **write（写入）**：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。

**注意**
read和load操作、store和write必须按照顺序执行，但是不要求连续执行。可能会出现read a、read b、load b、load a。
Java内存模型规定了上述8种操作必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把变化同步回主内存。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量。
- 一个变量在同一时刻只允许一条线程对其进行lock操作。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load和assign操作初始化变量的值。
- 如果一个变量没有被lock，那就不允许对它执行unlock操作。
- 对一个变量执行unlock之前必须先把此变量同步到主内存中。

> 个人理解：
>
> lock和unlock操作不是必需的。

```java
public class Main {
    private static int n = 0;

    public static void main(String[] args) {
        Thread[] threads=new Thread[20];
        for (int i = 0; i < 20; i++) {
            threads[i]=new Thread(new Runnable() {
                @Override
                public void run() {
                    iAdd();
                }
            });
            threads[i].start();
        }

        while (Thread.activeCount()>1){
            Thread.yield();
        }
        System.out.println(n);
    }

    private static void iAdd() {
        for (int i = 0; i < 100; i++) {
            n++;
        }
    }
}

output:
//多次运行
1839
2000
1998
2000
1949
2000
```

字节码分析：

```
public class Main {
    private static int n = 0;
    
	public static void main(String[] args) {
        n++;
    }
}

public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field n:I
         3: iconst_1
         4: iadd
         5: putstatic     #2                  // Field n:I
         8: return
      LineNumberTable:
        line 4: 0
        line 5: 8
```

| 指令      | 作用                                         |
| :-------- | :------------------------------------------- |
| getstatic | 获取指定类的静态域，并将其值压入栈顶         |
| iconst_1  | int型常量值1进栈(iconst_2，int型常量值2进栈) |
| iadd      | 栈顶两int型数值相加，并且结果进栈            |
| putstatic | 为指定的类的静态域赋值                       |

## volatile

https://blog.csdn.net/yinbucheng/article/details/71305951

### volatile原理

在字节码层面上，volatile变量在赋值后会多一个指令，这个指令相当于内存屏障，这个内存屏障保证在指令重排序时不能把后面的指令重排序到内存屏障之前的位置，就是禁止指令重排序优化。另外这个指令能够将变量写回内存，并让其它线程的副本无效。通过这个操作，对volatile变量的修改就可以保证对其它线程可见。

**特性**

当一个变量定义为volatile，它将具备两种特性：

> 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

1. **可见性**
   保证此变量对所有线程的可见性，指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

   由于volatile变量只能保证可见性，不能保证原子性。在不符合以下两条规则的运算场景下，仍然要通过加锁的方式来保证原子性：

   - 运算结果并不依赖变量的当前值（像这种情况就不能：i++），或者能够确保只有单一的线程修改变量的值。
   - 变量不需要与其他的状态变量共同参与不变约束。

   简单地说就是，volatile只保证只读只写的情况，对于同时读写的情况不能保证。
   
   **volatile修饰的变量如果是对象或数组之类的，其含义是对象或数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性。**
   
2. **禁止指令重排序优化**

   DCL失效问题
   有volatile修饰后，变量赋值会多执行一个**内存屏障**操作（重排序时不能把后面的指令重排序到内存屏障之前的位置，换句话说，执行这条指令时，前面的指令已经执行完了）。

> 普通变量和volatile变量的个人理解：
>
> 普通变量并发运算不是安全的在于读写问题。
>
> volatile变量并发运算不是安全的在于操作栈问题。
>
> 指令重排序的个人理解：
>
> 1：A+10
>
> 2：A*2
>
> 3：B+10
>
> 在这三个指令中，CPU可能是123执行，也可能是132或者312执行。如果B加了volatile，那么禁止指令重排序只执行123。

Java内存模型对volatile变量定义的特殊规则：

- 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量v执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。**线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作必须连续一起出现**(这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量v所做的修改后的值)。
- 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。**线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现**(这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改)。

- 假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量w的read或write动作。如果A先于B,那么P先于Q (这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同)。

## 线程的状态

有5种状态，一个线程有且仅有其中的一个状态：

1. 新建（New）：创建后尚未启动的线程处于这种状态。创建线程的方式有三种：第一种是继承自Thread类，第二种是实现Runnable接口，第三种是实现Callable接口。
   Callable与Runnable有两点不同：第一，可以通过call获得返回值。前两种方式都有一个共同的缺陷，即在任务执行完成后，无法直接获取执行结果，需要借助共享变量等获取，而Callable和Future则很好地解决了这个问题；第二，call可以抛出异常，而Runnable只有通过setDfaultUncaughtExceptionHandler的方式才能在主线程中捕捉到子线程异常。
2. 运行（Runnable）：调用start方法之后的状态。此状态的线程可能在执行，也可能在等待CPU为它分配执行时间。
3. 等待（Waiting）：此状态的线程不会被分配CPU执行时间。
4. 阻塞（Blocked）：等待着获取一个锁。
5. 结束（Terminated）：线程已经结束执行。

![20180911214631](http://111.230.96.19:8081/image/2019050601.jpg)

# 线程安全

## Java语言中的线程安全

线程安全的“安全强度”由强至弱排序：

1. **不可变**
   final
2. **绝对线程安全**
3. **相对线程安全**
   相对线程安全就是通常意义上的线程安全。
4. **线程兼容**
   对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。
5. **线程对立**

## 线程安全的实现方法

### **互斥同步（悲观锁）**

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。互斥是实现同步的一种手段。

#### synchronized

在Java中，synchronized关键字是最基本的互斥同步手段。

**synchronized原理**

sychronized 关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

> sychronized同步一部分代码才会加这两个指令，方法级的不会，具体可见第6章类文件结构的第4节的第10部分：同步指令。

在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的：

首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。

其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。所以synchronized是Java语言中一个重量级的操作。

**synchronized的缺陷**

效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程

不够灵活：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。无法知道是否成功获取到锁

**synchronized使用**

synchronized可以加类锁，也可以锁对象，锁普通方法相当于锁对象，静态方法相当于锁类。

> 个人总结
>
> 锁类（对一个方法而言）：不管是不同对象还是同一个对象都会互斥同步。
>
> 锁对象：只有同一个对象会互斥同步。

#### 重入锁

除了synchronized之外，还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。

```java
public class Generator {
    private static int num = 0;
    private static Lock mLock = new ReentrantLock();

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                Generator generator = new Generator();
                generator.add();
            }).start();
        }
    }

    public void add() {
        mLock.lock();
        try {
            num++;
            System.out.println(num);
        } finally {
            mLock.unlock();
        }
    }
}
```

相比synchronized，ReentrantLock增加了一些高级功能，主要有下面三个：

1. **等待可中断**
   当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
2. **可实现公平锁**
   公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
3. **锁可以绑定多个条件**
   锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifAII()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantILock则无须这样做，只需要多次调用newCondition方法即可。

#### 两者的优缺点

##### 区别：

1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是在字节码层面上的。
2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
5. ReentrantLock的性能更好一点，但是synchronized有更大的优化空间。

### 非阻塞同步（乐观锁）

从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施(例如加锁)，那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。

随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据， 那操作就成功了：如果共享数据有争用。产生了冲突，那就再采取其他的补偿措施(最常见的补偿指施就是不断地重试，直到成功为止)，这种乐观的并发策略的许多实现都不需要把线程挂起。

#### CAS（Compare And Swap）指令

一个CAS方法包含三个参数CAS(V,E,N)。V表示要更新的变量，E表示预期的值（希望的值），N表示新值（当前获取到的值）。只有当V的值等于E时，才会将V的值修改为N。如果V的值不等于E，说明已经被其他线程修改了，当前线程可以放弃此操作，也可以再次尝试次操作直至修改成功。基于这样的算法，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰（临界区值的修改），并进行恰当的处理。

上面说到当前线程可以发现其他线程对临界区数据的修改，这点可以使用`volatile`进行保证。

在JDK 1.5之后，Java 程序中才可以使用CAS操作，该操作由sun.mise.Unsafe类里面的compareAndSwapIn()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。

由于Unsafe类不是提供给用户程序调用的类(Unsafe getUnsafe)的代码中限制了只有启动类加载器( Bootstrap ClassLoader)加载的Class才能访问它，因此，如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如java.util.concurrent包里面的整数原子类，其中的compareAndSet()和getAndIncrement等方法都使用了Unsafe 类的CAS操作。

**漏洞**

尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以**通过控制变量值的版本**来保证CAS的正确性。不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

### 无同步方案

**可重入代码**

可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

**线程本地存储**

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

## 锁优化

### 自旋锁与自适应自旋

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，  能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程”稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。**为了让线程等待，我们只需让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。**

在JDK 1.6中引入了**自适应的自旋锁**。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

连续的append方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部，就是扩展到第一个append操作之前直至最后一个append操作之后，这样只需要加锁一次就可以了。