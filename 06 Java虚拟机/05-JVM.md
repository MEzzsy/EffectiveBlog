# Java内存模型与线程

**物理机的内存模型：**

由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引人了一个新的问题：缓存一致性(Cache Chrence)为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议。

![20181210160955](http://111.230.96.19:8081/image/20181210160955.png)

**Java中的内存模型**

Java内存模型的**主要目标**是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

Java内存模型规定了所有的变量都存储在虚拟机的主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的使用操作（读取、赋值等）都必须在工作内存中进行，而不能直接在主内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

![4](/Applications/文件/知识点/img/4.jpg)

> Java内存模型是描述工作内存和主内存之间的交互操作。主内存主要对应Java堆，工作内存主要对应虚拟机栈。

## 内存间交互操作

Java内存模型定义了8种操作来完成主内存和工作内存之间的交互：

- **lock（锁定）**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- **unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read（读取）**：作用于主内存的变量，把一个变量从主内存传输到线程的工作内存中，以便随后的load动作使用。
- **load（载入）**：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。
- **use（使用）**：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码的指令时将会执行这个操作。
- **assgin（赋值）**：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。
- **store（存储）**：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中。
- **write（写入）**：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。

**注意**
read和load操作、store和write必须按照顺序执行，但是不要求连续执行。可能会出现read a、read b、load b、load a。
Java内存模型规定了上述8种操作必须满足如下规则：

- 不允许read和load、store和write操作之一单独出现。
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把变化同步回主内存。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量。
- 一个变量在同一时刻只允许一条线程对其进行lock操作。
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load和assign操作初始化变量的值。
- 如果一个变量没有被lock，那就不允许对它执行unlock操作。
- 对一个变量执行unlock之前必须先把此变量同步到主内存中。

> 个人理解：
>
> lock和unlock操作不是必需的。

```java
public class Main {
    private static int n = 0;

    public static void main(String[] args) {
        Thread[] threads=new Thread[20];
        for (int i = 0; i < 20; i++) {
            threads[i]=new Thread(new Runnable() {
                @Override
                public void run() {
                    iAdd();
                }
            });
            threads[i].start();
        }

        while (Thread.activeCount()>1){
            Thread.yield();
        }
        System.out.println(n);
    }

    private static void iAdd() {
        for (int i = 0; i < 100; i++) {
            n++;
        }
    }
}

output:
//多次运行
1839
2000
1998
2000
1949
2000
```

字节码分析：

```
public class Main {
    private static int n = 0;
    
	public static void main(String[] args) {
        n++;
    }
}

public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field n:I
         3: iconst_1
         4: iadd
         5: putstatic     #2                  // Field n:I
         8: return
      LineNumberTable:
        line 4: 0
        line 5: 8
```

| 指令      | 作用                                         |
| :-------- | :------------------------------------------- |
| getstatic | 获取指定类的静态域，并将其值压入栈顶         |
| iconst_1  | int型常量值1进栈(iconst_2，int型常量值2进栈) |
| iadd      | 栈顶两int型数值相加，并且结果进栈            |
| putstatic | 为指定的类的静态域赋值                       |

## volatile

https://blog.csdn.net/yinbucheng/article/details/71305951

### volatile原理

在字节码层面上，volatile变量在赋值后会多一个指令，这个指令相当于内存屏障，这个内存屏障保证在指令重排序时不能把后面的指令重排序到内存屏障之前的位置，就是禁止指令重排序优化。另外这个指令能够将变量写回内存，并让其它线程的副本无效。通过这个操作，对volatile变量的修改就可以保证对其它线程可见。

**特性**

当一个变量定义为volatile，它将具备两种特性：

> 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

1. **可见性**
   保证此变量对所有线程的可见性，指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

   由于volatile变量只能保证可见性，不能保证原子性。在不符合以下两条规则的运算场景下，仍然要通过加锁的方式来保证原子性：

   - 运算结果并不依赖变量的当前值（像这种情况就不能：i++），或者能够确保只有单一的线程修改变量的值。
   - 变量不需要与其他的状态变量共同参与不变约束。

   简单地说就是，volatile只保证只读只写的情况，对于同时读写的情况不能保证。
   
   **volatile修饰的变量如果是对象或数组之类的，其含义是对象或数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性。**
   
2. **禁止指令重排序优化**

   DCL失效问题
   有volatile修饰后，变量赋值会多执行一个**内存屏障**操作（重排序时不能把后面的指令重排序到内存屏障之前的位置，换句话说，执行这条指令时，前面的指令已经执行完了）。

> 普通变量和volatile变量的个人理解：
>
> 普通变量并发运算不是安全的在于读写问题。
>
> volatile变量并发运算不是安全的在于操作栈问题。
>
> 指令重排序的个人理解：
>
> 1：A+10
>
> 2：A*2
>
> 3：B+10
>
> 在这三个指令中，CPU可能是123执行，也可能是132或者312执行。如果B加了volatile，那么禁止指令重排序只执行123。

Java内存模型对volatile变量定义的特殊规则：

- 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量v执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。**线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作必须连续一起出现**(这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量v所做的修改后的值)。
- 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。**线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现**(这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改)。

- 假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量w的read或write动作。如果A先于B,那么P先于Q (这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同)。

## 线程的状态

有5种状态，一个线程有且仅有其中的一个状态：

1. 新建（New）：创建后尚未启动的线程处于这种状态。创建线程的方式有三种：第一种是继承自Thread类，第二种是实现Runnable接口，第三种是实现Callable接口。
   Callable与Runnable有两点不同：第一，可以通过call获得返回值。前两种方式都有一个共同的缺陷，即在任务执行完成后，无法直接获取执行结果，需要借助共享变量等获取，而Callable和Future则很好地解决了这个问题；第二，call可以抛出异常，而Runnable只有通过setDfaultUncaughtExceptionHandler的方式才能在主线程中捕捉到子线程异常。
2. 运行（Runnable）：调用start方法之后的状态。此状态的线程可能在执行，也可能在等待CPU为它分配执行时间。
3. 等待（Waiting）：此状态的线程不会被分配CPU执行时间。
4. 阻塞（Blocked）：等待着获取一个锁。
5. 结束（Terminated）：线程已经结束执行。

![20180911214631](http://111.230.96.19:8081/image/2019050601.jpg)

# 线程安全

## Java语言中的线程安全

线程安全的“安全强度”由强至弱排序：

1. **不可变**
   final
2. **绝对线程安全**
3. **相对线程安全**
   相对线程安全就是通常意义上的线程安全。
4. **线程兼容**
   对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。
5. **线程对立**

## 线程安全的实现方法

### **互斥同步（悲观锁）**

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。互斥是实现同步的一种手段。

#### synchronized

在Java中，synchronized关键字是最基本的互斥同步手段。

**synchronized原理**

sychronized 关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

> sychronized同步一部分代码才会加这两个指令，方法级的不会，具体可见第6章类文件结构的第4节的第10部分：同步指令。

在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的：

首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。

其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。所以synchronized是Java语言中一个重量级的操作。

**synchronized的缺陷**

效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程

不够灵活：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。无法知道是否成功获取到锁

**synchronized使用**

synchronized可以加类锁，也可以锁对象，锁普通方法相当于锁对象，静态方法相当于锁类。

> 个人总结
>
> 锁类（对一个方法而言）：不管是不同对象还是同一个对象都会互斥同步。
>
> 锁对象：只有同一个对象会互斥同步。

#### 重入锁

除了synchronized之外，还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。

```java
public class Generator {
    private static int num = 0;
    private static Lock mLock = new ReentrantLock();

    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                Generator generator = new Generator();
                generator.add();
            }).start();
        }
    }

    public void add() {
        mLock.lock();
        try {
            num++;
            System.out.println(num);
        } finally {
            mLock.unlock();
        }
    }
}
```

相比synchronized，ReentrantLock增加了一些高级功能，主要有下面三个：

1. **等待可中断**
   当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
2. **可实现公平锁**
   公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
3. **锁可以绑定多个条件**
   锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifAII()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantILock则无须这样做，只需要多次调用newCondition方法即可。

#### 两者的优缺点

##### 区别：

1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是在字节码层面上的。
2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
5. ReentrantLock的性能更好一点，但是synchronized有更大的优化空间。

### 非阻塞同步（乐观锁）

从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施(例如加锁)，那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。

随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据， 那操作就成功了：如果共享数据有争用。产生了冲突，那就再采取其他的补偿措施(最常见的补偿指施就是不断地重试，直到成功为止)，这种乐观的并发策略的许多实现都不需要把线程挂起。

#### CAS（Compare And Swap）指令

一个CAS方法包含三个参数CAS(V,E,N)。V表示要更新的变量，E表示预期的值（希望的值），N表示新值（当前获取到的值）。只有当V的值等于E时，才会将V的值修改为N。如果V的值不等于E，说明已经被其他线程修改了，当前线程可以放弃此操作，也可以再次尝试次操作直至修改成功。基于这样的算法，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰（临界区值的修改），并进行恰当的处理。

上面说到当前线程可以发现其他线程对临界区数据的修改，这点可以使用`volatile`进行保证。

在JDK 1.5之后，Java 程序中才可以使用CAS操作，该操作由sun.mise.Unsafe类里面的compareAndSwapIn()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。

由于Unsafe类不是提供给用户程序调用的类(Unsafe getUnsafe)的代码中限制了只有启动类加载器( Bootstrap ClassLoader)加载的Class才能访问它，因此，如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如java.util.concurrent包里面的整数原子类，其中的compareAndSet()和getAndIncrement等方法都使用了Unsafe 类的CAS操作。

**漏洞**

尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以**通过控制变量值的版本**来保证CAS的正确性。不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

### 无同步方案

**可重入代码**

可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

**线程本地存储**

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

## 锁优化

### 自旋锁与自适应自旋

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，  能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程”稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。**为了让线程等待，我们只需让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。**

在JDK 1.6中引入了**自适应的自旋锁**。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

连续的append方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部，就是扩展到第一个append操作之前直至最后一个append操作之后，这样只需要加锁一次就可以了。