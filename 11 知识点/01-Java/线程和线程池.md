# 线程池

## 简单介绍

线程池的优点：

1. 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。
2. 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞。
3. 能对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。

## 线程池的分类

核心线程指不会被回收的线程。非核心线程指最大线程数减核心线程数，会被回收。

### FixedThreadPool

通过Executors的newFixedThreadPool()方法创建，它是个线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。

```java
public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(
        nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>() 
        );
}
ExecutorService mExecutor = Executors.newFixedThreadPool(5);
```

参数nThreads，就是我们固定的核心线程数量。

### CachedThreadPool

通过Executors的newCachedThreadPool()方法来创建，它是一个数量无限多的线程池，它所有的线程都是非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。

```java
public static ExecutorService new CachedThreadPool(){
    return new ThreadPoolExecutor(
        0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>()
    );
}
```

### ScheduledThreadPool

通过Executors的newScheduledThreadPool()方法来创建，ScheduledThreadPool线程池像是上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。

```java
public static ScheduledThreadPool newScheduledThreadPool(int corePoolSize){
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public ScheduledThreadPoolExecutor(int corePoolSize){
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

参数corePoolSize是核心线程数量。

### SingleThreadExecutor

通过Executors的newSingleThreadExecutor()方法来创建，它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。

```java
public static ExecutorService newSingleThreadExecutor(){
    return new FinalizableDelegatedExecutorService(
        new ThreadPoolExecutor(
        1, 1, 0L, TimeUnit.MILLISECONDS, 
        new LinkedBlockingQueue<Runnable>()));
}
```

## ThreadPoolExecutor

ExecutorService是最初的线程池接口，ThreadPoolExecutor类是对线程池的具体实现，它通过构造方法来配置线程池的参数：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}
```

参数解释：

- corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。
- maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。
- keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。
- unit，枚举时间单位，TimeUnit。
- workQueue，线程池中的任务队列，提交给线程池的runnable会被存储在这个对象上。

线程池的分配遵循这样的规则：

- 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；
- 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；
- 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；
- 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。

# 使用CountDownLatch控制多线程并发等待

转载自[Java并发编程中级篇(三)：使用CountDownLatch控制多线程并发等待](https://my.oschina.net/nenusoul/blog/794634)

你是否遇到这这样一种情况，我们要举行一个视频会议，有若干的参会人员，需要等待所有的人员到齐后视频会议才能开始。

为了解决这个问题，Java API提供了一个线程同步辅助类CountDownLatch，使用这个辅助类可以让线程等待其它线程完成一组操作后才能执行，否则就一直等待。这个类使用一个整形参数来初始化，这个整形参数代表着等待其他线程的数量，使用await()方法让线程开始等待其他线程执行完毕，每一个线程执行完毕后后调用countDown()方法，这个方法会让CountDownLatch内部的计数器减1，当计数器变为0的时候，CountDownLatch类将唤醒所有调用await()方法并进入WAITING状态线程。

下面我们来完成这个视频会议的例子：

创建视频会议线程类VideoConference，并声明一个CountDownLatch属性controller来控制视频会议线程等待所有参会者到齐。会议线程启动后会调用await()方法并进入等待状态，每一个参会者到达后代用arrive()方法，并把controller中的计数器减1，当计数器等于0的时候会议线程继续执行。

```java
public class VideoConference implements Runnable{
    private final CountDownLatch controller;

    public VideoConference(int number) {
        controller = new CountDownLatch(number);
    }

    public void arrive(String name) {
        System.out.printf("%s has arrived.\n", name);
        controller.countDown();
        System.out.printf("VideoConference: Waiting for %d participants.\n", controller.getCount());
    }

    @Override
    public void run() {
        System.out.printf("VidwoConference: Initialization: %d participants.\n", controller.getCount());

        try {
            controller.await();
            System.out.printf("VidwoConference: All the participants have come.\n");
            System.out.printf("VidwoConference: Let's start...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

创建参会者线程类Participant，这个类持有会议类的引用，启动后用一个随机休眠时间来模拟与会者到达所需的时间，休眠结束后代用会议类的arrive(name)方法告诉会议类，与会者到达并把CountDownLatch计数器减1。

```java
public class Participant implements Runnable{
    private String name;
    private VideoConference videoConference;

    public Participant(String name, VideoConference videoConference) {
        this.name = name;
        this.videoConference = videoConference;
    }

    @Override
    public void run() {
        long duration = (long) (Math.random() * 10);
        try {
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        videoConference.arrive(name);
    }
}
```

实现主方法类，这里我们创建并移动一个视频会议，规定参会者有10个人。然后我们启动10个参会者线程，当所有参会者都到达后，视频会议开始执行。

```java
public class Main {
    public static void main(String[] args) {
        VideoConference videoConference = new VideoConference(10);
        Thread threadConference = new Thread(videoConference);
        threadConference.start();

        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(new Participant("P-" + i, videoConference));
        }

        for (int i = 0; i < 10; i++) {
            threads[i].start();
        }
    }
}
```

查看控制台日志，我们看到每次有一个参会者到达都可以调用getCount()方法来获取计数器的值。

```
VidwoConference: Initialization: 10 participants.
P-0 has arrived.
VideoConference: Waiting for 9 participants.
P-4 has arrived.
VideoConference: Waiting for 8 participants.
P-2 has arrived.
VideoConference: Waiting for 7 participants.
P-5 has arrived.
VideoConference: Waiting for 6 participants.
P-8 has arrived.
VideoConference: Waiting for 5 participants.
P-3 has arrived.
VideoConference: Waiting for 4 participants.
P-6 has arrived.
VideoConference: Waiting for 3 participants.
P-1 has arrived.
VideoConference: Waiting for 2 participants.
P-7 has arrived.
VideoConference: Waiting for 1 participants.
P-9 has arrived.
VideoConference: Waiting for 0 participants.
VidwoConference: All the participants have come.
VidwoConference: Let's start...
```

注意，CountDownLatch并不是用来保护共享资源同步访问的，而是用来控制并发线程等待的。并且CountDownLatch只允许进入一次，一旦内部计数器等于0，再调用这个方法将不起作用，如果还有第二次并发等待，你还得创建一个新的CountDownLatch。