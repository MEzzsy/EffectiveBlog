# 线程池

## 简单介绍

线程池的优点：

1. 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。
2. 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞。
3. 能对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。

## 线程池的分类

核心线程指不会被回收的线程。非核心线程指最大线程数减核心线程数，会被回收。

### FixedThreadPool

通过Executors的newFixedThreadPool()方法创建，它是个线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。

```java
public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(
        nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>() 
        );
}
ExecutorService mExecutor = Executors.newFixedThreadPool(5);
```

参数nThreads，就是我们固定的核心线程数量。

### CachedThreadPool

通过Executors的newCachedThreadPool()方法来创建，它是一个数量无限多的线程池，它所有的线程都是非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。

```java
public static ExecutorService new CachedThreadPool(){
    return new ThreadPoolExecutor(
        0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>()
    );
}
```

### ScheduledThreadPool

通过Executors的newScheduledThreadPool()方法来创建，ScheduledThreadPool线程池像是上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。

```java
public static ScheduledThreadPool newScheduledThreadPool(int corePoolSize){
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public ScheduledThreadPoolExecutor(int corePoolSize){
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

参数corePoolSize是核心线程数量。

### SingleThreadExecutor

通过Executors的newSingleThreadExecutor()方法来创建，它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。

```java
public static ExecutorService newSingleThreadExecutor(){
    return new FinalizableDelegatedExecutorService(
        new ThreadPoolExecutor(
        1, 1, 0L, TimeUnit.MILLISECONDS, 
        new LinkedBlockingQueue<Runnable>()));
}
```

## ThreadPoolExecutor

ExecutorService是最初的线程池接口，ThreadPoolExecutor类是对线程池的具体实现，它通过构造方法来配置线程池的参数：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}
```

参数解释：

- corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。
- maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。
- keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。
- unit，枚举时间单位，TimeUnit。
- workQueue，线程池中的任务队列，提交给线程池的runnable会被存储在这个对象上。

线程池的分配遵循这样的规则：

- 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；
- 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；
- 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；
- 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。

# 使用CountDownLatch控制多线程并发等待

转载自[Java并发编程中级篇(三)：使用CountDownLatch控制多线程并发等待](https://my.oschina.net/nenusoul/blog/794634)

你是否遇到这这样一种情况，我们要举行一个视频会议，有若干的参会人员，需要等待所有的人员到齐后视频会议才能开始。

为了解决这个问题，Java API提供了一个线程同步辅助类CountDownLatch，使用这个辅助类可以让线程等待其它线程完成一组操作后才能执行，否则就一直等待。这个类使用一个整形参数来初始化，这个整形参数代表着等待其他线程的数量，使用await()方法让线程开始等待其他线程执行完毕，每一个线程执行完毕后后调用countDown()方法，这个方法会让CountDownLatch内部的计数器减1，当计数器变为0的时候，CountDownLatch类将唤醒所有调用await()方法并进入WAITING状态线程。

下面我们来完成这个视频会议的例子：

创建视频会议线程类VideoConference，并声明一个CountDownLatch属性controller来控制视频会议线程等待所有参会者到齐。会议线程启动后会调用await()方法并进入等待状态，每一个参会者到达后代用arrive()方法，并把controller中的计数器减1，当计数器等于0的时候会议线程继续执行。

```java
public class VideoConference implements Runnable{
    private final CountDownLatch controller;

    public VideoConference(int number) {
        controller = new CountDownLatch(number);
    }

    public void arrive(String name) {
        System.out.printf("%s has arrived.\n", name);
        controller.countDown();
        System.out.printf("VideoConference: Waiting for %d participants.\n", controller.getCount());
    }

    @Override
    public void run() {
        System.out.printf("VidwoConference: Initialization: %d participants.\n", controller.getCount());

        try {
            controller.await();
            System.out.printf("VidwoConference: All the participants have come.\n");
            System.out.printf("VidwoConference: Let's start...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

创建参会者线程类Participant，这个类持有会议类的引用，启动后用一个随机休眠时间来模拟与会者到达所需的时间，休眠结束后代用会议类的arrive(name)方法告诉会议类，与会者到达并把CountDownLatch计数器减1。

```java
public class Participant implements Runnable{
    private String name;
    private VideoConference videoConference;

    public Participant(String name, VideoConference videoConference) {
        this.name = name;
        this.videoConference = videoConference;
    }

    @Override
    public void run() {
        long duration = (long) (Math.random() * 10);
        try {
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        videoConference.arrive(name);
    }
}
```

实现主方法类，这里我们创建并移动一个视频会议，规定参会者有10个人。然后我们启动10个参会者线程，当所有参会者都到达后，视频会议开始执行。

```java
public class Main {
    public static void main(String[] args) {
        VideoConference videoConference = new VideoConference(10);
        Thread threadConference = new Thread(videoConference);
        threadConference.start();

        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(new Participant("P-" + i, videoConference));
        }

        for (int i = 0; i < 10; i++) {
            threads[i].start();
        }
    }
}
```

查看控制台日志，我们看到每次有一个参会者到达都可以调用getCount()方法来获取计数器的值。

```
VidwoConference: Initialization: 10 participants.
P-0 has arrived.
VideoConference: Waiting for 9 participants.
P-4 has arrived.
VideoConference: Waiting for 8 participants.
P-2 has arrived.
VideoConference: Waiting for 7 participants.
P-5 has arrived.
VideoConference: Waiting for 6 participants.
P-8 has arrived.
VideoConference: Waiting for 5 participants.
P-3 has arrived.
VideoConference: Waiting for 4 participants.
P-6 has arrived.
VideoConference: Waiting for 3 participants.
P-1 has arrived.
VideoConference: Waiting for 2 participants.
P-7 has arrived.
VideoConference: Waiting for 1 participants.
P-9 has arrived.
VideoConference: Waiting for 0 participants.
VidwoConference: All the participants have come.
VidwoConference: Let's start...
```

注意，CountDownLatch并不是用来保护共享资源同步访问的，而是用来控制并发线程等待的。并且CountDownLatch只允许进入一次，一旦内部计数器等于0，再调用这个方法将不起作用，如果还有第二次并发等待，你还得创建一个新的CountDownLatch。

# 并发与多线程

**并发**是指在某个时间段内，多任务交替处理的能力。

每个CPU不可能只顾着执行某个进程，让其他进程一直处于等待状态。所以，CPU把可执行时间均匀地分成若干份，每个进程执行一段时间后， 记录当前的工作状态，释放相关的执行资源并进入等待状态，让其他进程抢占CPU资源。

**并行**是指同时处理多任务的能力。

目前，CPU已经发展为多核，可以同时执行多个互不依赖的指令及执行块。

并发与并行两个概念非常容易混淆，它们的核心区别在于进程是否同时执行。以KTV唱歌为例，并行指的是有多少人可以使用话筒同时唱歌；并发指的是同一个话筒被多个人轮流使用。

在并发环境下，由于程序的封闭性被打破，出现了以下特点:

1. 并发程序之间有相互制约的关系。直接制约体现为一个程序需要另一个程序的计算结果：间接制约体现为多个程序竞争共享资源，如处理器、缓冲区等。

2. 并发程序的执行过程是断断续的。程序需要记忆现场指令及执行点。

3. 当并发数设置合理并且CPU拥有足够的处理能力时，并发会提高程序的运行效率。

## Thread的一些方法

笔记：[线程池源码分析](https://mezzsy.github.io/2019/08/29/源码分析/线程池源码分析/)。

|         方法          | 含义                                                         |
| :-------------------: | :----------------------------------------------------------- |
|        sleep()        | 让出CPU的使用，暂停阻塞等待一段时间，时间过了就继续。不释放锁。sleep必须捕获异常。 |
|        wait()         | 让出CPU的使用。Object中的方法。阻塞和等待，但是需要notify来唤醒。释放锁。wait，notify和notifyAll不需要捕获异常 |
|        join()         | 会释放锁，底层用了wait。在一个线程中调用other.join()，将等待other执行完后才继续本线程 |
| notify()、notifyAll() | Object中的方法。唤醒线程                                     |
|        yield()        | 当前线程可转让cpu控制权，让别的就绪状态线程运行（切换），也会等待阻塞一段时间，但是时间不是由客户控制了 |
|     interrupte()      | 打断线程，代替过时方法stop()                                 |
|     setPriority()     | MIN_PRIORITY 最小优先级=1 ， NORM_PRIORITY 默认优先级=5 ，MAX_PRIORITY 最大优先级=10 |

> 带参数的wait方法当超过了指定时间后会移除等待集合，开始竞争锁，而不带wait的方法会一直等待。demo见Java笔记。
>
> notifyAll()是将所有等待此锁的线程移出等待集合，开始竞争锁。而notify方法是选择一个移出等待集合，开始竞争锁。

**sleep和wait的区别**

1.  sleep()方法是属于Thread类的。wait()方法是属于Object类的。
2.  sleep()方法是让出cpu给其他线程，到了指定的时间又会恢复运行状态。在此期间，线程不会释放对象锁。
    调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。
3.  使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 

**notify和notifyAll的区别**

notify是随机唤醒一个线程，notifyAll是唤醒所有线程。

## 创建线程的方式

1. 继承Thread类重写run方法
2. 实现Runnable接口
3. 使用Callable（重写call方法）和Future配合线程池使用。
    线程池的submit方法传入Callable对象，返回Future对象。利用Future对象的get方法得到Callable中call方法返回的值。

如果Runnable和run方法都有呢？

如：

```java
MyThread myThread = new MyThread(myRunnable);
myThread.start();
```

Thread的run方法

```java
public void run() {
    if (target != null) {
        target.run();//target就是传入的Runnable
    }
}
```

Runnable的run方法是在Thread的run方法调用的。

Thread子类如果没有调用super.run()方法，那么传入的Runnable对象的run方法不会被调用。

## 线程间的通信

一般指wait/nofityAll和await/signalAll，这两者的用法可以见Java笔记。

## 有三个线程T1，T2，T3，怎么确保它们按顺序执行

可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。

```java
public class Main {

    public static void main(String[] args) {
        MyThread thread1 = new MyThread(1, null);
        MyThread thread2 = new MyThread(2, thread1);
        MyThread thread3 = new MyThread(3, thread2);
        thread3.start();
        thread2.start();
        thread1.start();
        //输出123
    }

    private static class MyThread extends Thread {
        int id;
        Thread mThread;

        public MyThread(int id, Thread thread) {
            this.id = id;
            mThread = thread;
        }

        @Override
        public void run() {
            super.run();
            try {
                if (mThread != null)
                    mThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(id);
        }
    }

}
```

## 线程对象回收

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        
    }
}).start();
```

以这种方式创建线程，并没有一个引用去引用这个对象，为什么线程对象不会被回收？

start线程后（注意：需要start），在JNI会创建一个全局引用来引用该线程，所以不会被回收。

# 