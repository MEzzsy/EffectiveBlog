

# HaspMap源码总结

1.   HashMap内部采用数组+链表/红黑树，使用散列表解决碰撞冲突的问题，其中数组的每个元素是单链表的头结点，链表/红黑树是用来解决冲突的。
2.   HashMap有两个重要的参数：初始容量和加载因子。初始容量是hash数组的长度，当前加载因子=当前hash数组元素/hash数组长度，最大加载因子为最大能容纳的数组元素个数（默认最大加载因子为0.75），当hash数组中的元素个数超出了最大加载因子和容量的乘积时，要对hashMap进行扩容，扩容过程存在于hashmap的put方法中，扩容过程始终以2次方增长。
3.   3.HashMap是泛型类，key和value可以为任何类型，包括null类型。key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。

## 常量介绍

1. static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; -> 数组默认初始容量：16
2. static final int MAXIMUM_CAPACITY = 1 << 30; -> 数组最大容量2 ^ 30 次方
3. static final float DEFAULT_LOAD_FACTOR = 0.75f; -> 默认负载因子的大小：0.75
4. **static final int MIN_TREEIFY_CAPACITY = 64; -> 树形最小容量：哈希表的最小树形化容量，超过此值允许表中桶(Node)转化成红黑树**
5. **static final int TREEIFY_THRESHOLD = 8; -> 树形阈值：当链表长度达到8时，将链表转化为红黑树**
6. **static final int UNTREEIFY_THRESHOLD = 6; -> 树形阈值：当链表长度小于6时，将红黑树转化为链表**
7. int threshold; -> 可存储key-value 键值对的临界值 需要扩充时;值 = 容量 * 加载因子
8. transient int size; 已存储key-value 键值对数量
9. final float loadFactor; -> 负载因子
10. transient Node< K,V>[] table; -> 链表数组（用于存储hashmap的数据）

## 部分方法解析

**放入（put方法）**

1.   根据key的hash值和数组长度（hash&n-1）得出key在数组中的位置。
2.   如果当前位置没有key，那么将键值对放入。
3.   如果有冲突：
     如果是同一个key，那么更新value。
     如果是数组中的节点是红黑树节点，那么就放入树中。
     如果是链表节点，那么放入单链表中的**最后一个**：
     如果单链表的长度超过树化阈值（8），如果数组长度小于64，那么扩容，否则将此单链表转化为红黑树。
4.   放入键值对后，如果当前键值对数量超过阈值，那么resize。

**resize方法**

1.   首先创建新的数组，长度为原来的2倍，阈值也变为原来的2倍。
2.   然后对原数组的每一个位置进行遍历，如果有链表，那么会把链表分为2份。

> 这里分为2份的原理是：
>
> 比如之前的长度10000（16），一个key为1111，一个key为11111，那么根据
> [hash&(n-1)]，它们放在同一个位置。
>
> 扩容后的长度100000。在扩容的方法中利用的是[hash&oldcap]（oldcap为原来的长度）来区分。那么，1111的是0，11111的不为0，这里就分出了2个链表，如果有多个节点情况也是如此，最终会分为2个链表，一个low，一个high，low的位置为[原来的坐标]，high的坐标为[原来的坐标+oldcap]。

3.   如果红黑树在resize后的大小小于非树化阈值（6），那么变为单链表。

**树化（treeifyBin方法）**

1.   先将单链表节点转为红黑树节点，然后将单链表转为双向链表，再转为红黑树。

**什么时候树化？**

桶为数组中的一个节点，size为HashMap中键值对数量，capacity为数组长度。MIN_TREEIFY_CAPACITY(64)树形最小容量，TREEIFY_THRESHOLD(8)树形阈值，UNTREEIFY_THRESHOLD(6)，threshold阈值。

1.   当单链表中的长度>TREEIFY_THRESHOLD，但是capacity<MIN_TREEIFY_CAPACITY，不会变成红黑树，会进行扩容。
2.   当单链表中的长度>TREEIFY_THRESHOLD，而且capacity>=MIN_TREEIFY_CAPACITY，将此单链表转为红黑树。
3.   只要size>threshold，就会进行扩容。
4.   在扩容的时候，桶中元素个数小于非树化阈值（6），就会把树形的桶元素还原为单链表结构。

> 为什么单链表要转为红黑树？
>
> 红黑树所有的操作最坏情况都是O（log（n））的。
> 红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3。
> 链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。

**删除（remove方法）**

1.   根据key的hash值和数组长度得出key在数组中的位置。
2.   如果当前位置有key，而且key就是要删除的那个key，那么移除。
3.   否则，要么从红黑树中找到那个节点或者从单链表中找到那个节点，然后移除。

移除：

1.   如果是红黑树，按照红黑树的移除操作。
2.   如果是单链表的头部，那么头部变为节点的下一个。
3.   如果是单链表的中间，那么前一个节点的next变为当前结点的下一个。

## 线程安全

为什么HashMap不是线程安全的？举个例子：如果两个线程同时put，如果这两个key的hash相同，那么会放在同一个位置，可能会产生覆盖。

要想使用线程安全的HashMap：Hashtable、ConcurrentHashMap、使用Collections类的synchronizedMap方法包装一下。

## HashMap和Hashtable区别？

简单总结有几点：

1.  HashMap支持null Key和null Value；Hashtable不允许。这是因为HashMap对null进行了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket。

2.  HashMap是非线程安全，HashMap实现线程安全方法为`Map map = Collections.synchronziedMap(new HashMap())；`
    Hashtable是线程安全。

3.  HashMap默认长度是16，扩容是原先的2倍
    Hashtable默认长度是11，扩容是原先的2n+1

4.  HashMap继承AbstractMap
    Hashtable继承了Dictionary

5.  如果在创建时给定了初始化大小，那么HashTable会直接使用给定的大小，而HashMap会将其扩充为2的幂次方大小。 

## ConcurrentHashMap和Hashtable的区别

都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。**简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。**

## HashMap、SparseArray、ArrayMap的区别

1.  在数据量小的时候一般认为1000以下，当key为int的时候，使用SparseArray确实是一个很不错的选择，内存大概能节省30%，相比用HashMap，因为key值不需要装箱，所以时间性能平均来看也优于HashMap。
2.  ArrayMap相对于SparseArray，特点就是key值类型不受限，任何情况下都可以取代HashMap，但是通过研究和测试发现，ArrayMap的内存节省并不明显。并且AS会提示使用SparseArray，但是不会提示使用ArrayMap。

# SparseArray源码总结

当key为int类型的时候可以使用SparseArray。

成员变量

```java
private static final Object DELETED = new Object();
private boolean mGarbage = false;
private int[] mKeys;
private Object[] mValues;
private int mSize;
```

默认大小是10

mKeys是升序排序的。

## 部分方法解析

**放入（put方法)**

1.   二分搜索寻找key在数组中的位置，如果key存在，更新值。反之，返回二分搜索得到的下标。
2.   下标小于size并且key的值被标记为删除，那么更新值。
3.   如果垃圾标记位为true并且size超出容量，那么就运行gc方法，再重新二分搜索，返回新的下标。
4.   如果size大于容量，那么扩容。
5.   如果下标不是最后一个，那么把后面的键值对往后移，然后在当前位置放入键值对。

**移除（remove方法）**

根据key，二分搜索找到下标i。

如果有这个key的话（i>=0）

```java
if (i >= 0) {
    if (mValues[i] != DELETED) {
        mValues[i] = DELETED;
        mGarbage = true;
    }
}
```

**删除（gc方法）**

如果在放入的时候，mGarbage标记位为true并且size大于等于数组的长度，那么进行垃圾删除。

```java
private void gc() {
    int n = mSize;
    int o = 0;
    int[] keys = mKeys;
    Object[] values = mValues;

    for (int i = 0; i < n; i++) {
        Object val = values[i];

        if (val != DELETED) {
            if (i != o) {
                keys[o] = keys[i];
                values[o] = val;
                values[i] = null;
            }

            o++;
        }
    }
    mGarbage = false;
    mSize = o;
}
```

就是把非DELETED的往前移。很简单。

# ArrayList源码总结

默认容量是10，可以自定义容量。

成员变量有个数组`Object[] elementData`，用来存储数据。

## 部分方法解析

**添加数据（add方法）**

在最后面的位置添加。

```
elementData[size++] = e;
```

**插入**

将当前位置的后面的数据往后移，然后在当前位置插入新的数据。

**删除（remove方法）**

如果是最后一个，那么直接令其为null，否则将后面的元素往前移。

**扩容**

在添加和插入之前，会进行扩容判定，如果添加后（size+1）会超出容量，那么会进行扩容。

容量变为原来的1.5倍。

## 总结

-   ArrayList是基于动态数组实现的，随机存取快，但是在增删时候，需要数组的拷贝复制，这个时候明显劣势。
-   它不是线程安全的。
-   它能存放null值。
-   ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍

# LinkedList和ArrayList的区别

1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构
2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针
3. 对于添加和删除操作add和remove，ArrayList要移动数据；LinkedList的添加和删除是O(1)的，但是寻找元素需要时间，它是利用折半的方法查找的，如果index小于size的一半就从前往后，反之从后往前。总的来说LinkedList略占优势。

# 数组或者容器的最大长度

数组的length是int类型，最大值为2的31次方-1，当设置了这个值后会导致内存溢出。那么实际的最大长度是多少呢？这个和虚拟机的参数有关，可以通过设置参数来更改内存最大值。

# LinkedList

LinkedList源码很简单，见[LinkedList源码分析](/Applications/Projects/Blog/源码分析/LinkedList源码分析.md)

> transient 关键字
>
> 1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
>
> 2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
>
> 3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。

# 