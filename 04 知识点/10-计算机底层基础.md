# 二进制

## 补码

正数的补码与原码、反码是一样的，而负数的补码是反码加1的结果。

## 位运算

减法运算符号位也要参与运算。

![](http://111.230.96.19:8081/image/20190311082903.png)

以上示例中的一条电路线在计算机中被称为1位，即1个bit，简写为b。8个bit组成一个单位，称为一个字节，即1个Byte,简写为B。1024 个Byte，简写为KB 1024个KB，简写为MB；1024 个MB，简写为GB，这些都是计算机中常用的存储计量单位。

位移运算。“别人家的开发工程师”在代码中经常使用这种方式进行高低位的截取、哈希计算，甚至运用在乘除法运算中。向右移动1位近似表示除以2，十进制的奇数转化为二进制数后，在向右移时，最右边的1将被直接抹去，说明向右移对于奇数并非完全相当于除以2。在左移<<与右移>>两种运算中，符号位均参与移动，除负数往右移动，高位补1之外，其他情况均在空位处补0。

![](http://111.230.96.19:8081/image/20190311083750.png)

左移运算由于符号位参与向左移动，在移动后的结果中，最左位可能是1或者0，即正数向左移动的结果可能是正，也可能是负；负数向左移动的结果同样可能是正，也可能是负。

```
int a = 0xb0000000;
System.out.println(a << 1);

out:
1610612736
```

对于三个大于号的>>>无符号向右移动(注意不存在<<<无符号向左移动的运算方式)，当向右移动时，正负数高位均补0，**正数不断向右移动的最小值是0，而负数不断向右移动的最小值是1**。无符号意即藐视符号位，符号位失去特权，必须像其他平常的数字位一起向右移动，高位直接补0，根本不关心是正数还是负数。此运算常用在高位转低位的场景中，如表1-2所示分别表示向右移动1 ~ 3位的结果，左侧空位均补0。

![](http://111.230.96.19:8081/image/20190311084110.png)

为何负数不断地无符号向右移动的最小值是1呢？在实际编程中，位移运算仅作用于整型(32位)和长整型( 64位)数上，假如在整型数上移动的位数是32位，无论是否带符号位以及移动方向，均为本身。因为移动的位数是一个mod32的结果，即35>>1与35>>33是一样的结果。如果是长整型，mod 64，即35<<1与35<<65的结果是一样的。负数在无符号往右移动63位时，除最右边为1外，左边均为0,达到最小值1,如果>>>64,则为其原数值本身。

位运算的其他操作比较好理解，包括按位取反(符号为~)、按位与(符号为&)、按位或(符号为|)、按位异或(符号为^)等运算。其中，按位与(&)运算典型的场景是获取网段值。

逻辑或（||）和逻辑与（&&）只能用于布尔类型的条件表达式，7&&8这种是错误的。

# 系统的硬件组成

1.  总线
    贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。
2.  I/O设备
3.  主存
    主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器(DRAM)芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址(数组索引)，这些地址是从零开始的。
    数据一般需要经过处理器才能到达主存。利用直接存储器存取技术，数据可以不通过处理器而直接从磁盘到达主存。
4.  处理器
    中央处理单元(CPU)，简称处理器，是解释(或执行)存储在主存中指令的引擎。

## 64/32位

64位CPU是指CPU内部的通用寄存器的宽度为64比特，支持整数的64比特宽度的算术与逻辑运算。

存储器的大小是依据可寻址的存储器组件大小而变，例如 16位地址总线其寻址能力有 2的 16次方 = 65,536 = 64 KB 的存储器空间，而 32位地址总线其寻址能力有 2的 32次方 = 4,294,967,296 = 4 GB的存储器空间。

>   CPU的64位是指一次处理数据，数据的最大长度。
>
>   地址总线的32位是指寻址能力，最大能寻2的32次-1的地址，也就是4GB；64位就是2的64次-1。

# 进程

进程是操作系统对一个正在运行的程序的一种抽象。

并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。

# 字节序

计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。

大端序是高位字节在低地址，低位字节在高地址。小端序是反过来的。

以8位1字节为单位，`0x1234567`的大端字节序和小端字节序的写法如下。

```
地址：	0x100		0x101		0x102		0x103
大端序： 01 		23 			45 			67
小端序： 67			45			23			01
```

## 为什么会有小端字节序？

计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。

但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。

## 字节序的处理

字节序的处理，就是一句话：

>   **"只有读取的时候，才必须区分字节序，其他情况都不用考虑。"**

处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。然后，就正常使用这个值，完全不用再考虑字节序。

即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。

如值：0x1234567（十进制：19088743），

```clike
大端序： 01 23 45 67
小端序： 67 45 23 01
 
/* 大端字节序 */
val = data[0]<<24 | data[1]<<16 | data[2]<<8 | data[3]<<0

/* 小端字节序 */
val = data[0]<<0 | data[1]<<8 | data[2]<<16 | data[3]<<24
```

```java
public static void main(String[] args) {
        byte[] big = new byte[]{0x01,0x23,0x45,0x67};
        byte[] small = new byte[]{0x67,0x45,0x23,0x01};
        System.out.println(0x1234567);
        System.out.println(big[0]<<24 | big[1]<<16 | big[2]<<8 | big[3]<<0);
        System.out.println(small[0]<<0 | small[1]<<8 | small[2]<<16 | small[3]<<24);
    }

19088743
19088743
19088743
```

