# 语句和表达式

在Kotlin中，if是表达式，而不是语句。

语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。

在Java中， 所有的控制结构都是语句。而在Kotlin中，除了循环(for、do和do/while)以外大多数控制结构都是表达式。

另一方面，Java 中的赋值操作是表达式，在Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。

**例子**

```kotlin
fun main(args: Array<String>) {
    println(max(1，2))
}

fun max(a: Int， b: Int): Int {
    return if (a > b) a else b
}

2
```

# 可变变量和不可变量

val（来自value）不可变引用，对应Java的final变量。

var（来自variable）可变引用，对应Java普通(非final)变量。

lateinit不能修饰基础数据类型，只能修饰引用类型。

# 类型检查和转换

```kotlin
fun main() {
    println(eval(Sum(Sum(Num(1), Num(4)), Num(7))));
}

interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr

fun eval(e: Expr): Int =
        when (e) {
            is Num ->
                e.value
            is Sum ->
                eval(e.right) + eval(e.left)
            else ->
                throw IllegalArgumentException("未知表达式")
        }


12
```

is相当于Java中instanceof，但是不需要显式的类型转换。

可以使用as进行显式转换。

```kotlin
val n = e as Num
```

# 异常

在Java中，受检异常必须显式地处理，要么trycatch受检异常，要么抛出。

和其他许多现代JVM语言一样，Kotlin 并不区分受检异常和未受检异常。不用指定函数抛出的异常，而且可以处理也可以不处理异常。

这种设计是基于Java中使用异常的实践做出的决定，经验显示这些Java规则常常导致许多毫无意义的重新抛出或者忽略异常的代码，而且这些规则不能总是免受可能发生的错误。

Kotlin的try和catch都是表达式，可以返回值。

# 字符串和正则表达式的处理

## 分割字符串

在Java中

```java
public static void main(String[] args) {
    System.out.println(Arrays.toString("12.345-6.7".split(".")));
}

[]
```

如果将点.作为分隔符，那么返回的是一个空数组，因为它将一个正则表达式作为参数，并根据表达式将字符串分割成多个字符串。

而Kotlin的解决办法是

```kotlin
fun main(args: Array<String>) {
    println("12.345-6.7".split(".".toRegex()))
}

[， ， ， ， ， ， ， ， ， ， ]
```

如果传入的是正则表达式，那么用toRegex方法表示这是一个正则表达式，如果不加，就表示不是正则表达式。

```kotlin
fun main(args: Array<String>) {
    println("12.345-6.7".split("."))
}

[12， 345-6， 7]
```

指定多个分隔符

```kotlin
fun main(args: Array<String>) {
    println("12.345-6.7".split("."，"-"))
}

[12， 345， 6， 7]
```

使用扩展函数

```kotlin
fun main(args: Array<String>) {
    val path = "D:\\Android\\Hexo\\hexo\\source\\_posts\\Kotlin.md"
    val directory = path.substringBeforeLast("\\")
    val fullName = path.substringAfterLast("\\")
    val fileName = fullName.substringBeforeLast(".")
    val extension = fullName.substringAfterLast(".")

    println("directory = $directory ， " +
            "fileName = $fileName ， extension = $extension")
}

directory = D:\Android\Hexo\hexo\source\_posts ， fileName = Kotlin ， extension = md
```

使用正则表达式

```kotlin
fun main() {
    val path = "D:\\Android\\Hexo\\hexo\\source\\_posts\\Kotlin.md"
    val regex = """(.+)\\(.+)\.(.+)""".toRegex()
    val matchResult = regex.matchEntire(path)
    if (matchResult != null) {
        val (directory, fileName, extension) = matchResult.destructured
        println("Dir: $directory , name: $fileName , ext: $extension")
    }
}

Dir: D:\Android\Hexo\hexo\source\_posts , name: Kotlin , ext: md
```

正则表达式写在一个三重引号的字符串中。在这样的字符串中，不需要对任何字符进行转义，包括反斜线，所以可以用 \\. 而不是 \\\\. 来表示点，正如写一个普通的字符串字面值一样。这个正则表达式将一个路径分为三个由斜线和点分隔的组。这个 . 模式从字符串的一开始就进行匹配，所以第一组 (.+) 包含最后一个 \\\\ 之前的子串。这个子串包括所有前面的斜线，因为它们匹配“任何字符”的模式。同理，第二组包含最后一个 . 之前的子串，第三组包含剩余部分。

```
(.+)\\(.+)\.(.+)
```

\\\\表示最后一个\\\\，\\.表示最后一个.

## 多行三重引号的字符串

三重引号字符串的目的，不仅在于避免转义字符，而且使它可以包含任何字符，包括换行符。另外，它提供了一种更简单的方法，从而可以简单地把包含换行符的文本嵌入到程序中。例如，可以用ASCII码来画点东西：

```kotlin
fun main() {
    val kotlinLogo = """
        .| //
        .|//
        .|/ \
    """.trimMargin(".")
    println(kotlinLogo)
}

| //
|//
|/ \
```

多行字符串包含三重引号之间的所有字符，包括用于格式化代码的缩进。如果要更好地表示这样的字符串，可以去掉缩进(左边距)。为此，可以向字符串内容添加前缀，标记边距的结尾，然后调用trimMargin来删除每行中的前缀和前面的空格。在前面的例子中，它就是使用了点来作为前缀。

一个三重引号的字符串可以包含换行，而不用专门的字符，比如\n。另一方面，可以不必转义字符所头Windows 风格的路径"C: \\\\Users\\\yole\\\kotlin-book"可以写成 ”'C\Users\yole\kotlin-book'"

还可以在多行字符串中使用字符串模板。因为多行字符串不支持转义序列，如果需要在字符串的内容中使用美元符号的字面量，则必须使用嵌入式表达式，像这样: 

```kotlin
fun main() {
    val price = """${'$'}100"""
    val price2 = """$100"""//貌似不加也可以
    println(price)
    println(price2)
}

$100
$100
```

除了使用ASCII的画图游戏外，需要使用多行字符串的一个地方是测试。在测试中，往往需要执行产生多行文本(例如，网页片段)的操作并将结果与预期输出进行比较。多行字符串完美地解决了将预期输出作为测试的一部分的问题。不需要笨拙的转义或从外部文件中加载文本，只需放入一些引号并将预期的HTML或其他输出放在它们中间。为了更好的格式化，请使用前面提到的trimMargin函数。